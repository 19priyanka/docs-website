{
  "/docs/style-guide/quick-reference/usage-dictionary": [
    {
      "sections": [
        "Callouts",
        "Types of callouts",
        "Caution (callout-caution)",
        "Caution",
        "Important (callout-important)",
        "Important",
        "Tip (callout-tip)",
        "Tip",
        "User-related permissions",
        "Pricing (callout-pricing) Do not use.",
        "Custom callouts",
        "Beta feature",
        "Avoid callout fatigue",
        "Stacked callouts example"
      ],
      "title": "Callouts",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "4c8337fb61ea2576fe138fe4540929e67d501ce2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/callouts/",
      "published_at": "2021-09-01T21:51:53Z",
      "updated_at": "2021-08-20T14:36:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Callouts direct your attention to information of special importance or to information that doesn't fit smoothly into the main text. Consider your reader. If your doc has too many callouts, it might confuse your reader about what matters the most and distract them from what does. Use your callouts judiciously. Recommendation: Skim the complete doc. If there are too many callouts, decide which ones can be removed. Types of callouts Here's an example of the callout format: <Callout variant=\"tip\"> Your tip text goes here. It can have multiple paragraphs. </Callout> Copy On our Docs site, we use these callout classes: Caution (callout-caution) Cautions scream at you that this could cause a crash or cost you data loss beyond the task at hand. Cautions use the callout-caution class. At a traffic light, a Caution would be red. Caution Avoid disabling auto-transaction naming, because metric grouping issues will likely occur. Instead, use API calls to name your transactions. Important (callout-important) Important notes urge awareness that this could impair the task at hand or cost you time if you ignore the text. Important notes use the callout-important class. At a traffic light, an Important note would be yellow. Important Custom events sent via the agent API are not compatible with high security mode. Tip (callout-tip) Tips whisper to you that this is nice to know, like a shortcut, best practice, or reminder, but is unnecessary to complete the task at hand. Tips use the callout-tip class. At a traffic light, a Tip would be a green light. Tip If you have integrated your New Relic account with a ticketing system such as Lighthouse, Pivotal Tracker, or Atlassian JIRA, you can use the note to file a ticket or story. User-related permissions For recommended wording, see User-related language and styles. Pricing (callout-pricing) Do not use. Pricing callouts let you know that you may need a specific subscription level in order to access the product or feature. Pricing callouts use the callout-pricing class. Typically, pricing callouts appear in the intro of a doc. See the example below for standard verbiage in the callout. With the new pricing model, these are rarely used. Tip Access to this feature depends on your subscription level. Custom callouts Custom callouts are available for special cases, such as beta docs. Here's what you can control with custom callouts: Title text: Change the callout label by inserting the title attribute like this: title=\"YOUR CUSTOM TITLE\". When you publish, this field is automatically converted to all capital letters. Color: The color is limited to the color of the variant you include, or if you don't include a variant, you get the default border color (blue-grey). Here is what the code looks like: <Callout variant=\"caution\" title=\"YOUR CUSTOM TITLE\"> Your callout message goes here! </Callout> Copy For beta docs, no watermark is needed–just a custom callout. Also, we recommend that you don't include a variant so you display the default color: Beta feature This feature is still in development, but we encourage you to try it out! Avoid callout fatigue Callout fatigue is what happens when there are too many callouts on a doc. A single callout is a great way to draw attention to important information, but the more callouts there are, the more likely it is that your reader won't read the callouts. Keep these things in mind when you're working with callouts: If you add a callout, remove a callout. Wherever possible, don't increase the number of callouts. Do not use stacked callouts. Stacked callouts are two or more callouts that follow directly one after another. Not only do not use these, but if you see this in a doc, take a few minutes to break these callouts up. Remove outdated callouts. As you're going through the Docs site, if you see a callout that's outdated, for whatever reason, take a few minutes to delete it from the doc. Be stingy in your use of important and warning callouts. If we use important and warning callouts too often, they lose their effectiveness. Stacked callouts example Here's an example of the stacked callouts we'd love to avoid. Tip The more callouts there are, the more difficult it is to spot the information that's important. Important Not everything is important enough to put in a callout. Caution Think carefully before adding another callout on the page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 324.5597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>"
      },
      "id": "60421e82e7b9d23d022a07f2"
    },
    {
      "sections": [
        "Buttons",
        "Button breakdown",
        "Button variations"
      ],
      "title": "Buttons",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "4c755477545c29afb5ae1a309af0f61bbb9091a2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/buttons/",
      "published_at": "2021-09-01T21:51:53Z",
      "updated_at": "2021-08-08T00:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you want to draw someone's attention to a link without putting it in a callout, buttons are an elegant way to do that. Click me! Button breakdown Buttons are created from two React components: <ButtonGroup> and <ButtonLink>. <ButtonGroup> <ButtonLink role=\"button\" to=\"Button URL\" variant=\"primary\" > Button text </ButtonLink> </ButtonGroup> Copy The ButtonLink component has three fields: Field Description role Use the value button. to The button's URL. variant Use the value primary. For alternate button style, use secondary Button variations If you need it, you can put two or more buttons in a row. Simply include additional ButtonLink content within ButtonGroup. Button one Button two Secondary button The source for those buttons looks like this: <ButtonGroup> <ButtonLink role=\"button\" to=\"https://docs.newrelic.com\" variant=\"primary\" > Button one </ButtonLink> <ButtonLink role=\"button\" to=\"https://docs.newrelic.com\" variant=\"primary\" > Button two </ButtonLink> <ButtonLink role=\"button\" to=\"https://docs.newrelic.com\" variant=\"secondary\" > Secondary button </ButtonLink> </ButtonGroup> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 288.91144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": "=&quot;primary&quot; &gt; Button text &lt;&#x2F;ButtonLink&gt; &lt;&#x2F;ButtonGroup&gt; Copy The ButtonLink component has three fields: Field Description role Use the value button. to The button&#x27;s URL. variant Use the value primary. For alternate button <em>style</em>, use secondary Button variations If you need it, you can put two or more buttons"
      },
      "id": "610f1f1064441f5f2947abfa"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Important",
        "Products and features",
        "UI elements and UI page paths",
        "Watermarks"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "7a4d6c67e7c4737414cc99d452577f79dfc79ffc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/capitalization/",
      "published_at": "2021-09-01T21:52:38Z",
      "updated_at": "2021-06-20T21:09:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our Screenshots and images document for more information on our image guidelines. Products and features Item Example We use title case for products. Full Stack Observability We don't capitalize features (including features that used to be products). Use transaction traces to... not Use Transaction Traces to... Our infrastructure monitoring... not Our Infrastructure monitoring... UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing. Watermarks Item Example We use all caps for BETA or NR ONLY. <div id=\"watermark\">NR ONLY</div> Copy Otherwise use sentence case. <div id=\"watermark\">Legacy</div> Copy Include break (br /) for longer watermarks. <div id=\"watermark\">Limited <br /> release</div> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 250.68668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Style</em> <em>guide</em> <em>quick</em> <em>reference</em>",
        "body": ", such as a variable or function, then capitalize it exactly as it&#x27;s used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft <em>Style</em> <em>Guide</em> for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles"
      },
      "id": "60421e50196a67d785a83d97"
    }
  ],
  "/docs/style-guide/writer-workflow/github-intro": [
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "f117225cac5b0cf73daa56bd32807c4a58c4a31e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-09-01T19:30:05Z",
      "updated_at": "2021-09-01T19:30:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.08128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a title or a redirect, create a <em>GitHub</em> issue or, if you&#x27;re a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document&#x27;s URL is based solely on its filename and filepath in the <em>GitHub</em> repo. For more information, see Doc URL. Change titles To change"
      },
      "id": "604220ec196a670d0ba83dd4"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writer-workflow/tech-writer-workflow/",
      "sections": [
        "Tech Writer workflow",
        "Resources",
        "Edit in the UI vs local build",
        "Work on a branch, not a fork",
        "Set up your local environment",
        "Run the site locally",
        "Prerequisites",
        "Build the site",
        "Edit a doc",
        "Commit your changes",
        "Publish your commits",
        "Open your pull request",
        "Preview a doc",
        "Revise and publish a doc",
        "Revert merging"
      ],
      "published_at": "2021-09-01T21:57:08Z",
      "title": "Tech Writer workflow",
      "updated_at": "2021-08-27T04:54:57Z",
      "type": "docs",
      "external_id": "074905b02af0ab6eb53640c1c80e83296a8a0b02",
      "document_type": "page",
      "popularity": 1,
      "body": "This document will guide you through the entire workflow for editing the New Relic documentation site as a New Relic Tech Docs Writer. Resources VSCode (or another text editor) VSCode has great GitHub integrations GitHub account GitHub Desktop Edit in the UI vs local build Need to edit a doc? Use this table to decide where to work! Use the UI for: Use the local build for: Adding content to one doc: Rewriting sentences, or 1-2 lines Editing small amounts of content: updating URLs, deleting typos, etc. Brand new docs Rewrites of more than 1 or 2 lines Any updates to doc frontmatter Title changes Taxonomy changes Metadescription updates Redirects Updating images Editing multiple docs at once Continue reading for instructions on how to edit a doc locally. Work on a branch, not a fork Some teams work on branches, some teams work on forks; the docs team works in branches. As long as a branch has been pushed upstream, this allows us to work collaboratively and ensure that no work is ever lost when someone goes on vacation. To create a branch on the docs-website repo: Open GitHub Desktop Click on Current branch: xxx Click on New Branch You will be prompted to name your new branch. Descriptive names are best. It's a great way to quickly clue people in to what your work is all about. For example, if you are working on What’s New pages, you might name the branch Whats-new-updates. When you create a new branch, don't forget to add the Jira issue's key (DOC-1234) to the branch name and the PR title. Set up your local environment Running the site locally makes testing and previewing large changes much easier. Here's how to get setup: Install GitHub Desktop Sign in to GitHub Desktop. On Macs, click on GitHub Desktop in the top left corner of your screen and select Preferences. Select the blue Sign In button and follow the prompts in the browser window. Navigate to the Docs Site repository on GitHub.com. Click the green Code button and then select Open with GitHub Desktop. Choose the location where you want the repo, and this will clone the entire repository to your local machine at the designated path. You can ensure the repo was cloned by navigating to your local GitHub folder (the default is ~/Documents/github). Once you have cloned the repo, you don't need to clone it again in the future. Run the site locally Build the site locally using the terminal to preview changes before opening a Pull Request. While it's highly recommended to build the site locally, this is technically an optional step. The site will automatically reflect any local changes once build. Node and Yarn are tools used to build the site on your local machine. Prerequisites Install Node Install Yarn npm install -g yarn Build the site In your terminal, go to your cloned repo, docs-website. For example: cd ~/Documents/github/docs-website Run yarn with the following commands: yarn && yarn start The site will take a few minutes to build. Make yourself some tea or coffee. Once it's built, you can access your preview site in your browser by navigating to http://localhost:8000/ Edit a doc Once your local environment and branch are set up, you're ready to edit a doc. Check out the style guide for writing guidelines. First, ensure your Current Branch in GitHub Desktop is set to the correct branch, not Develop. Navigate to the doc you want to edit in Finder. If I wanted to edit a Python agent doc, I would navigate to: ~/Documents/github/docs-website/src/content/docs/agents/python-agent/hosting-services/python-agent-stackato.mdx Edit the doc in your text editor of choice. You should write docs in markdown language. Reference the style guide for help with formatting markdown Save the file with your edits, then follow the same process for any other docs you wish to edit. Commit your changes Once your edits are done, you can commit them. This stages your changes, which you will later push upstream to Github. By pushing your changes, everyone will have access to your branch and commits. Navigate to GitHub Desktop. The left column should have a record of all the edits you have made to docs. In the bottom left corner, name your commit and add a good description of your edits. It should be descriptive enough to ensure that someone can understand all the changes made by simply scanning this description. Click Commit to [yourbranchname] Publish your commits Once you have committed your changes, you're almost ready to open your Pull Request. First, you need to ensure your branch is pushed upstream. On GitHub desktop, click the blue Publish Branch button if available. If you don't see the Publish Branch, click the blue Push Origin button. This will push all your commits upstream and make them available to everyone else through the GitHub repository. Open your pull request Now that your commits are available to everyone, you need to notify people that your changes are ready to be merged into the develop branch. To do this, you open a pull request: On GitHub Desktop, click the blue Create Pull Request button. This will open GitHub in your browser, and prompt you to fill in your pull request. Ensure you're merging from your branch into either the main or develop branch. If you scroll down, you can review all your commits to ensure they reflect all your changes. Just like your commit description, your pull request description should be detailed and give the full context of your changes. Feel free to add any additional context here (issue or Jira number, SMEs, etc.) To request a review from another Tech Writer: in GitHub open the PR, navigate to the Conversation section, and then select or type in a reviewer name in the Reviewer section. Add any relevant labels to your PR. If you do not add from_tw, the PR will not be automatically assigned to another writer for review. Once you're satisfied with your pull request, click the green Create pull request button. You can either publish the changes directly by approving the pull request yourself, or you can request for another Tech Writer to peer edit it. At the bottom of the pull request page, you will see a Checks section. These checks ensure your PR doesn't break the build process of the site. Ensure all checks marked required pass before merging. Once the pull request has passed the checks and it has been approved by another tech writer (or you are confident the changes are ready to be published), click the green Merge pull request button. This will merge your branch and commits into the repository and will begin the build process. If you don't add the from_tw label when you first create a PR, it will not automatically assign a reviewer. If you forget to add the label before opening the PR: Add the from_tw label. Turn the PR into a draft PR. Select the PR is ready for review button at the bottom of the page to reopen the PR. The PR should now have a reviewer. Preview a doc There are two main ways to preview branches you’ve already published and run commits on: Local: Quicker, but requires a semi-substantial amount of setup and familiarity with a terminal. Gatsby Cloud: Full preview of the live site with no overhead, and a very convenient way to share a preview of your draft with a SME. Gatsby Cloud will comment on your PR with a link to a preview version of the site once the build is ready. Building the site generally takes about 15 minutes, but can sometimes take longer if there are a lot of changes. Revise and publish a doc If you’re notified that a reviewer has submitted a review to your file, go to your PR and review the changes. You might see them in the diff view, if they’re part of a review with comments; otherwise, they might appear as copy edits in the file. Respond to any comments in the file. Either reply with follow up discussion, or click Resolve conversation. When you’ve resolved all the comments, and all of the automatic checks have passed, you can merge the pull request. Merging the pull request sets in motion the automated build process and your changes will be published shortly. Note: You will only be able to merge when the Merge pull request button is green. If it’s not green, review for any comments you missed, or other messages that indicate why GitHub is blocking you from merging. Revert merging Remember that you can almost always undo things. If you merge a PR, and then find that you shouldn’t have, you can unmerge with the Revert button. On the Pull requests tab in GitHub, click Closed on the tally bar to see all the issues and PRs that have alredy been merged. Locate the PR you merged, and locate the Revert button. Click Revert. That creates a new PR, which needs to be merged. If you want to reopen it, you need to follow the link back to the original PR and either revert that or reopen it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.2562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " and the PR title. Set up your local environment Running the site locally makes testing and previewing large changes much easier. Here&#x27;s how to <em>get</em> setup: Install <em>GitHub</em> Desktop Sign in to <em>GitHub</em> Desktop. On Macs, click on <em>GitHub</em> Desktop in the top left corner of your screen and select Preferences. Select"
      },
      "id": "60c6a91764441f404d91f8c6"
    },
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-09-01T19:44:23Z",
      "updated_at": "2021-08-26T14:51:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.0597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " the language-specific <em>GitHub</em> links below to <em>get</em> library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on <em>GitHub</em> Metrics Events"
      },
      "id": "603ea196196a670192a83d83"
    }
  ],
  "/docs/style-guide/writer-workflow/github-troubleshooting": [
    {
      "sections": [
        "Diagnostics CLI (nrdiag)",
        "Compatibility",
        "Get started"
      ],
      "title": "Diagnostics CLI (nrdiag)",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Diagnostics CLI (nrdiag)"
      ],
      "external_id": "973501f4752e56caf3d68e37bf21b823d0e42078",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/cross-product-functions/diagnostics-cli-nrdiag/diagnostics-cli-nrdiag/",
      "published_at": "2021-09-02T11:55:19Z",
      "updated_at": "2021-03-13T05:45:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Download latest version The Diagnostics CLI (nrdiag) is a utility that automatically detects common problems with New Relic products. If the Diagnostics CLI detects a problem, it suggests troubleshooting steps. The Diagnostics CLI can also automatically attach troubleshooting data to a New Relic Support ticket. The Diagnostics CLI is open source and is located in GitHub. For additional troubleshooting steps for your agent, check out Not seeing data. Here's an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates zipped troubleshooting logs that are ready to be attached to support tickets. Compatibility The Diagnostics CLI is available for Linux, macOS, and Windows. It can detect common configuration issues for: APM: Available for all APM agents except C SDK. For the Go agent, only basic connectivity checks are available. Browser monitoring: Browser agent detection Infrastructure monitoring: Linux and Windows agents Mobile agents: iOS and Android Synthetic monitoring: Containerized private minions (CPM) The Diagnostics CLI does not require superuser or admin permissions to run, although we recommend those permissions for some checks. It will return an error if it does not have permissions to read the files it scans. Get started To use the Diagnostics CLI: Run the Diagnostics CLI, including task suites and command line options as needed. Include an attachment key when you upload the results to your Support ticket. Optional: Validate your config file settings. Interpret the output. Like any other New Relic tool, the Diagnostics CLI service is designed to protect you and your customers' data privacy. For detailed information, see our Diagnostics CLI licensing and security documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 588.05115,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Support ticket. The Diagnostics CLI is open source and is located in <em>GitHub</em>. For additional <em>troubleshooting</em> steps for your agent, check out Not seeing data. Here&#x27;s an example of the Diagnostics CLI running on Ubuntu Linux. The program checks your New Relic agent configurations for issues and generates"
      },
      "id": "604469f8e7b9d2abb65799f0"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "f117225cac5b0cf73daa56bd32807c4a58c4a31e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-09-01T19:30:05Z",
      "updated_at": "2021-09-01T19:30:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.0812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a title or a redirect, create a <em>GitHub</em> issue or, if you&#x27;re a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document&#x27;s URL is based solely on its filename and filepath in the <em>GitHub</em> repo. For more information, see Doc URL. Change titles To change"
      },
      "id": "604220ec196a670d0ba83dd4"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writer-workflow/tech-writer-workflow/",
      "sections": [
        "Tech Writer workflow",
        "Resources",
        "Edit in the UI vs local build",
        "Work on a branch, not a fork",
        "Set up your local environment",
        "Run the site locally",
        "Prerequisites",
        "Build the site",
        "Edit a doc",
        "Commit your changes",
        "Publish your commits",
        "Open your pull request",
        "Preview a doc",
        "Revise and publish a doc",
        "Revert merging"
      ],
      "published_at": "2021-09-01T21:57:08Z",
      "title": "Tech Writer workflow",
      "updated_at": "2021-08-27T04:54:57Z",
      "type": "docs",
      "external_id": "074905b02af0ab6eb53640c1c80e83296a8a0b02",
      "document_type": "page",
      "popularity": 1,
      "body": "This document will guide you through the entire workflow for editing the New Relic documentation site as a New Relic Tech Docs Writer. Resources VSCode (or another text editor) VSCode has great GitHub integrations GitHub account GitHub Desktop Edit in the UI vs local build Need to edit a doc? Use this table to decide where to work! Use the UI for: Use the local build for: Adding content to one doc: Rewriting sentences, or 1-2 lines Editing small amounts of content: updating URLs, deleting typos, etc. Brand new docs Rewrites of more than 1 or 2 lines Any updates to doc frontmatter Title changes Taxonomy changes Metadescription updates Redirects Updating images Editing multiple docs at once Continue reading for instructions on how to edit a doc locally. Work on a branch, not a fork Some teams work on branches, some teams work on forks; the docs team works in branches. As long as a branch has been pushed upstream, this allows us to work collaboratively and ensure that no work is ever lost when someone goes on vacation. To create a branch on the docs-website repo: Open GitHub Desktop Click on Current branch: xxx Click on New Branch You will be prompted to name your new branch. Descriptive names are best. It's a great way to quickly clue people in to what your work is all about. For example, if you are working on What’s New pages, you might name the branch Whats-new-updates. When you create a new branch, don't forget to add the Jira issue's key (DOC-1234) to the branch name and the PR title. Set up your local environment Running the site locally makes testing and previewing large changes much easier. Here's how to get setup: Install GitHub Desktop Sign in to GitHub Desktop. On Macs, click on GitHub Desktop in the top left corner of your screen and select Preferences. Select the blue Sign In button and follow the prompts in the browser window. Navigate to the Docs Site repository on GitHub.com. Click the green Code button and then select Open with GitHub Desktop. Choose the location where you want the repo, and this will clone the entire repository to your local machine at the designated path. You can ensure the repo was cloned by navigating to your local GitHub folder (the default is ~/Documents/github). Once you have cloned the repo, you don't need to clone it again in the future. Run the site locally Build the site locally using the terminal to preview changes before opening a Pull Request. While it's highly recommended to build the site locally, this is technically an optional step. The site will automatically reflect any local changes once build. Node and Yarn are tools used to build the site on your local machine. Prerequisites Install Node Install Yarn npm install -g yarn Build the site In your terminal, go to your cloned repo, docs-website. For example: cd ~/Documents/github/docs-website Run yarn with the following commands: yarn && yarn start The site will take a few minutes to build. Make yourself some tea or coffee. Once it's built, you can access your preview site in your browser by navigating to http://localhost:8000/ Edit a doc Once your local environment and branch are set up, you're ready to edit a doc. Check out the style guide for writing guidelines. First, ensure your Current Branch in GitHub Desktop is set to the correct branch, not Develop. Navigate to the doc you want to edit in Finder. If I wanted to edit a Python agent doc, I would navigate to: ~/Documents/github/docs-website/src/content/docs/agents/python-agent/hosting-services/python-agent-stackato.mdx Edit the doc in your text editor of choice. You should write docs in markdown language. Reference the style guide for help with formatting markdown Save the file with your edits, then follow the same process for any other docs you wish to edit. Commit your changes Once your edits are done, you can commit them. This stages your changes, which you will later push upstream to Github. By pushing your changes, everyone will have access to your branch and commits. Navigate to GitHub Desktop. The left column should have a record of all the edits you have made to docs. In the bottom left corner, name your commit and add a good description of your edits. It should be descriptive enough to ensure that someone can understand all the changes made by simply scanning this description. Click Commit to [yourbranchname] Publish your commits Once you have committed your changes, you're almost ready to open your Pull Request. First, you need to ensure your branch is pushed upstream. On GitHub desktop, click the blue Publish Branch button if available. If you don't see the Publish Branch, click the blue Push Origin button. This will push all your commits upstream and make them available to everyone else through the GitHub repository. Open your pull request Now that your commits are available to everyone, you need to notify people that your changes are ready to be merged into the develop branch. To do this, you open a pull request: On GitHub Desktop, click the blue Create Pull Request button. This will open GitHub in your browser, and prompt you to fill in your pull request. Ensure you're merging from your branch into either the main or develop branch. If you scroll down, you can review all your commits to ensure they reflect all your changes. Just like your commit description, your pull request description should be detailed and give the full context of your changes. Feel free to add any additional context here (issue or Jira number, SMEs, etc.) To request a review from another Tech Writer: in GitHub open the PR, navigate to the Conversation section, and then select or type in a reviewer name in the Reviewer section. Add any relevant labels to your PR. If you do not add from_tw, the PR will not be automatically assigned to another writer for review. Once you're satisfied with your pull request, click the green Create pull request button. You can either publish the changes directly by approving the pull request yourself, or you can request for another Tech Writer to peer edit it. At the bottom of the pull request page, you will see a Checks section. These checks ensure your PR doesn't break the build process of the site. Ensure all checks marked required pass before merging. Once the pull request has passed the checks and it has been approved by another tech writer (or you are confident the changes are ready to be published), click the green Merge pull request button. This will merge your branch and commits into the repository and will begin the build process. If you don't add the from_tw label when you first create a PR, it will not automatically assign a reviewer. If you forget to add the label before opening the PR: Add the from_tw label. Turn the PR into a draft PR. Select the PR is ready for review button at the bottom of the page to reopen the PR. The PR should now have a reviewer. Preview a doc There are two main ways to preview branches you’ve already published and run commits on: Local: Quicker, but requires a semi-substantial amount of setup and familiarity with a terminal. Gatsby Cloud: Full preview of the live site with no overhead, and a very convenient way to share a preview of your draft with a SME. Gatsby Cloud will comment on your PR with a link to a preview version of the site once the build is ready. Building the site generally takes about 15 minutes, but can sometimes take longer if there are a lot of changes. Revise and publish a doc If you’re notified that a reviewer has submitted a review to your file, go to your PR and review the changes. You might see them in the diff view, if they’re part of a review with comments; otherwise, they might appear as copy edits in the file. Respond to any comments in the file. Either reply with follow up discussion, or click Resolve conversation. When you’ve resolved all the comments, and all of the automatic checks have passed, you can merge the pull request. Merging the pull request sets in motion the automated build process and your changes will be published shortly. Note: You will only be able to merge when the Merge pull request button is green. If it’s not green, review for any comments you missed, or other messages that indicate why GitHub is blocking you from merging. Revert merging Remember that you can almost always undo things. If you merge a PR, and then find that you shouldn’t have, you can unmerge with the Revert button. On the Pull requests tab in GitHub, click Closed on the tally bar to see all the issues and PRs that have alredy been merged. Locate the PR you merged, and locate the Revert button. Click Revert. That creates a new PR, which needs to be merged. If you want to reopen it, you need to follow the link back to the original PR and either revert that or reopen it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.85275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "This document will guide you through the entire workflow for editing the New Relic documentation site as a New Relic Tech Docs Writer. Resources VSCode (or another text editor) VSCode has great <em>GitHub</em> integrations <em>GitHub</em> account <em>GitHub</em> Desktop Edit in the UI vs local build Need to edit a doc? Use"
      },
      "id": "60c6a91764441f404d91f8c6"
    }
  ],
  "/docs/style-guide/writer-workflow/peer-editor-workflow": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writer-workflow/tech-writer-workflow/",
      "sections": [
        "Tech Writer workflow",
        "Resources",
        "Edit in the UI vs local build",
        "Work on a branch, not a fork",
        "Set up your local environment",
        "Run the site locally",
        "Prerequisites",
        "Build the site",
        "Edit a doc",
        "Commit your changes",
        "Publish your commits",
        "Open your pull request",
        "Preview a doc",
        "Revise and publish a doc",
        "Revert merging"
      ],
      "published_at": "2021-09-01T21:57:08Z",
      "title": "Tech Writer workflow",
      "updated_at": "2021-08-27T04:54:57Z",
      "type": "docs",
      "external_id": "074905b02af0ab6eb53640c1c80e83296a8a0b02",
      "document_type": "page",
      "popularity": 1,
      "body": "This document will guide you through the entire workflow for editing the New Relic documentation site as a New Relic Tech Docs Writer. Resources VSCode (or another text editor) VSCode has great GitHub integrations GitHub account GitHub Desktop Edit in the UI vs local build Need to edit a doc? Use this table to decide where to work! Use the UI for: Use the local build for: Adding content to one doc: Rewriting sentences, or 1-2 lines Editing small amounts of content: updating URLs, deleting typos, etc. Brand new docs Rewrites of more than 1 or 2 lines Any updates to doc frontmatter Title changes Taxonomy changes Metadescription updates Redirects Updating images Editing multiple docs at once Continue reading for instructions on how to edit a doc locally. Work on a branch, not a fork Some teams work on branches, some teams work on forks; the docs team works in branches. As long as a branch has been pushed upstream, this allows us to work collaboratively and ensure that no work is ever lost when someone goes on vacation. To create a branch on the docs-website repo: Open GitHub Desktop Click on Current branch: xxx Click on New Branch You will be prompted to name your new branch. Descriptive names are best. It's a great way to quickly clue people in to what your work is all about. For example, if you are working on What’s New pages, you might name the branch Whats-new-updates. When you create a new branch, don't forget to add the Jira issue's key (DOC-1234) to the branch name and the PR title. Set up your local environment Running the site locally makes testing and previewing large changes much easier. Here's how to get setup: Install GitHub Desktop Sign in to GitHub Desktop. On Macs, click on GitHub Desktop in the top left corner of your screen and select Preferences. Select the blue Sign In button and follow the prompts in the browser window. Navigate to the Docs Site repository on GitHub.com. Click the green Code button and then select Open with GitHub Desktop. Choose the location where you want the repo, and this will clone the entire repository to your local machine at the designated path. You can ensure the repo was cloned by navigating to your local GitHub folder (the default is ~/Documents/github). Once you have cloned the repo, you don't need to clone it again in the future. Run the site locally Build the site locally using the terminal to preview changes before opening a Pull Request. While it's highly recommended to build the site locally, this is technically an optional step. The site will automatically reflect any local changes once build. Node and Yarn are tools used to build the site on your local machine. Prerequisites Install Node Install Yarn npm install -g yarn Build the site In your terminal, go to your cloned repo, docs-website. For example: cd ~/Documents/github/docs-website Run yarn with the following commands: yarn && yarn start The site will take a few minutes to build. Make yourself some tea or coffee. Once it's built, you can access your preview site in your browser by navigating to http://localhost:8000/ Edit a doc Once your local environment and branch are set up, you're ready to edit a doc. Check out the style guide for writing guidelines. First, ensure your Current Branch in GitHub Desktop is set to the correct branch, not Develop. Navigate to the doc you want to edit in Finder. If I wanted to edit a Python agent doc, I would navigate to: ~/Documents/github/docs-website/src/content/docs/agents/python-agent/hosting-services/python-agent-stackato.mdx Edit the doc in your text editor of choice. You should write docs in markdown language. Reference the style guide for help with formatting markdown Save the file with your edits, then follow the same process for any other docs you wish to edit. Commit your changes Once your edits are done, you can commit them. This stages your changes, which you will later push upstream to Github. By pushing your changes, everyone will have access to your branch and commits. Navigate to GitHub Desktop. The left column should have a record of all the edits you have made to docs. In the bottom left corner, name your commit and add a good description of your edits. It should be descriptive enough to ensure that someone can understand all the changes made by simply scanning this description. Click Commit to [yourbranchname] Publish your commits Once you have committed your changes, you're almost ready to open your Pull Request. First, you need to ensure your branch is pushed upstream. On GitHub desktop, click the blue Publish Branch button if available. If you don't see the Publish Branch, click the blue Push Origin button. This will push all your commits upstream and make them available to everyone else through the GitHub repository. Open your pull request Now that your commits are available to everyone, you need to notify people that your changes are ready to be merged into the develop branch. To do this, you open a pull request: On GitHub Desktop, click the blue Create Pull Request button. This will open GitHub in your browser, and prompt you to fill in your pull request. Ensure you're merging from your branch into either the main or develop branch. If you scroll down, you can review all your commits to ensure they reflect all your changes. Just like your commit description, your pull request description should be detailed and give the full context of your changes. Feel free to add any additional context here (issue or Jira number, SMEs, etc.) To request a review from another Tech Writer: in GitHub open the PR, navigate to the Conversation section, and then select or type in a reviewer name in the Reviewer section. Add any relevant labels to your PR. If you do not add from_tw, the PR will not be automatically assigned to another writer for review. Once you're satisfied with your pull request, click the green Create pull request button. You can either publish the changes directly by approving the pull request yourself, or you can request for another Tech Writer to peer edit it. At the bottom of the pull request page, you will see a Checks section. These checks ensure your PR doesn't break the build process of the site. Ensure all checks marked required pass before merging. Once the pull request has passed the checks and it has been approved by another tech writer (or you are confident the changes are ready to be published), click the green Merge pull request button. This will merge your branch and commits into the repository and will begin the build process. If you don't add the from_tw label when you first create a PR, it will not automatically assign a reviewer. If you forget to add the label before opening the PR: Add the from_tw label. Turn the PR into a draft PR. Select the PR is ready for review button at the bottom of the page to reopen the PR. The PR should now have a reviewer. Preview a doc There are two main ways to preview branches you’ve already published and run commits on: Local: Quicker, but requires a semi-substantial amount of setup and familiarity with a terminal. Gatsby Cloud: Full preview of the live site with no overhead, and a very convenient way to share a preview of your draft with a SME. Gatsby Cloud will comment on your PR with a link to a preview version of the site once the build is ready. Building the site generally takes about 15 minutes, but can sometimes take longer if there are a lot of changes. Revise and publish a doc If you’re notified that a reviewer has submitted a review to your file, go to your PR and review the changes. You might see them in the diff view, if they’re part of a review with comments; otherwise, they might appear as copy edits in the file. Respond to any comments in the file. Either reply with follow up discussion, or click Resolve conversation. When you’ve resolved all the comments, and all of the automatic checks have passed, you can merge the pull request. Merging the pull request sets in motion the automated build process and your changes will be published shortly. Note: You will only be able to merge when the Merge pull request button is green. If it’s not green, review for any comments you missed, or other messages that indicate why GitHub is blocking you from merging. Revert merging Remember that you can almost always undo things. If you merge a PR, and then find that you shouldn’t have, you can unmerge with the Revert button. On the Pull requests tab in GitHub, click Closed on the tally bar to see all the issues and PRs that have alredy been merged. Locate the PR you merged, and locate the Revert button. Click Revert. That creates a new PR, which needs to be merged. If you want to reopen it, you need to follow the link back to the original PR and either revert that or reopen it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.70866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tech Writer <em>workflow</em>",
        "sections": "Tech Writer <em>workflow</em>",
        "body": "This document will guide you through the entire <em>workflow</em> for editing the New Relic documentation site as a New Relic Tech Docs Writer. Resources VSCode (or another text <em>editor</em>) VSCode has great GitHub integrations GitHub account GitHub Desktop Edit in the UI vs local build Need to edit a doc? Use"
      },
      "id": "60c6a91764441f404d91f8c6"
    },
    {
      "sections": [
        "Use TCP endpoint to forward logs to New Relic",
        "Compatibility and requirements",
        "Important",
        "Configure rsyslog",
        "Legacy config file for rsyslog 7 or earlier",
        "Configure syslog-ng",
        "Tip"
      ],
      "title": "Use TCP endpoint to forward logs to New Relic",
      "type": "docs",
      "tags": [
        "Logs",
        "Log management",
        "Log API"
      ],
      "external_id": "3f572fe998dd7f72516a7b654295b779ff290176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/log-management/log-api/use-tcp-endpoint-forward-logs-new-relic/",
      "published_at": "2021-09-01T23:13:09Z",
      "updated_at": "2021-08-26T21:31:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We offer a wide range of solutions to get your log data into New Relic. But in other situations where you don't have log forwarders (such as CDNs, hardware devices, or managed services), you can use syslog protocols via a TCP endpoint. You can forward your logs to New Relic using syslog clients such as rsyslog and syslog-ng. Compatibility and requirements To forward logs to New Relic using a syslog client, you need: A valid New Relic license key for the account you want to send logs to Some minor changes to the syslog client's configuration, as explained in this document Important Currently, our syslog endpoint only supports accounts in our US data center. Configure rsyslog To forward logs to New Relic with rsyslog: Install packages required to allow rsyslog to send logs using TLS encryption: sudo yum install rsyslog-gnutls ca-certificates Copy Optional: Configure rsyslog to tail log files and forward their contents to New Relic. Add the following to the /etc/rsyslog.conf file in order to enable its text file input module: module(load=\"imfile\" PollingInterval=\"10\" statefile.directory=\"/var/spool/rsyslog\" ) Copy In the /etc/rsyslog.d/ directory, create a text file named newrelic.conf. Explicitly include the newly created newrelic.conf to the /etc/rsyslog.d/ file: include(file=\"/etc/rsyslog.conf.d/newrelic.conf\") Copy Add the following to newrelic.conf, replacing YOUR_LICENSE_KEY with your New Relic license key: ## Specify each of the files to be tailed in case step 1 is done input(type=\"imfile\" ruleset=\"infiles\" Tag=\"<YOUR_FILE_TAG>\" File=\"<PATH_TO_FILE>\" StateFile=\"<UNIQUE_STATEFILE_NAME >\") ## Template expected by the New Relic Syslog endpoint template(name=\"newrelic-rfc5424\" type=\"string\" string=\"<YOUR_LICENSE_KEY> <%pri%>%protocol-version% %timestamp:::date-rfc3339% %hostname% %app-name% %procid% %msgid% %structured-data% %msg%\\n\" ) ## Configure TLS and log forwarding global(DefaultNetstreamDriver=\"gtls\" DefaultNetstreamDriverCAFile=\"/etc/ssl/certs/ca-certificates.crt\" ) action(type=\"omfwd\" Target=\"newrelic.syslog.nr-data.net\" Port=\"6514\" Protocol=\"tcp\" Template=\"newrelic-rfc5424\" ResendLastMSGOnReconnect=\"on\" StreamDriver=\"gtls\" StreamDriverAuthMode=\"x509/name\" StreamDriverPermittedPeers=\"*.syslog.nr-data.net\" StreamDriverMode=\"1\" ) Copy Restart the rsyslog service by running: sudo systemctl restart rsyslog Copy Check your New Relic account for logs. Legacy config file for rsyslog 7 or earlier If you are using rsyslog version 7 or below, the configuration files need to be adapted to the obsolete legacy format. This format is only kept for retro compatibility purposes. We strongly recommend to avoid using it, as stated in the rsyslog documentation. Install packages required to allow rsyslog to send logs using TLS encryption: sudo yum install rsyslog-gnutls ca-certificates Copy Optional: Configure rsyslog to tail log files and forward their contents to New Relic. Add the following to the /etc/rsyslog.conf file in order to enable its text file input module: $ModLoad imfile $InputFilePollInterval 10 $PrivDropToGroup adm $WorkDirectory /var/spool/rsyslog Copy In the /etc/rsyslog.d/ directory, create a text file named newrelic.conf. Explicitly include the newly created newrelic.conf to the /etc/rsyslog.d/ file: $IncludeConfig /etc/rsyslog.conf.d/newrelic.conf Copy Add the following to newrelic.conf, replacing `YOUR_LICENSE_KEY with your New Relic license key: ## Template expected by the New Relic Syslog endpoint $template NRLogFormat,\"YOUR_LICENSE_KEY <%pri%>%protocol-version% %timestamp:::date-rfc3339% %hostname% %app-name% %procid% %msgid% %structured-data% %msg%\\n\" ## Specify each of the files to be tailed in case step 1 is done $InputFileName /path/to/file $InputFileTag <YOUR_FILE_TAG> $InputFileStateFile <UNIQUE_STATEFILE_NAME> $InputFileSeverity info $InputRunFileMonitor ## Configure TLS and log forwarding $DefaultNetstreamDriverCAFile /etc/ssl/certs/ca-certificates.crt $ActionSendStreamDriver gtls $ActionSendStreamDriverMode 1 $ActionSendStreamDriverAuthMode x509/name $ActionSendStreamDriverPermittedPeer *.syslog.nr-data.net *.* @@newrelic.syslog.nr-data.net:6514;NRLogFormat Copy Restart the rsyslog service by running: sudo systemctl restart rsyslog Copy Check your New Relic account for logs. Configure syslog-ng To forward logs to New Relic with syslog-ng: Install ca-certificates required to allow syslog-ng to send logs using TLS encryption: sudo yum install ca-certificates Copy Open the syslog-ng configuration file (/etc/syslog-ng/syslog-ng.conf) in a text editor. Define the sources to be monitored by adding: source s_src { internal(); }; Copy Optional: Configure syslog-ng to tail files by adding the following to the Sources configuration block: source s_files { file(\"<PATH_TO_FILE>\"); }; Copy Define the New Relic syslog format and add your New Relic license key: template NRFormat { template(\"YOUR_LICENSE_KEY <${PRI}>1 ${ISODATE} ${HOST:--} ${PROGRAM:--} ${PID:--} ${MSGID:--} ${SDATA:--} $MSG\\n\"); template_escape(no); }; Copy Add the New Relic Syslog endpoint: destination d_newrelic { network(\"newrelic.syslog.nr-data.net\" port(6514) transport(\"tls\") tls(peer-verify(no)) template(NRFormat) ); }; Copy Add the following output to the log path configuration block: log { source(s_src); source(s_files); ## in case step 4 is implemented. destination(d_newrelic); }; Copy Restart syslog-ng by running: sudo service syslog-ng restart Copy Check your New Relic account for logs. Tip If you are running syslog-ng from a Docker container and experience issues, check balait/syslog image documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.965675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " $DefaultNetstreamDriverCAFile &#x2F;etc&#x2F;ssl&#x2F;certs&#x2F;ca-certificates.crt $ActionSendStreamDriver gtls $ActionSendStreamDriverMode 1 $ActionSendStreamDriverAuthMode x509&#x2F;name $ActionSendStreamDriverPermitted<em>Peer</em> *.syslog.nr-data.net *.* @@newrelic.syslog.nr-data.net:6514;NRLogFormat Copy Restart the rsyslog service"
      },
      "id": "603e7d6764441f1a774e88a0"
    },
    {
      "sections": [
        "Troubleshooting docs guide",
        "Problem",
        "Solution",
        "Cause",
        "Related info"
      ],
      "title": "Troubleshooting docs guide",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Article templates"
      ],
      "external_id": "ba7c99eb79d6fa7ad574db5768a742a4d2084a41",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/article-templates/troubleshooting-docs-guide/",
      "published_at": "2021-09-01T21:50:47Z",
      "updated_at": "2021-05-10T03:34:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our troubleshooting docs have these main sections: problem, solution, and (optionally) cause. Otherwise, a troubleshooting doc uses the basic doc template Problem Generally, this is the who, what, when, and where of the troubleshooting doc. Provide a clear, concise description of the problem the user is trying to solve. Include steps for reproduction, symptoms, and other key points when applicable. Re-state the problem in different ways if needed, to ensure customers can find this doc via Google. If the problem text is very short, you can include the cause text here. Solution Generally, this is the how of the troubleshooting doc. Provide an ordered list of steps to guide users through the solution. If there are multiple causes and solutions, consider creating a standard, basic page doc rather than using the troubleshooting template. Consider the best approach to help the reader, and discuss your reasoning with your peer editor. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn't solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes the problem and cause. Do not include a solution. Also, include any statements promising that the issue will be fixed in a future release. Cause Generally, this is the why of the troubleshooting doc, and is optional. The Cause section is particularly useful when the product works in an unintuitive way. Provide background information or context that gives the user additional insight into the problem. If the problem and the cause text are both very short, you can include the cause in the Problem section. Related info In general, leave blank. The standard For more help footer block will appear automatically when published. If necessary, use this section to link to other, related docs if it does not make sense to refer to them within the context of other information in the troubleshooting doc itself.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.95677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", and discuss your reasoning with your <em>peer</em> <em>editor</em>. If the issue you are documenting is more of a known issue (FYI in nature), or if it doesn&#x27;t solve the issue: Incorporate the information into other relevant docs. Do not refer to it as a known issue. OR Create a troubleshooting doc that describes"
      },
      "id": "6043f591196a675446960f74"
    }
  ],
  "/docs/style-guide/writer-workflow/tech-writer-workflow": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writer-workflow/peer-editor-workflow/",
      "sections": [
        "Peer editor workflow",
        "Peer editing workflow in GitHub",
        "Developmental edit pass",
        "Copy edit workflow"
      ],
      "published_at": "2021-09-01T21:56:17Z",
      "title": "Peer editor workflow",
      "updated_at": "2021-06-14T00:56:46Z",
      "type": "docs",
      "external_id": "c5cade26eea3b846e8c6cc5f3b89552147d724be",
      "document_type": "page",
      "popularity": 1,
      "body": "Use this document to learn how to review and peer edit docs for you fellow writers in GitHub. Check the Tech Writer workflow doc for info on how to set up your local environment. To troubleshoot GitHub issues, see our guide. Peer editing workflow in GitHub If you’re peer editing a doc or have been otherwise assigned to a PR as a reviewer, you have a few choices for how and where to do the work. The most streamlined and open-source approach is to do the edit using GitHub options, rather than copying the file to Google Docs and editing there. Developmental edit pass For cases where you have questions and suggestions rather than straight copy edits, follow these steps. Open the PR that you’re assigned to review. On the Files changed tab, you can either: Click Review changes and then select one of the following: Comment - use if you have a comment that doesn’t require follow up. Approve - use if you just want to approve the PR. You can request changes in the Leave a comment area, and select Approve if you want to let the writer make the edits and merge the file without a follow-up review from you. Request changes - use for times when you want to make sure the changes you request are included. You’ll be notified with any updates that the writer makes. OR, start making comments on lines or sections of the doc. To do this, click the add comment icon , and leave an edit or comment for that specific line in the page. With this option, you get the choice between adding a single comment or starting a review. If you’re going to make comments throughout a doc, choose Start a review so the comments will all be rolled into one commit. Click Finish your review to complete your review. This triggers a notification to the writer alerting them that you’ve made suggestions. Copy edit workflow If you have copy edits for a file rather than comments and suggestions, you can make the changes to the file in different ways. Here are two main options: Edit using the GitHub browser: On the Files changed tab, in the diff window click the editing button (three dots). When you finish your edits, add a comment at the bottom of the file and choose to either commit the changes directly, or create a branch and start a pull request. Choose to branch and start a pull request if you expect a writer to review the diff and accept or revise your edits. Edit locally: Check out the branch containing the file you want to edit. In GitHub Desktop, click the Current branch down arrow and select the branch. Then, make the edits on your local drive, save, and commit your changes to the branch. Note that this approach adds your edits to the open pull request. You can now see the changes you added to the file on the Files changed tab in the PR. These are just a few of many editing options. You’ll find your preferred way, just as with any other tool.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 871.3416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Peer editor <em>workflow</em>",
        "sections": "Peer editor <em>workflow</em>",
        "body": "Use this document to learn how to review and peer edit docs for you fellow writers in GitHub. Check the <em>Tech</em> <em>Writer</em> <em>workflow</em> doc for info on how to set up your local environment. To troubleshoot GitHub issues, see our guide. Peer editing <em>workflow</em> in GitHub If you’re peer editing a doc or have been"
      },
      "id": "60c6a94ee7b9d21cd1d6779f"
    },
    {
      "sections": [
        "Delete a document",
        "Caution"
      ],
      "title": "Delete a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "46997b8327630e068987c09788cb6e5115896517",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/delete-document/",
      "published_at": "2021-09-01T21:35:11Z",
      "updated_at": "2021-09-01T21:35:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Caution When you delete a document, its content and its redirects will still be available in the GitHub commit history. In general, if you're not on the New Relic Docs team, please don't delete any docs. Instead, file an issue and someone on our team will help you out. If you are certain you want to delete a document, do this: Locate the mdx file of the doc you want to delete. Take care of redirects: Find the most relevant doc to redirect readers to. Add the deleted doc's URL as a redirect. Copy any existing redirects from the deleted doc and add them to the new doc. Delete the doc's title and path from the appropriate nav file. Delete the doc mdx file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.44272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> style guide"
      },
      "id": "60422009e7b9d21bd22a07d4"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "f117225cac5b0cf73daa56bd32807c4a58c4a31e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-09-01T19:30:05Z",
      "updated_at": "2021-09-01T19:30:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 197.7096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Tech</em> <em>writer</em> style guide"
      },
      "id": "604220ec196a670d0ba83dd4"
    }
  ],
  "/docs/style-guide/writing-guidelines/code-formatting-guidelines-var-mark": [
    {
      "sections": [
        "Code examples",
        "For inline code or data (<code>)",
        "For multi-line code blocks (<pre>)",
        "Highlight user input with <var>",
        "Highlight important sections with <mark>",
        "Add syntax highlighting",
        "Link to other docs"
      ],
      "title": "Code examples",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c8690ad4669d2a9b3eadad8a7bcbc1e05ff9093c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/code-examples/",
      "published_at": "2021-09-01T21:52:38Z",
      "updated_at": "2021-03-16T09:10:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We use a variety of formatting to highlight code or other technical language. You can use the <code>, <pre>, and <var> tags to indicate \"raw\" technical content such as excerpts from a config file, an API method name, or a file path. For inline code or data (<code>) To surround small blocks of code or data (single words or lines), mark as code: Source: Use <code> tags. Markdown: Surround the text with backtick ` characters. For multi-line code blocks (<pre>) To surround longer blocks of data that run multiple lines, mark as preformatted text: Source: Use <pre> tags. Markdown: Do not use Markdown-style indented code formatting, as this can cause unexpected formatting problems. Highlight user input with <var> Use the <var> tag to highlight areas of a code block where a user is expected to supply their own value. For more context on when to use <var> tags, see < var> formatting guidelines. Follow these guidelines when you use <var> tags: Address the reader directly Use all caps and underscores _ to separate words (also known as SCREAMING_SNAKE_CASE). Don't use other punctuation (such as wrapping the text in angle brackets). Exception: REST API examples use a ${VARNAME} syntax inspired by Bash conventions. Standard examples: echo \"license_key: YOUR_LICENSE_KEY\" | sudo tee -a /etc/newrelic-infra.yml Copy msiexec.exe /qn /i PATH\\TO\\newrelic-infra.msi Copy https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/APP_ID Copy REST API v2 example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_call_time&values[]=call_count&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy Highlight important sections with <mark> Use the <mark> tag to highlight areas of a code block that are particularly important. Most commonly, <mark> is used to highlight New Relic API methods in sample code that contains a lot of \"other logic.\" When you use <mark>, you should usually follow the code block with a list of bullets that explain what each API call is doing and link to method syntax. For more context on when to use <mark> tags, see < mark> formatting guidelines. Examples: Example of using the <mark> tag private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal(DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()) ; // fire and forget DB_POOL.submit(() -> { segment.end() ; insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For method syntax, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in New Relic APM with datastore data. For more information, see reportAsExternal API. For method syntax, see the Javadoc. segment.end(): Stops timing this segment. For method syntax, see the Javadoc. Add syntax highlighting To add syntax highlighting to a code block, add class=\"highlight\" to the <pre> tag. The syntax highlighter tries to auto-detect the language. If it's not working as expected, ensure the language is supported and specify the language by adding the a lang-LANG-NAME class (for example: lang-html). View a full list of supported languages for syntax highlighting. Element colors and themes are fully customizable. Link to other docs You can add <a href> tags inside a <pre> blocks, just as you would any other content. However, make sure to use them judiciously since they can be easy to miss. A good example is the Infrastructure config file template, where each config element links to the relevant section of the main config doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.98097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Code</em> examples",
        "sections": "<em>Code</em> examples",
        "body": " Markdown-style indented <em>code</em> <em>formatting</em>, as this can cause unexpected <em>formatting</em> problems. Highlight user input with &lt;<em>var</em>&gt; Use the &lt;<em>var</em>&gt; tag to highlight areas of a <em>code</em> block where a user is expected to supply their own value. For more context on when to use &lt;<em>var</em>&gt; tags, see &lt; <em>var</em>&gt; <em>formatting</em> <em>guidelines</em>"
      },
      "id": "6042212b28ccbc7c9eeba772"
    },
    {
      "sections": [
        ".NET: Configure logs in context",
        "Set up your .NET app",
        "Configure log4net extension",
        "log4net workflow diagram",
        "log4net 2.0.8 or higher configuration",
        "Configure NLog extension",
        "Nlog workflow diagram",
        "Nlog 4.5 or higher configuration",
        "Nlog file-based configuration",
        "Configure Serilog 2.5 or higher extension",
        "Serilog workflow diagram",
        "Serilog 2.5 or higher configuration",
        "Serilog file-based configuration",
        "View logs in the UI",
        "What's next?"
      ],
      "title": ".NET: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Configure logs in context"
      ],
      "external_id": "1a1f97cbefe7280d8e526a23826bdd0fa70a5bd7",
      "image": "https://docs.newrelic.com/static/90e8518fffeb7d9cc28f58f29fe749a5/e5166/LogsInContext-Log4Net.jpg",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/configure-logs-context/net-configure-logs-context-all/",
      "published_at": "2021-09-02T10:29:44Z",
      "updated_at": "2021-09-01T04:15:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the .NET agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your .NET app To enable logs in context for APM apps monitored by .NET: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest .NET agent version, and enable distributed tracing. Use .NET agent version 8.21 or higher and the New Relic .NET agent API version 8.21 or higher for logs in context. Install or update to Microsoft .NET Framework 4.5 or higher or .NET Core 2.0 or higher. Install and configure any of the following logging extensions to enrich your log data. Configure log4net extension You can use the Apache log4net version 2.0.8 or higher extension to link your log data with related data across the rest of the New Relic platform. log4net workflow diagram The following diagram illustrates the flow of log messages through Apache log4net, highlighting specific components of the New Relic log4net extension. Many log forwarders are available. This example uses Fluentd. Appender: The NewRelicAppender adds contextual information from the .NET agent (using the API) to the log events generated by the application. This contextual information, known as linking metadata, is used by New Relic to link log messages to the transactions and spans from which they were created. This appender will pass the enriched log events to downstream appenders for further processing. Since the NewRelicAppender is ForwardingAppender type, it needs to be the first appender in the chain. It also requires another appender that can write to an actual output destination as its child in order to work. Layout: The NewRelicLayout formats the enriched log events into the JSON format expected by New Relic. The appender, which this layout is assigned to, instructs log4net to output the JSON to a file in the location that the log forwarder expects. Log Forwarder: The log forwarder monitors an output folder and incrementally sends New Relic formatted log information to the New Relic logging endpoint. log4net 2.0.8 or higher configuration Log4net uses appender and layout to store and format log messages. NewRelicAppender enriches log messages with contextual information from the New Relic .NET agent if it is attached to your application. The appender passes enriched log messages to downstream appenders to handle specific use cases for log messages. For more information about logging with log4net, see the Apache log4net Getting started documentation. To configure logs in context with the log4net extension: Using the Visual Studio NuGet Package Manager, locate and install the NewRelic.LogEnrichers.Log4Net package. In your log4net configuration file, update your logging configuration to use the NewRelicAppender as the first level appender, and reference your existing appenders as its children. Also replace the layout of the appender that writes log messages to an output destination with the NewRelicLayout. The following log4net configuration example enriches log events with New Relic linking metadata. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\log4netExample.log.json for consumption by the log forwarder: <log4net> <root> <level value=\"ALL\" /> <appender-ref ref=\"NewRelicAppender\" /> </root> <appender name=\"NewRelicAppender\" type=\"NewRelic.LogEnrichers.Log4Net.NewRelicAppender, NewRelic.LogEnrichers.Log4Net\" > <threshold value=\"ALL\"/> <appender-ref ref=\"FileAppender\" /> </appender> <appender name=\"FileAppender\" type=\"log4net.Appender.FileAppender\"> <file value=\"C:\\logs\\log4netExample.log.json\" /> <param name=\"AppendToFile\" value=\"true\" /> <layout type=\"NewRelic.LogEnrichers.Log4Net.NewRelicLayout, NewRelic.LogEnrichers.Log4Net\"> </layout> </appender> </log4net> Copy After you configure the log4net extension and update your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin for New Relic Logs: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\log4netExample.log.json pos_file C:\\logs\\log4netExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Configure NLog extension You can use our NLog 4.5 or higher extension to link to your log data with related data across the rest of the New Relic platform. Nlog workflow diagram The New Relic NLog extension provides a NewRelicJsonLayout that formats a log event in the way required by the New Relic logging endpoint. Next, it adds contextual information from the .NET agent when attached to your application. Then, a target can be configured to write logging data to an output folder. The log forwarder can monitor this folder and incrementally send log information to New Relic. The following diagram illustrates the flow of log messages through NLog, highlighting specific components of the New Relic NLog extension. New Relic JSON Layout: The NewRelicJsonLayout adds contextual information from the .NET agent (using the API) to the log events generated by the application, and outputs log messages in the JSON format expected by New Relic. This contextual information, known as linking metadata, is used by New Relic to link log messages to the transactions and spans where they were created. Since the NewRelicAppender is ForwardingAppender type, it needs to be the first appender in the chain. It also requires another appender that can write to an actual output destination as its child in order to work. File Target: A FileTarget defines a file on disk where log messages are written. Adding the NewRelicJsonLayout to that target allows the output to be formatted correctly for forwarding to New Relic. Log Forwarder: The log forwarder is configured to send the log data from the FileTarget output to New Relic. The example below uses the New Relic Fluentd log forwarder, however there are many other log forwarders that can be used. For more information about logging with NLog, see the nlog-project.org documentation. Nlog 4.5 or higher configuration Use our NLog 4.5 or higher extension to link to your log data with related data across the rest of the New Relic platform. Using the Visual Studio NuGet Package Manager, locate and install the NewRelic.LogEnrichers.NLog package. In your application code, update your logging configuration to add the NewRelicJsonLayout and decide if you want to collect MappedDiagnosticsContext (MDC) or the MappedDiagnosticsLogicalContext (MDLC) data. The following configuration examples result in new JSON files that are written to disk. Some of these configuration options may be useful for managing the amount of disk space used and/or the performance of the target. archiveAboveSize maxArchiveFiles bufferSize enableArchiveFileCompression autoFlush concurrentWrites Although the NLog AsyncWrapper Target is not required, it may help improve performance by performing formatting and output of log files on a different thread. Don't collect MDC or the MDLC data (default): The following code example enriches log events with New Relic linking metadata, but not with MDC or the MDLC data. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\NLogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggingConfiguration(); var newRelicFileTarget = new FileTarget(\"NewRelicFileTarget\"); newRelicFileTarget.Layout = new NewRelicJsonLayout(); newRelicFileTarget.FileName = \"C:\\logs\\NLogExample.json\"; loggerConfig.AddTarget(newRelicFileTarget); loggerConfig.AddRuleForAllLevels(\"NewRelicFileTarget\"); LogManager.Configuration = loggerConfig; var logger = LogManager.GetLogger(\"Example\"); Copy Collect MDC or the MDLC data: If your application uses the MDC or the MDLC, you can configure the NewRelicJsonLayout to include items in those collections. The following code example adds the additional configuration to enable collecting MDC and MDLC data. As in the previous example, it outputs new log files in a specific JSON format at C:\\logs\\NLogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggingConfiguration(); var newRelicFileTarget = new FileTarget(\"NewRelicFileTarget\"); var newRelicLayout = new NewRelicJsonLayout { IncludeMdc = `true,` IncludeMdlc = `true` }; newRelicFileTarget.Layout = newRelicLayout; newRelicFileTarget.FileName = \"C:\\logs\\NLogExample.json\"; loggerConfig.AddTarget(newRelicFileTarget); loggerConfig.AddRuleForAllLevels(\"NewRelicFileTarget\"); LogManager.Configuration = loggerConfig; var logger = LogManager.GetLogger(\"Example\"); Copy Once you have configured the NLog extension and updated your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin to forward logs to New Relic: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\NLogExample.log.json pos_file C:\\logs\\NLogExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Nlog file-based configuration You can also configure the New Relic NLog extension with file-based configuration providers. The folowing example code creates a logger based on settings contained in an App.config file. Instantiating Logger using .config file var logger = LogManager.GetLogger(\"NewRelicLog\"); logger.Info(\"Hello, New Relic!\"); Copy Sample App.config file <?xml version=\"1.0\" encoding=\"utf-8\" ?> <configuration> <configSections> <section name=\"nlog\" type=\"NLog.Config.ConfigSectionHandler, NLog\"/> </configSections> <startup> <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5\" /> </startup> <nlog xmlns=\"http://www.nlog-project.org/schemas/NLog.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"> <extensions> <add assembly=\"NewRelic.LogEnrichers.NLog\" /> </extensions> <targets> <target name=\"NewRelicLogFile\" xsi:type=\"File\" fileName=\"C:/path/to/NewRelicLog.json\"> <layout xsi:type=\"newrelic-jsonlayout\"> </layout> </target> </targets> <rules> <logger name=\"NewRelicLog\" minlevel=\"Info\" writeTo=\"newRelicLogFile\" /> </rules> </nlog> </configuration> Copy Configure Serilog 2.5 or higher extension You can use our Serilog extension to link to your log data with related data across the rest of the New Relic platform. This requires: Serilog 2.5 or higher Serilog File Sinks v4.0 or higher Serilog workflow diagram Serilog is a structured logging framework that records log messages from your application and creates a LogEvent to store the message data. Using Enrichers, you can add additional information to the log events. Sinks and Formatters allow you to format and output those log events for downstream consumption and viewing. The following diagram illustrates the flow of log messages through Serilog, highlighting specific components of the New Relic Serilog extension. Many log forwarders are available. This example uses Fluentd. New Relic Enricher: The NewRelicEnricher adds contextual information from the .NET agent (using the API) to the log events generated by the application. This contextual information, called linking metadata, is used by New Relic to link log messages to the transactions and spans where they were created. New Relic Formatter: The NewRelicFormattertranslates enriched log events into the JSON format expected by New Relic. A sink instructs Serilog to output the JSON to a file in the location that the log forwarder expects. New Relic Log Forwarder: The NewRelicFormatter translates enriched log events into the JSON format expected by New Relic. A sink instructs Serilog to output the JSON to a file in the location that the log forwarder expects. For more information about Serilog log events, see the Serilog documentation on GitHub. Serilog 2.5 or higher configuration To configure logs in context with the Serilog extension: Use the Visual Studio NuGet Package Manager to locate and install the NewRelic.LogEnrichers.Serilog package. In your application code, update your logging configuration to add the NewRelicEnricher and NewRelicFormatter. The following code example enriches log events with New Relic linking metadata. In addition to the existing log files, it outputs new log files in a specific JSON format at C:\\logs\\SerilogExample.log.json for consumption by the log forwarder: var loggerConfig = new LoggerConfiguration() loggerConfig .Enrich.WithThreadName() .Enrich.WithThreadId() .Enrich.WithNewRelicLogsInContext() .WriteTo.File( path: @\"C:\\logs\\ExistingLoggingOutput.txt\") .WriteTo.File( formatter: new NewRelicFormatter(), path: @\"C:\\logs\\SerilogExample.log.json\"); var log = loggerConfig.CreateLogger(); Copy This configuration results in new JSON files that are written to disk. Some of these configuration options may be useful for managing the amount of disk space used and/or the performance of the sink. restrictedToMinimumLevel buffered rollingInterval rollOnFileSizeLimit retainedFileCountLimit Although not required, using the Serilog Asynchronous Sink Wrapper may help improve the performance by performing formatting and output of log files on a different thread. Once you have configured the Serilog extension and updated your logging file, you can configure your extension to send data to New Relic. Here is an example configuration using the Fluentd plugin to forward logs to New Relic: <!--NewRelicLoggingExample.conf--> <source> @type tail path C:\\logs\\SerilogExample.log.json pos_file C:\\logs\\SerilogExample.log.json.pos tag logfile.* <parse> @type json </parse> </source> <match **> @type newrelic license_key <YOUR NEW_RELIC_LICENSE_KEY> base_uri https://log-api.newrelic.com/log/v1 </match> Copy Serilog file-based configuration You can also configure the New Relic Serilog extension with file-based configuration providers.The following additional NuGet Packages are required: Microsoft.Extensions.Configuration](https://www.nuget.org/packages/Microsoft.Extensions.Configuration/) Serilog.Settings.Configuration The following example code creates a logger based on settings contained in an appSettings.json file. Instantiating logger using appsettings.json var builder = new ConfigurationBuilder() .AddJsonFile(\"appsettings.json\"); var configuration = builder.Build(); var logger = new LoggerConfiguration() .ReadFrom.Configuration(configuration) .CreateLogger(); Copy Sample appsettings.json file { \"Serilog\": { \"Using\": [ \"Serilog.Sinks.Console\", \"Serilog.Sinks.File\", \"NewRelic.LogEnrichers.Serilog\" ], \"MinimumLevel\": \"Debug\", \"Enrich\": [ \"WithNewRelicLogsInContext\" ], \"WriteTo\": [ { \"Name\": \"File\", \"Args\": { \"path\": \"C:\\\\Logs\\\\SerilogExample.log.json\", \"formatter\": \"NewRelic.LogEnrichers.Serilog.NewRelicFormatter, NewRelic.LogEnrichers.Serilog\" } } ], \"Properties\": { \"Application\": \"NewRelic Logging Serilog Example\" } } } Copy The following example code creates a logger based on settings contained in a web.config file. The Serilog.Settings.AppSettings NuGet Package is required. Instantiating logger using .config file var logger = new LoggerConfiguration() .ReadFrom.AppSettings() .CreateLogger(); Copy Sample web.config file <?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <appSettings> <add key=\"serilog:using:NewRelic\" value=\"NewRelic.LogEnrichers.Serilog\" /> <add key=\"serilog:using:File\" value=\"Serilog.Sinks.File\" /> <!--Add other enrichers here--> <add key=\"serilog:enrich:WithNewRelicLogsInContext\" /> <add key=\"serilog:write-to:File.path\" value=\"C:\\logs\\SerilogExample.log.json\" /> <add key=\"serilog:write-to:File.formatter\" value=\"NewRelic.LogEnrichers.Serilog.NewRelicFormatter, NewRelic.LogEnrichers.Serilog\" /> </appSettings> Copy View logs in the UI To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.222916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " <em>code</em> example enriches log events with New Relic linking metadata. In addition to the existing log files, it outputs new log files in a specific JSON <em>format</em> at C:\\logs\\SerilogExample.log.json for consumption by the log forwarder: <em>var</em> loggerConfig = new LoggerConfiguration() loggerConfig"
      },
      "id": "612efe5764441ff155424352"
    },
    {
      "sections": [
        "Bold or code, not italics",
        "Tip"
      ],
      "title": "Bold or code, not italics",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "c4d55d70ca7e6d5a8359be160059ea2e1190cf27",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/bold-or-code-not-italics/",
      "published_at": "2021-09-01T19:07:14Z",
      "updated_at": "2021-03-16T14:49:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you'd like to emphasize text in our docs, please follow these simple guidelines: Use code for things the user is likely to copy and paste, like a file path or a command line example. Use bold for anything else you need to emphasize, like a UI name or to highlight an important word. We don't format text in our docs with italics. Here are more specific guidelines our team uses. For this... Bold Code Example APM Agent lists C SDK Go Java .NET Node.js PHP Python Ruby Command line utility names To install the utility, use apt. Emphasis Stop IIS before running the installer. File paths and file names The agent looks for newrelic.config in the %ALLUSERSPROFILE%\\New Relic\\.NET Agent directory. Insights event names and attributes To analyze APM errors, use the TransactionError event. Method names To initialize the APM agent, use startAgent(). Non-clickable URLs In your web browser, navigate to the minion Overview page at http://MINION_IP_ADDRESS. The <var> formatting automatically applies color coding and italics in this situation. Pages, paths, fields, etc. in the user interface Go to one.newrelic.com > APM > (select an app) > Transactions. For more information, see UI paths. Tip If you have a UI object (page, tab, etc.) that also has link formatting, then you don't need to add the bold formatting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.500465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Bold or <em>code</em>, not italics",
        "sections": "Bold or <em>code</em>, not italics",
        "body": " <em>format</em> text in our docs with italics. Here are more specific <em>guidelines</em> our team uses. For this... Bold <em>Code</em> Example APM Agent lists C SDK Go Java .NET Node.js PHP Python Ruby Command line utility names To install the utility, use apt. Emphasis Stop IIS before running the installer. File paths and file"
      },
      "id": "60421e1de7b9d2eadb2a0800"
    }
  ],
  "/docs/style-guide/writing-guidelines/create-edit-content": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/get-started/introduction-style-guide/",
      "sections": [
        "Introduction to the style guide",
        "Organize your doc to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-09-01T21:50:48Z",
      "title": "Introduction to the style guide",
      "updated_at": "2021-04-12T11:26:22Z",
      "type": "docs",
      "external_id": "b0bfbe0b3791c4feb00fe86a41e49312cd9e82cd",
      "document_type": "page",
      "popularity": 1,
      "body": "We've written these guidelines to make it easier for you to contribute to our docs, as well as to give you some insight into how we think about good technical writing. We, the Tech Docs team, rely on your expertise to keep New Relic's documentation updated and useful. Thank you for your willingness to share your knowledge! Our style guide focuses on style and usage that's particular to our site. Our site follows American English conventions. For topics that aren't covered, please refer to the Microsoft Writing Style Guide (for guidelines on technical terminology) or the Chicago Manual of Style (for general writing and editing guidelines). Organize your doc to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 398.32513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Create</em> <em>and</em> <em>edit</em> categories",
        "body": " large groups of docs at once, please <em>create</em> an issue to request these types of changes and we&#x27;ll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see <em>Create</em> and <em>edit</em> <em>content</em>. To learn how to <em>create</em> and publish release notes, see <em>Create</em> release notes. To make it even easier to start a new doc, use templates."
      },
      "id": "60415293e7b9d262f32a07d7"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "f117225cac5b0cf73daa56bd32807c4a58c4a31e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-09-01T19:30:05Z",
      "updated_at": "2021-09-01T19:30:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.81571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Edit</em> redirects",
        "tags": "Processes <em>and</em> procedures",
        "body": "This document describes how to change the title of a document and how to <em>create</em>, <em>edit</em>, and delete redirects. Procedures are the same for both standard docs (&quot;basic pages&quot;) and release notes. Caution Changing titles or updating redirects can <em>create</em> issues with finding <em>content</em>. If you need to change"
      },
      "id": "604220ec196a670d0ba83dd4"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writer-workflow/tech-writer-workflow/",
      "sections": [
        "Tech Writer workflow",
        "Resources",
        "Edit in the UI vs local build",
        "Work on a branch, not a fork",
        "Set up your local environment",
        "Run the site locally",
        "Prerequisites",
        "Build the site",
        "Edit a doc",
        "Commit your changes",
        "Publish your commits",
        "Open your pull request",
        "Preview a doc",
        "Revise and publish a doc",
        "Revert merging"
      ],
      "published_at": "2021-09-01T21:57:08Z",
      "title": "Tech Writer workflow",
      "updated_at": "2021-08-27T04:54:57Z",
      "type": "docs",
      "external_id": "074905b02af0ab6eb53640c1c80e83296a8a0b02",
      "document_type": "page",
      "popularity": 1,
      "body": "This document will guide you through the entire workflow for editing the New Relic documentation site as a New Relic Tech Docs Writer. Resources VSCode (or another text editor) VSCode has great GitHub integrations GitHub account GitHub Desktop Edit in the UI vs local build Need to edit a doc? Use this table to decide where to work! Use the UI for: Use the local build for: Adding content to one doc: Rewriting sentences, or 1-2 lines Editing small amounts of content: updating URLs, deleting typos, etc. Brand new docs Rewrites of more than 1 or 2 lines Any updates to doc frontmatter Title changes Taxonomy changes Metadescription updates Redirects Updating images Editing multiple docs at once Continue reading for instructions on how to edit a doc locally. Work on a branch, not a fork Some teams work on branches, some teams work on forks; the docs team works in branches. As long as a branch has been pushed upstream, this allows us to work collaboratively and ensure that no work is ever lost when someone goes on vacation. To create a branch on the docs-website repo: Open GitHub Desktop Click on Current branch: xxx Click on New Branch You will be prompted to name your new branch. Descriptive names are best. It's a great way to quickly clue people in to what your work is all about. For example, if you are working on What’s New pages, you might name the branch Whats-new-updates. When you create a new branch, don't forget to add the Jira issue's key (DOC-1234) to the branch name and the PR title. Set up your local environment Running the site locally makes testing and previewing large changes much easier. Here's how to get setup: Install GitHub Desktop Sign in to GitHub Desktop. On Macs, click on GitHub Desktop in the top left corner of your screen and select Preferences. Select the blue Sign In button and follow the prompts in the browser window. Navigate to the Docs Site repository on GitHub.com. Click the green Code button and then select Open with GitHub Desktop. Choose the location where you want the repo, and this will clone the entire repository to your local machine at the designated path. You can ensure the repo was cloned by navigating to your local GitHub folder (the default is ~/Documents/github). Once you have cloned the repo, you don't need to clone it again in the future. Run the site locally Build the site locally using the terminal to preview changes before opening a Pull Request. While it's highly recommended to build the site locally, this is technically an optional step. The site will automatically reflect any local changes once build. Node and Yarn are tools used to build the site on your local machine. Prerequisites Install Node Install Yarn npm install -g yarn Build the site In your terminal, go to your cloned repo, docs-website. For example: cd ~/Documents/github/docs-website Run yarn with the following commands: yarn && yarn start The site will take a few minutes to build. Make yourself some tea or coffee. Once it's built, you can access your preview site in your browser by navigating to http://localhost:8000/ Edit a doc Once your local environment and branch are set up, you're ready to edit a doc. Check out the style guide for writing guidelines. First, ensure your Current Branch in GitHub Desktop is set to the correct branch, not Develop. Navigate to the doc you want to edit in Finder. If I wanted to edit a Python agent doc, I would navigate to: ~/Documents/github/docs-website/src/content/docs/agents/python-agent/hosting-services/python-agent-stackato.mdx Edit the doc in your text editor of choice. You should write docs in markdown language. Reference the style guide for help with formatting markdown Save the file with your edits, then follow the same process for any other docs you wish to edit. Commit your changes Once your edits are done, you can commit them. This stages your changes, which you will later push upstream to Github. By pushing your changes, everyone will have access to your branch and commits. Navigate to GitHub Desktop. The left column should have a record of all the edits you have made to docs. In the bottom left corner, name your commit and add a good description of your edits. It should be descriptive enough to ensure that someone can understand all the changes made by simply scanning this description. Click Commit to [yourbranchname] Publish your commits Once you have committed your changes, you're almost ready to open your Pull Request. First, you need to ensure your branch is pushed upstream. On GitHub desktop, click the blue Publish Branch button if available. If you don't see the Publish Branch, click the blue Push Origin button. This will push all your commits upstream and make them available to everyone else through the GitHub repository. Open your pull request Now that your commits are available to everyone, you need to notify people that your changes are ready to be merged into the develop branch. To do this, you open a pull request: On GitHub Desktop, click the blue Create Pull Request button. This will open GitHub in your browser, and prompt you to fill in your pull request. Ensure you're merging from your branch into either the main or develop branch. If you scroll down, you can review all your commits to ensure they reflect all your changes. Just like your commit description, your pull request description should be detailed and give the full context of your changes. Feel free to add any additional context here (issue or Jira number, SMEs, etc.) To request a review from another Tech Writer: in GitHub open the PR, navigate to the Conversation section, and then select or type in a reviewer name in the Reviewer section. Add any relevant labels to your PR. If you do not add from_tw, the PR will not be automatically assigned to another writer for review. Once you're satisfied with your pull request, click the green Create pull request button. You can either publish the changes directly by approving the pull request yourself, or you can request for another Tech Writer to peer edit it. At the bottom of the pull request page, you will see a Checks section. These checks ensure your PR doesn't break the build process of the site. Ensure all checks marked required pass before merging. Once the pull request has passed the checks and it has been approved by another tech writer (or you are confident the changes are ready to be published), click the green Merge pull request button. This will merge your branch and commits into the repository and will begin the build process. If you don't add the from_tw label when you first create a PR, it will not automatically assign a reviewer. If you forget to add the label before opening the PR: Add the from_tw label. Turn the PR into a draft PR. Select the PR is ready for review button at the bottom of the page to reopen the PR. The PR should now have a reviewer. Preview a doc There are two main ways to preview branches you’ve already published and run commits on: Local: Quicker, but requires a semi-substantial amount of setup and familiarity with a terminal. Gatsby Cloud: Full preview of the live site with no overhead, and a very convenient way to share a preview of your draft with a SME. Gatsby Cloud will comment on your PR with a link to a preview version of the site once the build is ready. Building the site generally takes about 15 minutes, but can sometimes take longer if there are a lot of changes. Revise and publish a doc If you’re notified that a reviewer has submitted a review to your file, go to your PR and review the changes. You might see them in the diff view, if they’re part of a review with comments; otherwise, they might appear as copy edits in the file. Respond to any comments in the file. Either reply with follow up discussion, or click Resolve conversation. When you’ve resolved all the comments, and all of the automatic checks have passed, you can merge the pull request. Merging the pull request sets in motion the automated build process and your changes will be published shortly. Note: You will only be able to merge when the Merge pull request button is green. If it’s not green, review for any comments you missed, or other messages that indicate why GitHub is blocking you from merging. Revert merging Remember that you can almost always undo things. If you merge a PR, and then find that you shouldn’t have, you can unmerge with the Revert button. On the Pull requests tab in GitHub, click Closed on the tally bar to see all the issues and PRs that have alredy been merged. Locate the PR you merged, and locate the Revert button. Click Revert. That creates a new PR, which needs to be merged. If you want to reopen it, you need to follow the link back to the original PR and either revert that or reopen it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.060165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Edit</em> in the UI vs local build",
        "body": " branch, not Develop. Navigate to the doc you want to <em>edit</em> in Finder. If I wanted to <em>edit</em> a Python agent doc, I would navigate to: ~&#x2F;Documents&#x2F;github&#x2F;docs-website&#x2F;src&#x2F;<em>content</em>&#x2F;docs&#x2F;agents&#x2F;python-agent&#x2F;hosting-services&#x2F;python-agent-stackato.mdx <em>Edit</em> the doc in your text editor of choice. You should write"
      },
      "id": "60c6a91764441f404d91f8c6"
    }
  ],
  "/docs/style-guide/writing-guidelines/docs-translation": [
    {
      "sections": [
        "Create smoother charts with sliding windows",
        "When to use sliding windows",
        "Valid NRQL syntax for SLIDE BY",
        "Translation from PromQL-style queries",
        "Use SLIDE BY with MAX and AUTO",
        "Tip"
      ],
      "title": "Create smoother charts with sliding windows",
      "type": "docs",
      "tags": [
        "Query your data",
        "NRQL: New Relic Query Language",
        "NRQL query tutorials"
      ],
      "external_id": "97fe07b51e5f2c6a2868c924d1c829d82fd8f585",
      "image": "https://docs.newrelic.com/static/9d882293c1b7b04e65b4bcf6f3ae4bbf/e5166/SlidingWindow2.jpg",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/nrql-query-tutorials/create-smoother-charts-sliding-windows/",
      "published_at": "2021-09-01T18:07:27Z",
      "updated_at": "2021-03-16T13:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Sliding windows are a technique for generating charts using the SLIDE BY clause in conjunction with the TIMESERIES clause. With sliding windows, data is gathered in time \"windows\" that overlap with each other. For example, in the image below, a query gathers data with 5 minute windows. The windows \"slide\" by 1 minute. Each window overlaps with the previous window by 4 minutes. 5-minute windows with 1-minute \"slide\" In contrast, with \"tumbling\" or \"cascading\" windows, the windows do not overlap. For example, in this TIMESERIES 3 minutes NRQL query, the windows are 3 minutes in length, with each beginning when the other ends. There is no overlap in the measurement interval. 3-minute windows with no overlap or \"slide\". When to use sliding windows Sliding windows are helpful when you need to smooth out \"spiky\" charts. One common use case is to use sliding windows to smooth line graphs that have a lot of variation over short periods of time in cases where the rolling aggregate (for example a rolling mean) is more important than aggregates from narrow windows of time. In the example below, data varies greatly from one minute to another, so the 1-minute tumbling window chart shows many high peaks and low valleys. TIMESERIES query without SLIDE BY clause However, in this example, 5-minute wide TIMESERIES windows are smoothed with the help of 1-minute SLIDE BY intervals. The query returns similar data but creates a much smoother chart. TIMESERIES query with SLIDE BY clause Valid NRQL syntax for SLIDE BY Valid NRQL syntax for the SLIDE BY clause will follow the format below. SELECT ... TIMESERIES integer1 units SLIDE BY integer2 units Copy integer1 specifies the sliding window width and integer2 specifies the SLIDE BY interval. units is a time unit, such as second, minute, hour, or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy Translation from PromQL-style queries When applicable, a PromQL-style query is translated into a NRQL sliding window query. For example, if your PromQL style query uses rate(request_count[5m]) for the past 60 minutes with a 1-minute window overlap, the NRQL translation would be the query below. SELECT rate(sum(request_count), 1 SECONDS) FROM Metric SINCE 3600 SECONDS AGO UNTIL NOW FACET dimensions() LIMIT 100 TIMESERIES 300000 SLIDE BY 60000 Copy In the translation output, the default unit of millisecond is used for TIMESERIES and SLIDE BY clauses. For TIMESERIES, 300000 ms is 300 seconds, or 5 minutes, specifying a window size of 5 minutes. For SLIDE BY, 60000 ms is 60 seconds, specifying a slide interval of 1 minute. Use SLIDE BY with MAX and AUTO You can combine SLIDE BY with MAX and AUTO arguments to further tailor query results, as shown in the examples below. SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY MAX Copy SELECT average(duration) FROM Transaction TIMESERIES 5 minutes SLIDE BY AUTO Copy Tip When paired with SLIDE BY, TIMESERIES does not support AUTO or MAX. The TIMESERIES value must be an integer time unit value. In other words, SLIDE BY AUTO or SLIDE BY MAX will work, but TIMESERIES AUTO or TIMESERIES MAX followed by SLIDE BY and MAX, AUTO, or a specific integer time unit is not supported. Tip The SLIDE BY value as determined by AUTO or MAX can produce a step interval greater than the window size, which will show up as gaps and unexpected results. If you experience these issues with query results, consider checking for instances of SLIDE BY where the step interval exceeds the window size.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 55.798336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Translation</em> from PromQL-style queries",
        "body": ", or day. All standard NRQL time units are accepted. Here’s a real-life example. It shows 5-minute TIMESERIES windows with a 1-minute SLIDE BY interval. SELECT average(duration) from Transaction TIMESERIES 5 minutes SLIDE BY 1 minute Copy <em>Translation</em> from PromQL-style queries When applicable"
      },
      "id": "603e8a2528ccbc56e5eba774"
    },
    {
      "sections": [
        "Update the home page",
        "Update a link's URL",
        "Add a new tile to the home page",
        "Add a new section to the home page"
      ],
      "title": "Update the home page",
      "type": "docs",
      "tags": [
        "home page",
        "landing pages"
      ],
      "external_id": "d637697a72493d8dbe0c9538e5b35f13f62d7474",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/edit-homepage/",
      "published_at": "2021-09-01T19:07:14Z",
      "updated_at": "2021-04-11T08:27:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can't just hit the edit button docs.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It's rare that you'll need to make changes to this file. Most home page changes will be to add a new tile or section to the page, or update links. These types of changes are handled in two files: src/data/homepage.yml - contains home page section titles, section descriptions, and the URLs for tiles. src/i18n/translations/en/translation.json - contains tile info, including the title and short description of tiles. Update a link's URL Change or add new links using homepage.yml. In homepage.yml, search for the link you want to change. Edit the URL, save, commit, and PR the change. Add a new tile to the home page You'll make changes to both homepage.yml and translations.json On the translations.json doc, find the spot where you want to add the new tile (which section, and in what order you want it to appear), and add a new entry with this format: \"t#\": { \"title\": \"tile name\", \"description\": \"Short description.\" }, Copy Make sure you update the number on the tile. If you want to insert it in the middle of a group, update all the subsequent tile numbers as well. Save the file. Open homepage.yml, find the spot where the new tile will be, and add a new line with the relative link for the new tile. For example, - /docs/new-relic-one/use-new-relic-one/workloads/workloads-isolate-resolve-incidents-faster Save and check that your new tile builds properly on a local build. Commit, push, PR when you're ready. Add a new section to the home page On the translations.json page, add a new section modeled in the spot where you want the new section to appear. Include at least one title. For example, here's the TDP entry, with one tile: \"tdp\": { \"title\": \"Telemetry Data Platform\", \"description\": \"Ingest, visualize, and alert on all your telemetry data in one place.\", \"t1\": { \"title\": \"Introduction to Telemetry Data Platform\", \"description\": \"How to manage all your monitoring in one place.\" }, Copy When you're done creating the info, save the file. In the homepage.yml page, find the corresponding location for the new section, and add the short name you provided in the translation.json file, title, description, and tile URLs. For example, here's the corresponding TDP section on homepage.yml. tdp: title: Telemetry Data Platform description: Ingest, visualize, and alert on all your telemetry data in one place. tiles: - /docs/data-ingest-apis/get-data-new-relic/getting-started/get-started-telemetry-data-platform Copy Save, build locally, commit, PR.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 50.537647,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "You can&#x27;t just hit the edit button <em>docs</em>.newrelic.com to make edits to the home page. The page that opens is index.js, the file that manages the parts of the home page, but not the content. It&#x27;s rare that you&#x27;ll need to make changes to this file. Most home page changes will be to add a new tile"
      },
      "id": "6072b300e7b9d231b2a5c663"
    },
    {
      "sections": [
        "iOS and tvOS crash reporting",
        "dSYM files",
        "Debug the crash reporter",
        "Disable crash reporting"
      ],
      "title": "iOS and tvOS crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "b2b79e6f9e78f6113bb20032c674996c746e14d4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/ios-tvos-crash-reporting/",
      "published_at": "2021-09-02T10:14:07Z",
      "updated_at": "2021-07-09T18:14:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For agent version 4 or higher, New Relic produces crash reports for your mobile applications. When an iOS or tvOS application crashes, the operating system creates a crash report and stores it on the device. New Relic uploads this report the next time the app launches. Using this report and any relevant dSYM files, the crash report includes the complete stack trace with human-readable information. You can then log into New Relic and see each crash, including the method and line where it crashed, plus device and environment details. dSYM files When you create a release build of an iOS or tvOS application, the names of methods and classes are stripped, leaving only machine-readable memory addresses. When the application crashes, the stack trace consists of this machine-readable code. A dSYM file is an Xcode project file for debug symbols. It contains the debugging symbols that allow for translation of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more information, see Retrieve and download dSYMs or Upload dSYM files. Debug the crash reporter Crash reporting is enabled by default, but there are some circumstances where it will be disabled: If the debugger is enabled: There can only be one uncaught exception handler registered at a time per application. If running with the debugger attached, New Relic will not capture and report crashes. If another crash reporter is enabled: If another uncaught exception handler is registered after New Relic starts, this error message is logged: The New Relic exception handler has been replaced. This may result in crashes no longer reporting to New Relic. Copy Disable crash reporting To disable New Relic crash reporting, call the following API method: Language Procedure Objective-C Call prior to [NewRelic startWithApplicationToken:...]; [NewRelic disableFeatures:NRFeatureFlag_CrashReporting]; Copy Swift Call prior to NewRelic.start(withApplicationToken:) NewRelic.disableFeatures(NRMAFeatureFlags.NRFeatureFlag_CrashReporting) Copy For more information about this call, see the NewRelic.h file. For more on applicable feature flags, see the NewRelicFeatureFlags.h file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 44.29912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " for <em>translation</em> of the initial crash report to human-readable information. This process is known as symbolication. New Relic has dynamic framework support for dSYM uploading. If your app uses a dynamic framework with multiple dSYM files, New Relic automatically uploads and uses those files. For more"
      },
      "id": "603ec58128ccbc9b51eba7d2"
    }
  ],
  "/docs/style-guide/writing-guidelines/five-questions-help-write-docs": [
    {
      "sections": [
        "Infrastructure monitoring Hosts page",
        "System tab",
        "System tab functions",
        "APM and infrastructure data",
        "Important",
        "Network tab",
        "Network tab functions",
        "Processes tab",
        "Tip",
        "Processes tab functions",
        "Storage tab",
        "Storage tab functions",
        "Docker containers tab",
        "Docker containers tab functions"
      ],
      "title": "Infrastructure monitoring Hosts page",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Infrastructure monitoring UI",
        "Infrastructure UI"
      ],
      "external_id": "41d8a2ac3ecbbdee164fd0bec6ac94bb3e8def64",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/infrastructure-ui-pages/infrastructure-ui/infrastructure-hosts-page/",
      "published_at": "2021-09-02T09:00:17Z",
      "updated_at": "2021-08-27T07:06:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Hosts page to better understand important performance metrics, like resource usage, network and processes performance, and data about your containers. You can filter your hosts by attributes and compare their performance with inventory change events to help determine root causes. You can also set alert notifications to help prevent problems. To view your hosts information, go to one.newrelic.com > Infrastructure > Hosts, then click any of the following tabs: System: Overview of your hosts' performance Network: Bandwidth and error data about your network interfaces Processes: Data about CPU percentage, I/O bytes, and memory usage for individual or groups of processes Storage: Resources' capacity and efficiency, including your devices' overall utilization, disk usage, or I/O operations Docker containers: CPU percentage, I/O bytes, and memory usage for individual or group of containers System tab Here are the default graphs shown on the Hosts page. For additional chart options, select the dropdown for any chart. CPU %: On the System tab, CPU Percent is a derived metric that is part of the SystemSample event. The CPU percentage is not collected by New Relic, but derived from several other metrics. Specifically, the cpuPercent attribute is an aggregation of cpuUserPercent, cpuSystemPercent, cpuIoWaitPercent and cpuStealPercent. Load average five minute: represents an average of the number of tasks waiting to do work on a system over the last 5 minutes. Memory free %: compares the amount of free memory bytes to the amount of used memory bytes. For explanations of different chart metrics, see Default infrastructure attributes and events. Functions for adjusting chart data include: Select different host groups: Use the host filter. Change time range: Use the time picker above the charts, or drag and select a time range on a chart. Change the number of elements on charts: use the Chart shows dropdown. Change data used to order hosts: Use the table below the charts to order the chart elements by different metrics; for example, from highest to lowest CPU user % to lowest, or from lowest to highest Disk free. System tab functions Here are some of the things you can do from the System tab: If you want to... Do this... Filter and group hosts Use filter sets to show only hosts matching certain criteria, or use group by to aggregate the results. Understand host health Use the Health column of the table. To see more details about specific violations, select the health status icons. Find root causes of issues Use the Events heatmap at the top of the page to compare performance to important events happening in your infrastructure. For more, see Events heatmap. Set an alert condition for a metric Mouse over a chart, select and then Create alert. View host's alert threshold violation If present, select the host's Critical icon or Warning icon. APM and infrastructure data If you have APM data associated with your infrastructure data, there are several ways to access your APM data on the Hosts page: Use the hosts filter to filter on hosts running specific applications. In the host list below the charts, select the Application column to filter on specific applications. From the chart selector dropdown beside a chart's name, select one of the application-related charts. Important APM charts in infrastructure monitoring do not have View query or Create alert options like the other infrastructure charts do. For more about using APM and infrastructure monitoring together, see APM data in infrastructure. Network tab The Network page provides real-time visibility into the health and performance of individual hosts, web servers, or other groups of resources across your network. Default charts show bandwidth metrics by packet, bandwidth by bytes, and errors per second. Details about individual interfaces can help you: Examine saturation levels across your network or for selected filter sets. Compare load balances between specific resources. Identify unexpected differences in capacity patterns between similar hosts. Evaluate the top five network errors that New Relic automatically presents for the selected time period. This real-time network data can then help you determine whether to resolve errors by reconfiguring your network, rebalancing the loads, or taking other preventative maintenance actions before needing to make a purchase decision. From the Network tab you can view bandwidth and error data about your network interfaces. The Network page includes an Events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. For a technical explanation of the attributes used to populate the Network page chart, see NetworkSample attributes. Network tab functions Here are some of the things you can do from the Network tab: If you want to... Do this... Filter and group Use filter sets to show only hosts matching certain criteria, or use Group by to aggregate the results. Select a time range Use the time picker to change the range of time selected. You can also click and drag on the chart to select a custom time range. When you select a time range, it carries over when you go from one infrastructure page to another. Change metrics displayed in chart Use the sorting dropdown to switch what metric the chart is displaying for the chosen process groupings, including: Received Bytes Received Dropped Received Errors Received Packets Transmitted Bytes Transmitted Dropped Transmitted Errors Transmitted Packets Search and filter the list Type in the Search interfaces search bar to filter the list to only those items containing the text you've typed. You can also filter the list by simply selecting the list item or user name you want to filter for. The chosen filters are displayed beside the filter icon above the chart. Add items to chart The chart, by default, displays the top five results. Use the Chart shows dropdown to display more results. To remove an item from a chart, select its name below the chart. Set an alert condition for a metric Mouse over a chart, select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Processes tab Important By default, the infrastructure agent doesn't send data about the operating system's processes unless you use guided install. To enable the sending of process data set enable_process_metrics to true. To fine-tune which processes you want to monitor, configure include_matching_metrics. Use the Processes tab to get information about processes running on your hosts, and to set alerts on process metrics. The Processes tab shows data such as CPU percentage, I/O bytes, and memory usage for individual processes or groupings of processes. The page also includes an events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. Use this information to: Pinpoint processes that are causing performance issues. Create alerts for conditions such as CPU percentage and memory usage. On the Processes page, CPU percent is scoped to individual processes, rather than hosts. Because of this, the CPU percent metric does not take into account the resources of the entire system. Instead, it shows how much of a single CPU core each process is taking. Example Here's an example of how to pinpoint an issue and set an alert: You notice on the Hosts page that a cluster has a CPU percentage much higher than normal. You go to the Processes page and filter down to that cluster's processes. You notice that several instances of the same process have excessive CPU percentage. After fixing the issue, you decide to create an alert condition that triggers when the CPU percentage for that process type exceeds a certain threshold. For a technical explanation of the attributes used to populate the Processes page chart, see ProcessSample attributes. Tip You cannot start, stop, or restart processes from the UI. Instead, follow standard procedures to start, stop, check, or restart the infrastructure agent manually. Processes tab functions Here are some of the things you can do from the Processes tab: If you want to... Do this... Only show hosts matching certain criteria Use filter sets. Aggregate results or group by host attributes Use Group by to change how the processes are grouped in the chart and the list. The dropdown contains host-related attributes such as hostID and entityName. If you are monitoring AWS EC2 instances, EC2-related attributes such as awsRegion will be available. Select a time range Use either of these options: Select any of the time picker options at the top of the page. Click and drag on the chart to select a custom time range. After you select a time range, it carries over from one infrastructure page to another. View Docker metrics To view process usage by Docker containers, see Docker instrumentation. Change charts Select the dropdown beside the chart's name to switch what metric the chart displays. Choices include: Memory: Resident or virtual size CPU percentage Disk I/O: Read or write Search and filter the list Use either of these options: Type in the Search processes search bar. Select the list item or user name you want to filter for. The selected filters appear beside the filter icon above the chart, where you can select and remove them as needed. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Storage tab The Storage page allows you to monitor your resources' capacity and efficiency, including your devices' overall utilization, disk usage, or I/O operations. This can help you to: Examine unexpected patterns; for example, a cluster of mirrored machines that do not process I/O tasks uniformly. Monitor usage levels before disk space completely runs out. Set alert conditions to notify you about problems with one or more hosts; for example, long processing times for read or write operations, disk availability or utilization based on percentage or bytes, etc. Make informed decisions about where to redistribute hosts with higher or lower than normal processing requests. Use data to help plan for additions or changes to your infrastructure budget before an emergency arises. The Storage page includes an Events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. For a technical explanation of the attributes used to populate the Storage page chart, see StorageSample attributes. Storage tab functions Here are some of the things you can do from the Storage tab: If you want to... Do this... Filter and group Use filter sets to show only hosts matching certain criteria, or use Group by to aggregate the results. Select a time range Use the time picker on the upper right to change the range of time selected. You can also click and drag on the chart to select a custom time range. When you select a time range, it carries over when you go from one infrastructure page to another. Change metrics displayed in chart Use the sorting dropdown to switch what metric the chart is displaying for the chosen process groupings. Choices include: Total Utilization % Read Utilization % Write Utilization % Disk Used Bytes Disk Free Bytes I/O Read Operations I/O Write Operations Search and filter the list Type in the Search devices search bar to filter the list. You can also filter the list by simply selecting the list item or user name you want to filter for. The chosen filters are displayed beside the filter icon above the chart. Add/remove chart items The chart, by default, displays the top five results. Use the Chart shows dropdown to display more results. To remove an item, select its name below the chart. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. (Not available on APM charts.) View host's alert threshold violation Select the host's Critical icon or Warning icon. Docker containers tab Use the Docker containers tab to get information about the containers running on your hosts, and to set alerts on container metrics. The Docker containers tab shows data such as CPU percentage, I/O bytes, and memory usage for individual containers or groupings of containers. The page also includes an events heatmap, which provides a snapshot of the events occurring within the same time range as the displayed metrics. Use this information to: Identify containers that are experiencing performance issues. Create alerts for conditions such as CPU percentage and memory usage. Docker containers tab functions Here are some of the things you can do from the Docker containers tab: If you want to... Do this... Only show hosts matching certain criteria Use filter sets. Aggregate results or group by host attributes Use Group by to change how the processes are grouped in the chart and the list. The dropdown contains host-related attributes such as image and operatingSystem. Select a time range Use either of these options: Select any of the time picker options at the top of the page. Click and drag on the chart to select a custom time range. After you select a time range, it carries over from one infrastructure page to another. View Docker integration dashboard To open the Docker integration dashboard, click the Dashboard link above the data table. Change charts Select the dropdown beside the chart's name to switch what metric the chart displays. Choices include: CPU: Used cores, kernel percentage Memory: Size limit, cache bytes I/O: Write count per second, total bytes Network: Errors per second, packets Process: Process count, restart count Search and filter the list Use either of these options: Type in the Search processes search bar. Select the list item or user name you want to filter for. The selected filters appear beside the filter icon above the chart, where you can select and remove them as needed. Set an alert condition for a metric Mouse over a chart. Select and then Create alert. View host's alert threshold violation Select the host's Critical icon or Warning icon.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.10724,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Docker</em> containers tab",
        "body": "Use the Hosts page to better understand important performance metrics, like resource usage, network and processes performance, and data about your containers. You can filter your hosts by attributes and compare their performance with inventory change events to <em>help</em> determine root causes. You can"
      },
      "id": "60440a6d196a675f6c960f58"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/prometheus-integrations/install-configure-remote-write/prometheus-remote-write-integration/",
      "sections": [
        "Prometheus remote write integration",
        "Why it matters",
        "Compatibility",
        "Scale your data and get moving quickly",
        "What's next",
        "For more help"
      ],
      "published_at": "2021-09-01T22:56:02Z",
      "title": "Prometheus remote write integration",
      "updated_at": "2021-07-10T23:03:06Z",
      "type": "docs",
      "external_id": "aaf44eb9ee0ffc4b6f751ca18c5dd5b34cd11649",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the Prometheus remote write integration to get data flowing into New Relic. Once you integrate, your data will be visible in query-based dashboards (and other query results), often within about five minutes. Why it matters Unlike Kubernetes and Docker OpenMetrics integrations, which scrape data from Prometheus endpoints, the remote write integration allows you to forward telemetry data from your existing Prometheus servers to New Relic. You can leverage the full range of options for setup and management, from raw data to queries and dashboards and beyond. With the Prometheus remote write integration, you can: Store and visualize crucial metrics on a single platform Combine and group data across your entire software stack Get a fully connected view of the relationship between data about your software stack and the behaviors and outcomes you’re monitoring Connect your Grafana dashboards (optional) Compatibility New Relic supports the Prometheus remote write integration for Prometheus versions 2.15.0 or newer. Scale your data and get moving quickly Once logged in to New Relic, you can get data flowing with a few simple steps: Generate your remote_write URL. Add the new remote_write URL to the configuration file for your Prometheus server. Restart your Prometheus server. View your data. What's next Ready to get started? Read the setup documentation. Configure a Prometheus data source in Grafana. Set up the integration on New Relic US EU For more help Recommendations for learning more: See the Docs site's landing page for Infrastructure integrations documentation. Browse New Relic's Explorers Hub for community discussions about our Infrastructure integrations. Find additional help or file a support ticket. Review New Relic's licenses, attributions, data usage limits, and other notices.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.63566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Prometheus remote <em>write</em> integration",
        "sections": "Prometheus remote <em>write</em> integration",
        "body": "You can use the Prometheus remote <em>write</em> integration to get data flowing into New Relic. Once you integrate, your data will be visible in query-based dashboards (and other query results), often within about <em>five</em> minutes. Why it matters Unlike Kubernetes and Docker OpenMetrics integrations, which"
      },
      "id": "60ea272a196a670c6038adbf"
    },
    {
      "sections": [
        "Scope alert thresholds to specific instances",
        "Example",
        "Create instance-based alert condition",
        "Tip",
        "Use \"By condition\" incident preference",
        "Use REST API for instance alerts",
        "Instance alert API call",
        "Instance alert JSON response",
        "For more help"
      ],
      "title": "Scope alert thresholds to specific instances",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "94a47cc26b7d947b578d39907f8faf74f9e48fcb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/scope-alert-thresholds-specific-instances/",
      "published_at": "2021-09-02T12:07:14Z",
      "updated_at": "2021-08-26T05:37:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can set alert thresholds that trigger when they're violated by any of your Java app's instances. Scoping the condition to instances of your app is helpful for detecting anomalies that occur only in a subset of your app's instances. These sorts of anomalies are easy to miss for apps that aggregate metrics across a large number of instances. By looking at each instance, you can more quickly identify where potential problems are originating. Example In this example, you set up a policy for a Java app with three instances. You want to open a violation when the condition's critical threshold for any instance's error rate is greater than .02% for at least five minutes. During a five-minute time period the three instances have these error rates: App instance 4:45pm 4:50pm Violation opened? A 0.00% 0.00% No. This instance remained below the target threshold the entire time. B 0.02% 0.03% Yes. The alert threshold exceeded the 0.02% threshold for this instance for at least five minutes. C 0.10% 0.00% No. The threshold value must be breached for at least five consecutive minutes to open a violation. However, if you had set the threshold for at least once in five minutes, then the threshold value must be breached at least once during the five-minute period. Create instance-based alert condition To create a policy that triggers notifications for violations by your app's individual instances: Follow the basic workflow process to set up a policy. When creating a condition (step 2), select APM. Select Application metric as the type of condition. To calculate alert threshold violations individually for each of the app's selected instances, select Scope to Java application instances. Select Next, select entities, then identify one or more apps for this condition. Optional: Change the time when New Relic Alerts will force-close the violation (default is 24 hours). Use By condition or By condition and signal incident preference. Continue the rest of the policy workflow process (step 3). Tip To open violations based on the average of all instances for your apps, select Scope to the application instead of Scope to Java application instances. Use \"By condition\" incident preference When setting the incident preference for policies containing instance-based conditions, we recommend that you select By condition instead of By condition and signal. Although apps are the selected entities for this condition, we evaluate each JVM as a separate entity. If you set your Incident preference to By condition and signal, a separate incident will be opened for each JVM that breaches the critical threshold. When an app fails across multiple JVMs, this can lead to alert \"fatigue\" and frustration. Use REST API for instance alerts To create instance-based alert conditions with the New Relic REST API, include these items with your REST API call: Your API key. The numeric entity_id for the entity being monitored The condition_id (available from the API Explorer: Alerts Conditions > GET > List) The entity_type (set to \"application\") The condition_scope (set to \"instance\" for a Java application instance or \"application\" for a Java app) Here is an example of the API request format and JSON response. Instance alert API call Use this format for your API call: curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/12345.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=application&condition_id=234567' Copy Instance alert JSON response The API returns the response as JSON. { \"condition\": [ { \"id\": 234567, \"type\": \"apm_app_metric\", \"name\": \"demo\", \"enabled\": true, \"entities\": [ 12345 ], \"metric\": \"apdex\", \"condition_scope\": \"instance\", <---<<< scope indicator \"violation_close_timer\": 24, \"terms\": [ { \"duration\": \"5\", \"operator\": \"above\", \"priority\": \"critical\", \"threshold\": \"1\", \"time_function\": \"all\" } ] } ] } Copy For more help If you need additional help, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 65.378006,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Scope alert thresholds <em>to</em> specific instances",
        "sections": "For more <em>help</em>",
        "body": " for any instance&#x27;s error rate is greater than .02% for at least <em>five</em> minutes. During a <em>five</em>-minute time period the three instances have these error rates: App instance 4:45pm 4:50pm Violation opened? A 0.00% 0.00% No. This instance remained below the target threshold the entire time. B 0.02% 0.03"
      },
      "id": "6130be7228ccbc35a056a810"
    }
  ],
  "/docs/style-guide/writing-guidelines/formatting-terminal-commands": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writer-workflow/tech-writer-workflow/",
      "sections": [
        "Tech Writer workflow",
        "Resources",
        "Edit in the UI vs local build",
        "Work on a branch, not a fork",
        "Set up your local environment",
        "Run the site locally",
        "Prerequisites",
        "Build the site",
        "Edit a doc",
        "Commit your changes",
        "Publish your commits",
        "Open your pull request",
        "Preview a doc",
        "Revise and publish a doc",
        "Revert merging"
      ],
      "published_at": "2021-09-01T21:57:08Z",
      "title": "Tech Writer workflow",
      "updated_at": "2021-08-27T04:54:57Z",
      "type": "docs",
      "external_id": "074905b02af0ab6eb53640c1c80e83296a8a0b02",
      "document_type": "page",
      "popularity": 1,
      "body": "This document will guide you through the entire workflow for editing the New Relic documentation site as a New Relic Tech Docs Writer. Resources VSCode (or another text editor) VSCode has great GitHub integrations GitHub account GitHub Desktop Edit in the UI vs local build Need to edit a doc? Use this table to decide where to work! Use the UI for: Use the local build for: Adding content to one doc: Rewriting sentences, or 1-2 lines Editing small amounts of content: updating URLs, deleting typos, etc. Brand new docs Rewrites of more than 1 or 2 lines Any updates to doc frontmatter Title changes Taxonomy changes Metadescription updates Redirects Updating images Editing multiple docs at once Continue reading for instructions on how to edit a doc locally. Work on a branch, not a fork Some teams work on branches, some teams work on forks; the docs team works in branches. As long as a branch has been pushed upstream, this allows us to work collaboratively and ensure that no work is ever lost when someone goes on vacation. To create a branch on the docs-website repo: Open GitHub Desktop Click on Current branch: xxx Click on New Branch You will be prompted to name your new branch. Descriptive names are best. It's a great way to quickly clue people in to what your work is all about. For example, if you are working on What’s New pages, you might name the branch Whats-new-updates. When you create a new branch, don't forget to add the Jira issue's key (DOC-1234) to the branch name and the PR title. Set up your local environment Running the site locally makes testing and previewing large changes much easier. Here's how to get setup: Install GitHub Desktop Sign in to GitHub Desktop. On Macs, click on GitHub Desktop in the top left corner of your screen and select Preferences. Select the blue Sign In button and follow the prompts in the browser window. Navigate to the Docs Site repository on GitHub.com. Click the green Code button and then select Open with GitHub Desktop. Choose the location where you want the repo, and this will clone the entire repository to your local machine at the designated path. You can ensure the repo was cloned by navigating to your local GitHub folder (the default is ~/Documents/github). Once you have cloned the repo, you don't need to clone it again in the future. Run the site locally Build the site locally using the terminal to preview changes before opening a Pull Request. While it's highly recommended to build the site locally, this is technically an optional step. The site will automatically reflect any local changes once build. Node and Yarn are tools used to build the site on your local machine. Prerequisites Install Node Install Yarn npm install -g yarn Build the site In your terminal, go to your cloned repo, docs-website. For example: cd ~/Documents/github/docs-website Run yarn with the following commands: yarn && yarn start The site will take a few minutes to build. Make yourself some tea or coffee. Once it's built, you can access your preview site in your browser by navigating to http://localhost:8000/ Edit a doc Once your local environment and branch are set up, you're ready to edit a doc. Check out the style guide for writing guidelines. First, ensure your Current Branch in GitHub Desktop is set to the correct branch, not Develop. Navigate to the doc you want to edit in Finder. If I wanted to edit a Python agent doc, I would navigate to: ~/Documents/github/docs-website/src/content/docs/agents/python-agent/hosting-services/python-agent-stackato.mdx Edit the doc in your text editor of choice. You should write docs in markdown language. Reference the style guide for help with formatting markdown Save the file with your edits, then follow the same process for any other docs you wish to edit. Commit your changes Once your edits are done, you can commit them. This stages your changes, which you will later push upstream to Github. By pushing your changes, everyone will have access to your branch and commits. Navigate to GitHub Desktop. The left column should have a record of all the edits you have made to docs. In the bottom left corner, name your commit and add a good description of your edits. It should be descriptive enough to ensure that someone can understand all the changes made by simply scanning this description. Click Commit to [yourbranchname] Publish your commits Once you have committed your changes, you're almost ready to open your Pull Request. First, you need to ensure your branch is pushed upstream. On GitHub desktop, click the blue Publish Branch button if available. If you don't see the Publish Branch, click the blue Push Origin button. This will push all your commits upstream and make them available to everyone else through the GitHub repository. Open your pull request Now that your commits are available to everyone, you need to notify people that your changes are ready to be merged into the develop branch. To do this, you open a pull request: On GitHub Desktop, click the blue Create Pull Request button. This will open GitHub in your browser, and prompt you to fill in your pull request. Ensure you're merging from your branch into either the main or develop branch. If you scroll down, you can review all your commits to ensure they reflect all your changes. Just like your commit description, your pull request description should be detailed and give the full context of your changes. Feel free to add any additional context here (issue or Jira number, SMEs, etc.) To request a review from another Tech Writer: in GitHub open the PR, navigate to the Conversation section, and then select or type in a reviewer name in the Reviewer section. Add any relevant labels to your PR. If you do not add from_tw, the PR will not be automatically assigned to another writer for review. Once you're satisfied with your pull request, click the green Create pull request button. You can either publish the changes directly by approving the pull request yourself, or you can request for another Tech Writer to peer edit it. At the bottom of the pull request page, you will see a Checks section. These checks ensure your PR doesn't break the build process of the site. Ensure all checks marked required pass before merging. Once the pull request has passed the checks and it has been approved by another tech writer (or you are confident the changes are ready to be published), click the green Merge pull request button. This will merge your branch and commits into the repository and will begin the build process. If you don't add the from_tw label when you first create a PR, it will not automatically assign a reviewer. If you forget to add the label before opening the PR: Add the from_tw label. Turn the PR into a draft PR. Select the PR is ready for review button at the bottom of the page to reopen the PR. The PR should now have a reviewer. Preview a doc There are two main ways to preview branches you’ve already published and run commits on: Local: Quicker, but requires a semi-substantial amount of setup and familiarity with a terminal. Gatsby Cloud: Full preview of the live site with no overhead, and a very convenient way to share a preview of your draft with a SME. Gatsby Cloud will comment on your PR with a link to a preview version of the site once the build is ready. Building the site generally takes about 15 minutes, but can sometimes take longer if there are a lot of changes. Revise and publish a doc If you’re notified that a reviewer has submitted a review to your file, go to your PR and review the changes. You might see them in the diff view, if they’re part of a review with comments; otherwise, they might appear as copy edits in the file. Respond to any comments in the file. Either reply with follow up discussion, or click Resolve conversation. When you’ve resolved all the comments, and all of the automatic checks have passed, you can merge the pull request. Merging the pull request sets in motion the automated build process and your changes will be published shortly. Note: You will only be able to merge when the Merge pull request button is green. If it’s not green, review for any comments you missed, or other messages that indicate why GitHub is blocking you from merging. Revert merging Remember that you can almost always undo things. If you merge a PR, and then find that you shouldn’t have, you can unmerge with the Revert button. On the Pull requests tab in GitHub, click Closed on the tally bar to see all the issues and PRs that have alredy been merged. Locate the PR you merged, and locate the Revert button. Click Revert. That creates a new PR, which needs to be merged. If you want to reopen it, you need to follow the link back to the original PR and either revert that or reopen it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.660706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Yarn npm install -g yarn Build the site In your <em>terminal</em>, go to your cloned repo, docs-website. For example: cd ~&#x2F;Documents&#x2F;github&#x2F;docs-website Run yarn with the following <em>commands</em>: yarn &amp;&amp; yarn start The site will take a few minutes to build. Make yourself some tea or coffee. Once it&#x27;s built, you can"
      },
      "id": "60c6a91764441f404d91f8c6"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/writing-guidelines/code-formatting-guidelines-var-mark/",
      "sections": [
        "Code formatting guidelines: var and mark",
        "var: Highlight user-specific values in procedural code snippets",
        "var format examples",
        "Important",
        "mark: Emphasize non-procedure code snippets"
      ],
      "published_at": "2021-09-01T22:03:57Z",
      "title": "Code formatting guidelines: var and mark",
      "updated_at": "2021-05-16T11:16:42Z",
      "type": "docs",
      "external_id": "dc9b222917947481942168f4004e4401f517b9dd",
      "document_type": "page",
      "popularity": 1,
      "body": "This document serves as a supplement to the basic <var> and <mark> documentation. It gives a longer explanation of when to use the <var> and <mark> formatting styles, and reasons for not using them. var: Highlight user-specific values in procedural code snippets The <var> tag is used for user-input values in code snippets that customers would be using in procedural/functional ways. For example, you would use the <var> tag when explaining how to do some specific task. A <var> tag would not be used for: Example code: If the code is meant to be an example, to show the format/structure of the code, and there is not an actual procedure the customer is following, var tags are not needed. Examples: Example configuration file (or this Java agent config template): if you are showing an example config file that isn't part of a procedure, you shouldn't use the <var> tag. Several reasons for this: 1) The important part of showing an example config file is to show the overall structure of the file, 2) Usually the number of config options present in a file will vary based on whatever the customer wishes to use, so using <var> tags can actually be confusing as it implies that these values must be present. Instrumentation procedure (at bottom of the Java section): the var tag wouldn't be necessary because it's an example, not part of a procedure, and the main goal is seeing the general structure. Also, because it's an example of app code, the concept of user-specific values doesn't have much meaning, because the entire code will vary dependent on how the customer has written their code. (If anything, this would be a potential for using <mark> format to emphasize the New Relic functions.) Response/output code: If the code is meant to show an expected return, and is not related to a procedure, then var tags shouldn't be used. Here's a doc section (the returned JSON) where var tags are not needed. For an example of a doc section with both <var> formatting and without it, see the Synthetics monitors REST API example. The first block shows a command they might choose to run, hence it uses a <var> tag. The second block is just an example output, showing the structure that would be returned; it doesn't require a <var> tag. For some use cases, highlighting may be a better choice than a var tag. var format examples Below are some general style recommendations for formatting user-specific <var> values. <var> tag formatting may vary based on language- or system-specific expectations, so be sure check the style used in the documentation section in question, and to ask relevant SMEs what they think of the style. Account IDs and other IDs/#s: YOUR_ACCOUNT_ID, YOUR_API_CODE, etc. This should be the general style used. URLs: example.com, or maybe YOUR_URL Paths: PATH/TO/SOMETHING.exe or maybe PATH_TO_FILE Emails: datanerd@example.com or maybe YOUR_EMAIL Bash variables for REST API code: Some <var> tagged code values on the docs site have the form $ { API_KEY}. This is a format used for variables in bash scripts, where users assign values to specific variable names and then call those variables later in the script by using the $VARIABLE_NAME. For more info, see this explanation of bash variables. Important The bash variable style is currently used in the REST API docs and in some Synthetics docs and that's fine. But going forward we should use the general variable style (without the $ and &lt; >). mark: Emphasize non-procedure code snippets Highlighting (<mark>) is used for when you want to draw attention to a variable or value, but it's not something directly procedural related. Here are two examples of highlighting: Highlighting values in code response that are meant for later use: Activate Azure integrations doc. Highlighting the commands in a large code block example that are New Relic-specific commands, with explanations below: Java API doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.86948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Code <em>formatting</em> guidelines: var and mark",
        "sections": "Code <em>formatting</em> guidelines: var and mark",
        "body": " to a procedure, then var tags shouldn&#x27;t be used. Here&#x27;s a doc section (the returned JSON) where var tags are not needed. For an example of a doc section with both &lt;var&gt; <em>formatting</em> and without it, see the Synthetics monitors REST API example. The first block shows a <em>command</em> they might choose to run, hence"
      },
      "id": "6042219c64441f52d94e889e"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2021-09-05T01:40:20Z",
      "updated_at": "2020-12-08T13:47:42Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic user key. You can create one from the NerdGraph API Explorer or view and create them in the API keys UI. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. bash Copy $ # curl version $ curl https://api.newrelic.com/graphql \\ > -H 'Content-Type: application/json' \\ > -H 'API-Key: API_KEY_REDACTED' \\ > --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' $ $ # New Relic CLI version $ newrelic nerdgraph query '{ $ actor { $ user { $ name $ email $ } $ account(id: 12345678) $ } $ } $ ' Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer’s Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.45717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Try your NerdGraph query in the <em>terminal</em>",
        "tags": "nerdgraph query <em>terminal</em>",
        "body": "NerdGraph is New Relic&#x27;s GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don&#x27;t need to know the query <em>format</em>: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want"
      },
      "id": "6091fa3928ccbc48dca268a3"
    }
  ],
  "/docs/style-guide/writing-guidelines/hyperlinks": [
    {
      "sections": [
        "apiStyleGuidelines (Example agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples",
        "URL guidelines",
        "Title guidelines",
        "Short title guidelines",
        "Syntax guidelines",
        "Important"
      ],
      "title": "apiStyleGuidelines (Example agent API)",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "41eee9dfacd933b49935d7bd4d32cb76476c29ed",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/article-templates/apistyleguidelines-example-agent-api/",
      "published_at": "2021-09-01T21:49:05Z",
      "updated_at": "2021-03-10T23:41:36Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the \"View all methods\" page. Requirements Agent version 1.2.3.4 or higher. Additional requirements on their own line (do not use bullets). Do not use any callouts. If there are no special requirements, write: Compatible with all agent versions. Description Describe the behavior of the call with as much detail as possible. Do not describe what individual parameters do except in broad strokes; details of parameters and call variants belong under the Parameters heading. Similarly, do not describe return values. When cross-referencing another API call, format its name with code blocks, and include parentheses () like this: anotherCoolMethod(). Tip You can include callouts, but use discretion. These pages are already visually busy. Parameters If there are no parameters, leave this section blank. If there is only one call variant, do not include a syntax block in this section. Parameter Description newrelic.apiStyleGuidelines(data type $parameter_name[, integer $optional_param]) Copy $parameter_name data type Required. Brief description of parameter. $optional_param integer Optional. Brief description of parameter. newrelic.apiStyleGuidelines(data type $parameter_name, array $different_param) Copy $parameter_name data type Required. Brief description of parameter. $different_param array Required. Brief description of parameter. $third_param string Required. Brief description of parameter. Return values What does this call return, and in what circumstances? Are there any things we expect customers to do with that return value? If the call does not return anything, leave this section blank. Examples This section documents rules for oddballs that aren't self-documenting. The rest of the examples are embedded within the page itself. In general, this page is intended for style reference. For examples of how to write good API method pages, check out our existing API docs, such as the PHP API. URL guidelines For the doc's URL: Manually edit the URL slug to remove the agent name. Where the API call does not already include separators (as in newrelic_awesome_call), separate the bits with hyphens -. For example: https://docs.newrelic.com/docs/new-relic-only/advanced-style-guide/writing-guidelines/api-style-guidelines Copy Title guidelines For the doc's title: Include the method name and the agent name in parentheses. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses () in the call itself. For example: apiStyleGuidelines (Example agent API) Copy Short title guidelines For the doc's short title: Include only the method name. Do not include newrelic. prefixes unless they are integral to the call name (as in the PHP agent). Do not include parentheses (). Adjust if necessary to fit on a single line in the category's sidebar. For example: apiStyleGuidelines Copy Syntax guidelines Important The Python and iOS agents use their own guidelines. For those guidelines, see the existing methods in those languages. Document each variant of a call on its own line. Do not use any formatting except italicizing the data type. Wrap optional parameters (including the comma separator) in square brackets []. Indicate the variable portion by prefacing it with a dollar sign $. If the call must be prefixed with newrelic. or similar, include that in the syntax. Optional: Include the return value, if that seems important for your particular agent. If you do, follow language conventions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.66936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "URL <em>guidelines</em>",
        "tags": "API writing <em>guidelines</em>",
        "body": "Syntax newrelic.apiStyle<em>Guidelines</em>(data type $parameter_name[, integer $optional_param]) newrelic.apiStyle<em>Guidelines</em>(data type $parameter_name, array $different_param, string $third_param) Copy Briefly describe the call. Ideally, one line or less on the &quot;View all methods&quot; page. Requirements Agent"
      },
      "id": "60441b8d28ccbc0ab22c60b3"
    },
    {
      "sections": [
        "API tutorial template",
        "Introduction (this heading will not be visible)",
        "Optional: Provide an overview for complex processes",
        "Provide a procedure to accomplish the task",
        "Tip",
        "Step 1. Do something...",
        "If needed: Step 2. Do something else...",
        "If needed: Step 3. Do something else...",
        "Last step. Verify that the task was completed...",
        "Optional: Do something else with the API",
        "Optional: Large example code block",
        "Code block example",
        "Optional: Troubleshooting"
      ],
      "title": "API tutorial template  ",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "API writing guidelines"
      ],
      "external_id": "a3fb036bc32f2dbc39c252acc9306e5ae0d5b7bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/article-templates/api-tutorial-template/",
      "published_at": "2021-09-01T21:48:01Z",
      "updated_at": "2021-03-10T23:40:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content link in the Page tools box. Delete all content up to Introduction (this heading won't be visible). For the doc title (the field at top of page): Doc should be named in a practical, use-case-focused way. Example: Add custom attributes to transactions Introduction (this heading will not be visible) Provide a brief explanation of what this document will teach customers, and why it is valuable for customers to know how to do that. Focus on the value the API provides to the customers and mention specific, common use cases. Any relevant notes about support/compatability should go here, too. Here's an example from the Java API asynchronous tutorial doc: New Relic for Java includes an API to instrument asynchronous activity. For supported frameworks, the Java agent usually instruments async work automatically. However, the async API can be useful for adding more detail to your data. This document provides examples of using tokens and segments to instrument your app. Optional: Provide an overview for complex processes This is an optional section for complicated tutorials that involve either using several methods in one procedure or that have different alternate steps you can take to achieve similar results. This section can link to lower-down sections to allow users to skip around as needed. For simple tutorials, this section isn't necessary. For an example, see this section of the Java async tutorial. Provide a procedure to accomplish the task Tell the user how to accomplish the task, and link to the methods necessary to accomplish that task. As much as possible, we're looking to describe tasks in \"procedures\" (procedure is tech writer jargon for a series of numbered steps). This may be tough to do for fairly open-ended/variable tasks, but it will usually be possible to chunk the content at a fairly high-level to make it into a procedure. Along the way, explain what the importance of the procedure step is, and how one might verify that the step was done correctly. For code samples, avoid using large chunks of code. Instead, use smaller pieces of code and give context for how they are being used. (If you think a large app code example would be helpful, place that later in the doc in the Example section.) Tip For an example of an open-ended task segmented into procedural chunks, see the Asynchronous doc section Connecting async threads. For another example, see this TomCat GAE Flex procedure. Base your procedure on the simple structure below. Tech writers will edit your content to match our style and formatting requirements: Step 1. Do something... Methods and example code to implement the first step. For each step, if applicable, indicate the significance of that step (why it's important) and how the user might verify that the step was done correctly (for example, something showing up in UI, or running a verification test of some sort). If needed: Step 2. Do something else... Methods and example code to implement step 2. If needed: Step 3. Do something else... Methods and example code to implement step 3. Last step. Verify that the task was completed... Explain how a user would know they'd completed the task correctly. In particular, how would the user find the new change or data in the New Relic UI. What NR products and pages would the change be noticed on? If new data shows up in Insights, what event types can it be found under? Optional: Do something else with the API Same as above. Make as many headings and separate procedures as needed. Optional: Large example code block If you think a large app code example would be useful, place here. Within any code block, explain all New Relic functions/methods, not just the main methods. Instead of in-line comments, consider using highlighted sections underneath the code block to give additional context. Here's an example: Code block example The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in New Relic APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. Optional: Troubleshooting Optional area for any common errors or troubleshooting tips.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.669334,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "API writing <em>guidelines</em>",
        "body": "This document is a template for an API tutorial document: Please skim the entire template first to understand the expected structure for this type of doc. Then, clone this doc using the Clone content <em>link</em> in the Page tools box. Delete all content up to Introduction (this heading won&#x27;t be visible"
      },
      "id": "60441b4a64441f7766378f09"
    },
    {
      "sections": [
        "Link your applications to Kubernetes",
        "Tip",
        "Compatibility and requirements",
        "Kubernetes requirements",
        "Network requirements",
        "APM agent compatibility",
        "Openshift requirements",
        "Important",
        "Configure the injection of metadata",
        "Default configuration",
        "Custom configuration",
        "Manage custom certificates",
        "Validate the injection of metadata",
        "Disable the injection of metadata",
        "Troubleshooting"
      ],
      "title": "Link your applications to Kubernetes",
      "type": "docs",
      "tags": [
        "Integrations",
        "Kubernetes integration",
        "Link apps and services"
      ],
      "external_id": "2ae58989813695b48f4924529d6fd6ea17e5f6c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/link-your-applications/link-your-applications-kubernetes/",
      "published_at": "2021-09-01T22:33:28Z",
      "updated_at": "2021-05-28T06:30:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can surface Kubernetes metadata and link it to your APM agents as distributed traces to explore performance issues and troubleshoot transaction errors. For more information, see this New Relic blog post. You can quickly start monitoring Kubernetes clusters using Auto-telemetry with Pixie, which is currently a beta release. This Pixie integration into New Relic does not require a language agent. Learn more about Auto-telemetry with Pixie here. Tip Our Kubernetes metadata injection project is open source. Here's the code to link APM and infrastructure data and the code to automatically manage certificates. Compatibility and requirements Before linking Kubernetes metadata to your APM agents, make sure you meet the following requirements: Kubernetes requirements Network requirements APM agent compatibility OpenShift requirements Kubernetes requirements To link your applications and Kubernetes, your cluster must have the MutatingAdmissionWebhook controller enabled, which requires Kubernetes 1.9 or higher. To verify that your cluster is compatible, run the following command: kubectl api-versions | grep admissionregistration.k8s.io/v1beta1 admissionregistration.k8s.io/v1beta1 Copy If you see a different result, follow the Kubernetes documentation to enable admission control in your cluster. Network requirements For Kubernetes to speak to our MutatingAdmissionWebhook, the master node (or the API server container, depending on how the cluster is set up) should be allowed egress for HTTPS traffic on port 443 to pods in all of the other nodes in the cluster. This might require specific configuration depending on how the infrastructure is set up (on-premises, AWS, Google Cloud, etc). Tip Until Kubernetes v1.14, users were only allowed to register admission webhooks on port 443. Since v1.15 it's possible to register them on different ports. To ensure backward compatibility, the webhook is registered by default on port 443 in the YAML config file we distribute. APM agent compatibility The following New Relic agents collect Kubernetes metadata: Go 2.3.0 or higher Java 4.10.0 or higher Node.js 5.3.0 or higher Python 4.14.0 or higher Ruby 6.1.0 or higher .NET 8.17.438 or higher Openshift requirements To link Openshift and Kubernetes you must enable mutating admission webhooks, which requires Openshift 3.9 or higher. During the process, install a resource that requires admin permissions to the cluster. Run this to log in as admin: oc login -u system:admin Copy Check that webhooks are correctly configured. If they are not, update the master-config.yaml file. admissionConfig: pluginConfig: MutatingAdmissionWebhook: configuration: apiVersion: apiserver.config.k8s.io/v1alpha1 kubeConfigFile: /dev/null kind: WebhookAdmission ValidatingAdmissionWebhook: configuration: apiVersion: apiserver.config.k8s.io/v1alpha1 kubeConfigFile: /dev/null kind: WebhookAdmission location: \"\" Copy Important Add kubeConfigFile: /dev/null to address some issues in Openshift. Enable certificate signing by editing the YAML file and updating your configuration: kubernetesMasterConfig: controllerArguments: cluster-signing-cert-file: - \"/etc/origin/master/ca.crt\" cluster-signing-key-file: - \"/etc/origin/master/ca.key\" Copy Restart the Openshift services in the master node. Configure the injection of metadata By default, all the pods you create that include APM agents have the correct environment variables set and the metadata injection applies to the entire cluster. To check that the environment variables have been set, any container that is running must be stopped, and a new instance started (see Validate the injection of metadata). This default configuration also uses the Kubernetes certificates API to automatically manage the certificates required for the injection. If needed, you can limit the injection of metadata to specific namespaces in your cluster or self-manage your certificates. Default configuration To proceed with the default injection of metadata, follow these steps: Download the YAML file: curl -O http://download.newrelic.com/infrastructure_agent/integrations/kubernetes/k8s-metadata-injection-latest.yaml Copy Replace YOUR_CLUSTER_NAME with the name of your cluster in the YAML file. Apply the YAML file to your Kubernetes cluster: kubectl apply -f k8s-metadata-injection-latest.yaml Copy Custom configuration You can limit the injection of metadata only to specific namespaces by using labels. To enable this feature, edit your YAML file by finding and uncommenting the following lines: # namespaceSelector: # matchLabels: # newrelic-metadata-injection: enabled Copy With this option, injection is only applied to those namespaces that have the newrelic-metadata-injection label set to enabled: kubectl label namespace YOUR_NAMESPACE newrelic-metadata-injection=enabled Copy Manage custom certificates To use custom certificates you need a specific YAML file: Download the YAML file without automatic certificate management: curl -O http://download.newrelic.com/infrastructure_agent/integrations/kubernetes/k8s-metadata-injection-custom-certs-latest.yaml Copy Replace YOUR_CLUSTER_NAME with the name of your cluster in the YAML file. Apply the YAML file to your Kubernetes cluster: kubectl apply -f k8s-metadata-injection-custom-certs-latest.yaml Copy Once you have the correct YAML file, you can proceed with the custom certificate management option. You need your certificate, server key, and Certification Authority (CA) bundle encoded in PEM format. If you have them in the standard certificate format (X.509), install openssl, and run the following: openssl x509 -in CERTIFICATE_FILENAME -outform PEM -out CERTIFICATE_FILENAME.pem openssl x509 -in SERVER_KEY_FILENAME -outform PEM -out SERVER_KEY_FILENAME.pem openssl x509 -in CA_BUNDLE_FILENAME -outform PEM -out BUNDLE_FILENAME.pem Copy If your certificate/key pair are in another format, see the Digicert knowledgebase for more help. Create the TLS secret with the signed certificate/key pair, and patch the mutating webhook configuration with the CA using the following commands: kubectl create secret tls newrelic-metadata-injection-secret \\ --key=PEM_ENCODED_SERVER_KEY \\ --cert=PEM_ENCODED_CERTIFICATE \\ --dry-run -o yaml | kubectl -n default apply -f - caBundle=$(cat PEM_ENCODED_CA_BUNDLE | base64 | td -d '\\n') kubectl patch mutatingwebhookconfiguration newrelic-metadata-injection-cfg --type='json' -p \"[{'op': 'replace', 'path': '/webhooks/0/clientConfig/caBundle', 'value':'${caBundle}'}]\" Copy Important Certificates signed by Kubernetes have an expiration of one year. For more information, see the Kubernetes source code in GitHub. Validate the injection of metadata In order to validate that the webhook (responsible for injecting the metadata) was installed correctly, deploy a new pod and check for the New Relic environment variables. Create a dummy pod containing Busybox by running: kubectl create -f https://git.io/vPieo Copy Check if New Relic environment variables were injected: kubectl exec busybox0 -- env | grep NEW_RELIC_METADATA_KUBERNETES NEW_RELIC_METADATA_KUBERNETES_CLUSTER_NAME=fsi NEW_RELIC_METADATA_KUBERNETES_NODE_NAME=nodea NEW_RELIC_METADATA_KUBERNETES_NAMESPACE_NAME=default NEW_RELIC_METADATA_KUBERNETES_POD_NAME=busybox0 NEW_RELIC_METADATA_KUBERNETES_CONTAINER_NAME=busybox Copy Disable the injection of metadata To disable/uninstall the injection of metadata, use the following commands: Delete the Kubernetes objects using the yaml file: kubectl delete -f k8s-metadata-injection-latest.yaml Copy Delete the TLS secret containing the certificate/key pair: kubectl delete secret/newrelic-metadata-injection-secret Copy Troubleshooting Follow these troubleshooting tips as needed. No Kubernetes metadata in APM or distributed tracing transactions Problem The creation of the secret by the k8s-webhook-cert-manager job used to fail due to the kubectl version used by the image when running in Kubernetes version 1.19.x, The new version 1.3.2 fixes this issue, therefore it is enough to run again the job using an update version of the image to fix the issue. Solution Update the image k8s-webhook-cert-manager (to a version >= 1.3.2) and re-run the job. The secret will be correctly created and the k8s-metadata-injection pod will be able to start. Note that the new version of the manifest and of the nri-bundle are already updated with the correct version of the image. Problem In OpenShift version 4.x, the CA that is used in order to patch the mutatingwebhookconfiguration resource is not the one used when signing the certificates. This is a known issue currently tracked here. In the logs of the Pod nri-metadata-injection, you'll see the following error message: TLS handshake error from 10.131.0.29:37428: remote error: tls: unknown certificate authority TLS handshake error from 10.129.0.1:49314: remote error: tls: bad certificate Copy Workaround Manually update the certificate stored in the mutatingwebhookconfiguration object. The correct CA locations might change according to the cluster configuration. However, you can usually find the CA in the secret csr-signer in the namespace openshift-kube-controller-manager. Problem There is no Kubernetes metadata included in the transactions' attributes of your APM agent or in distributed tracing. Solution Verify that the environment variables are being correctly injected by following the instructions described in the Validate your installation step. If they are not present, get the name of the metadata injection pod by running: kubectl get pods | grep newrelic-metadata-injection-deployment kubectl logs -f pod/podname Copy In another terminal, create a new pod (for example, see Validate your installation), and inspect the logs of the metadata injection deployment for errors. For every created pod there should be a set of 4 new entries in the logs like: {\"level\":\"info\",\"ts\":\"2020-04-09T12:55:32.107Z\",\"caller\":\"server/main.go:139\",\"msg\":\"POST https://newrelic-metadata-injection-svc.default.svc:443/mutate?timeout=30s HTTP/2.0\\\" from 10.11.49.2:32836\"} {\"level\":\"info\",\"ts\":\"2020-04-09T12:55:32.110Z\",\"caller\":\"server/webhook.go:168\",\"msg\":\"received admission review\",\"kind\":\"/v1, Kind=Pod\",\"namespace\":\"default\",\"name\":\"\",\"pod\":\"busybox1\",\"UID\":\"6577519b-7a61-11ea-965e-0e46d1c9335c\",\"operation\":\"CREATE\",\"userinfo\":{\"username\":\"admin\",\"uid\":\"admin\",\"groups\":[\"system:masters\",\"system:authenticated\"]}} {\"level\":\"info\",\"ts\":\"2020-04-09T12:55:32.111Z\",\"caller\":\"server/webhook.go:182\",\"msg\":\"admission response created\",\"response\":\"[{\\\"op\\\":\\\"add\\\",\\\"path\\\":\\\"/spec/containers/0/env\\\",\\\"value\\\":[{\\\"name\\\":\\\"NEW_RELIC_METADATA_KUBERNETES_CLUSTER_NAME\\\",\\\"value\\\":\\\"adn_kops\\\"}]},{\\\"op\\\":\\\"add\\\",\\\"path\\\":\\\"/spec/containers/0/env/-\\\",\\\"value\\\":{\\\"name\\\":\\\"NEW_RELIC_METADATA_KUBERNETES_NODE_NAME\\\",\\\"valueFrom\\\":{\\\"fieldRef\\\":{\\\"fieldPath\\\":\\\"spec.nodeName\\\"}}}},{\\\"op\\\":\\\"add\\\",\\\"path\\\":\\\"/spec/containers/0/env/-\\\",\\\"value\\\":{\\\"name\\\":\\\"NEW_RELIC_METADATA_KUBERNETES_NAMESPACE_NAME\\\",\\\"valueFrom\\\":{\\\"fieldRef\\\":{\\\"fieldPath\\\":\\\"metadata.namespace\\\"}}}},{\\\"op\\\":\\\"add\\\",\\\"path\\\":\\\"/spec/containers/0/env/-\\\",\\\"value\\\":{\\\"name\\\":\\\"NEW_RELIC_METADATA_KUBERNETES_POD_NAME\\\",\\\"valueFrom\\\":{\\\"fieldRef\\\":{\\\"fieldPath\\\":\\\"metadata.name\\\"}}}},{\\\"op\\\":\\\"add\\\",\\\"path\\\":\\\"/spec/containers/0/env/-\\\",\\\"value\\\":{\\\"name\\\":\\\"NEW_RELIC_METADATA_KUBERNETES_CONTAINER_NAME\\\",\\\"value\\\":\\\"busybox\\\"}},{\\\"op\\\":\\\"add\\\",\\\"path\\\":\\\"/spec/containers/0/env/-\\\",\\\"value\\\":{\\\"name\\\":\\\"NEW_RELIC_METADATA_KUBERNETES_CONTAINER_IMAGE_NAME\\\",\\\"value\\\":\\\"busybox\\\"}}]\"} {\"level\":\"info\",\"ts\":\"2020-04-09T12:55:32.111Z\",\"caller\":\"server/webhook.go:257\",\"msg\":\"writing response\"} Copy If there are no new entries on the logs, it means that the apiserver is not being able to communicate with the webhook service, this could be due to networking rules or security groups rejecting the communication. To check if the apiserver is not being able to communicate with the webhook you should inspect the apiserver logs for errors like: failed calling webhook \"metadata-injection.newrelic.com\": ERROR_REASON Copy To get the apiserver logs: Start a proxy to the Kubernetes API server by the executing the following command in a terminal window and keep it running. kubectl proxy --port=8001 Copy Create a new pod in your cluster, this will make the apiserver try to communicate with the webhook. The following command will create a busybox. kubectl create -f https://git.io/vPieo Copy Retrieve the apiserver logs. curl localhost:8001/logs/kube-apiserver.log > apiserver.log Copy Delete the busybox container. kubectl delete -f https://git.io/vPieo Copy Inspect the logs for errors. grep -E 'failed calling webhook' apiserver.log Copy Remember that one of the requirements for the metadata injection is that the apiserver must be allowed egress to the pods running on the cluster. If you encounter errors regarding connection timeouts or failed connections, make sure to check the security groups and firewall rules of the cluster. If there are no log entries in either the apiserver logs or the metadata injection deployment, it means that the webhook was not properly registered. Ensure the metadata injection setup job ran successfully by inspecting the output of: kubectl get job newrelic-metadata-setup Copy If the job is not completed, investigate the logs of the setup job: kubectl logs job/newrelic-metadata-setup Copy Ensure the CertificateSigningRequest is approved and issued by running: kubectl get csr newrelic-metadata-injection-svc.default Copy Ensure the TLS secret is present by running: kubectl get secret newrelic-metadata-injection-secret Copy Ensure the CA bundle is present in the mutating webhook configuration: kubectl get mutatingwebhookconfiguration newrelic-metadata-injection-cfg -o json Copy Ensure the TargetPort of the Service resource matches the Port of the Deployment's container: kubectl describe service/newrelic-metadata-injection-svc kubectl describe deployment/newrelic-metadata-injection-deployment Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.2146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Link</em> your applications to Kubernetes",
        "sections": "<em>Link</em> your applications to Kubernetes",
        "tags": "<em>Link</em> apps and services",
        "body": "You can surface Kubernetes metadata and <em>link</em> it to your APM agents as distributed traces to explore performance issues and troubleshoot transaction errors. For more information, see this New Relic blog post. You can quickly start monitoring Kubernetes clusters using Auto-telemetry with Pixie, which"
      },
      "id": "603ebb94196a674fd1a83df3"
    }
  ],
  "/docs/style-guide/writing-guidelines/levels-headings": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/get-started/introduction-style-guide/",
      "sections": [
        "Introduction to the style guide",
        "Organize your doc to make it easier to read",
        "Use action-oriented titles",
        "Start the document with an introductory paragraph",
        "Keep documents short",
        "Use the New Relic voice",
        "Change doc titles and anchors",
        "Create and edit categories",
        "Start writing and editing docs"
      ],
      "published_at": "2021-09-01T21:50:48Z",
      "title": "Introduction to the style guide",
      "updated_at": "2021-04-12T11:26:22Z",
      "type": "docs",
      "external_id": "b0bfbe0b3791c4feb00fe86a41e49312cd9e82cd",
      "document_type": "page",
      "popularity": 1,
      "body": "We've written these guidelines to make it easier for you to contribute to our docs, as well as to give you some insight into how we think about good technical writing. We, the Tech Docs team, rely on your expertise to keep New Relic's documentation updated and useful. Thank you for your willingness to share your knowledge! Our style guide focuses on style and usage that's particular to our site. Our site follows American English conventions. For topics that aren't covered, please refer to the Microsoft Writing Style Guide (for guidelines on technical terminology) or the Chicago Manual of Style (for general writing and editing guidelines). Organize your doc to make it easier to read Consider these organization guidelines when thinking about the order of information in a doc. By following these guidelines, you'll make it easier for readers to skim and find what they need. How to organize information Comments Separate what and why from how. Define any necessary prerequisites, policies, or background information (the what and the why) before you step through the how (step-by-step procedures). Examples: Explain what the feature is and why it matters before telling readers how to use it. Describe any limitations with user permissions or subscription levels that would prevent them from using the feature. If the feature is available for any user or subscription level, don't bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting a procedure that they have everything they need. Front-load directions with context. Make sure readers know where they need to be, before telling them what to do. In general, use (select an app) to describe what users select from the product index. Examples: Go to one.newrelic.com > Explorer > (select an app or service). Select (account dropdown) > User preferences. On the command line, type gitk. Also, structure steps by front-loading context from the user's point of view. For example, instead of \"Go to x to do y,\" structure the step as \"To do y, go to x.\" Separate requirements from options. Example: Type the Email you use to sign in and to receive information from New Relic. Optional: Type additional user emails, separated by commas. Follow the \"five to nine\" guideline. Depending on the topic, organize the information so there is a maximum of five to nine chunks of information. For example, readers may start to get lost or overwhelmed after about five h2 sections or seven steps into a procedure. If you have more than nine h2 sections or steps, you might need to create an additional doc or procedure. Other organization tools to consider: Levels of headings Lists Collapsers Callouts Tables Code examples For more help section Use action-oriented titles Wherever possible, give your document or h2 heading a task- or action-oriented title. Focus on what users are trying to accomplish or the problem they're trying to solve. Use present-tense verbs, rather than \"-ing\" verbs. Quality Title example Bad The query history Okay View query history Good Query history: Create and edit NRQL queries Start the document with an introductory paragraph Unless the document is less than a single screen in length, begin with a brief paragraph that introduces the topic or summarizes the important points. Not sure where to start? Try writing all the content for your document first, and then add the introduction to the top to summarize your key points. Or use the introduction to expand on the text in your metaDescription in the metadata. Keep documents short The amount of content needed can help you decide whether you need one or more documents for the topic. If all of the document's contents apply directly to the title, then everything belongs in the same document. If several related sections could be logically split into individual documents, and the overall length of your document is more than about two screenfuls, split those sections into other documents. Be sure to include links to the related contents. If a large document needs to be broken into multiple smaller documents, consider whether they might be best grouped together in their own sub-category. Use the New Relic voice We strive for a voice that's approachable, expert, and visionary. Check out our voice guidelines for how to write content with these qualities. And keep in mind these essential writing tips that apply to any type of documentation. Guidelines Comments Be clear and direct. Remember to: Use present tense. Use active voice; avoid passive voice. Tell users what to do, not what they \"should\" do. If absolutely necessary, tell users what not to do in situations where unexpected results may occur. Whenever possible, provide an alternative suggestion when telling users what not to do. Example: Using active voice with an alternative suggestion for what not to do Do not use your config file to change this setting, because this could affect other processes. Instead, go to one.newrelic.com > APM > (select an app or service) > Settings > Application. Write to aid localization and translation. Do not use euphemisms, idioms, jargon, or slang. Use the same terms and wording consistently. If you need to include an abbreviation or acronym, spell it out the first time it appears in the document. Always take a moment to ask yourself whether people will really understand the terms you are using in the way you're using them. Change doc titles and anchors Because changes to doc titles, anchors, and redirects can break links to other docs, please create an issue to request these types of changes and we'll help you out with that. Create and edit categories Because changes to categories can affect large groups of docs at once, please create an issue to request these types of changes and we'll help you out with that. Start writing and editing docs You are ready to start writing and editing New Relic docs! To learn the steps for basic docs, see Create and edit content. To learn how to create and publish release notes, see Create release notes. To make it even easier to start a new doc, use templates.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 445.90256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " it. Describe any limitations with user permissions or subscription <em>levels</em> that would prevent them from using the feature. If the feature is available for any user or subscription <em>level</em>, don&#x27;t bother to say so. Provide a roadmap for what users will be able to accomplish, so they know before starting"
      },
      "id": "60415293e7b9d262f32a07d7"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Important",
        "Products and features",
        "UI elements and UI page paths",
        "Watermarks"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "7a4d6c67e7c4737414cc99d452577f79dfc79ffc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/capitalization/",
      "published_at": "2021-09-01T21:52:38Z",
      "updated_at": "2021-06-20T21:09:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our Screenshots and images document for more information on our image guidelines. Products and features Item Example We use title case for products. Full Stack Observability We don't capitalize features (including features that used to be products). Use transaction traces to... not Use Transaction Traces to... Our infrastructure monitoring... not Our Infrastructure monitoring... UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing. Watermarks Item Example We use all caps for BETA or NR ONLY. <div id=\"watermark\">NR ONLY</div> Copy Otherwise use sentence case. <div id=\"watermark\">Legacy</div> Copy Include break (br /) for longer watermarks. <div id=\"watermark\">Limited <br /> release</div> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.52051,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use sentence case in <em>headings</em>",
        "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document&#x27;s title, <em>headings</em>, products, features, and other elements"
      },
      "id": "60421e50196a67d785a83d97"
    },
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "6dcea91eb875e69ab1786a4b5787615be7964bfe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-09-01T21:50:48Z",
      "updated_at": "2021-04-05T08:33:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or Docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the Docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.954216,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Headings</em> (H2s)",
        "body": " that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they&#x27;ve found the right doc. It provides a short, readable overview of the doc&#x27;s contents. <em>Headings</em> (H2s) Check that: Heading names are concise, yet provide information that helps readers"
      },
      "id": "604220b2196a6775f5a83dc0"
    }
  ],
  "/docs/style-guide/writing-guidelines/more-help-section": [
    {
      "image": "https://docs.newrelic.com/static/e8d42feaa627a4f1abd362c85a07596d/c1b63/example-doc-in-folder.png",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/understand-edit-docs-site-structure/",
      "sections": [
        "Understand and edit docs site structure (nav file, sidebar, categories)",
        "Terms",
        "Understand how the docs site structure works",
        "How is the displayed structure related to the actual folders?",
        "What determines a doc's URL?",
        "What does a nav file do?",
        "Where is the docs site structure exposed?",
        "What determines a doc's sidebar?",
        "When you click a sidebar category, what determines how that category view displays?",
        "Nav file format",
        "Tip",
        "Procedures",
        "Add a new category",
        "Add a new nav file",
        "Add a new category to a nav file",
        "Add a doc to sidebar/nav-file",
        "Add doc in multiple sidebar locations",
        "Move docs to other categories",
        "Move docs using nav file",
        "Move docs between folders",
        "Move or delete a folder",
        "Create a \"dummy\" sub-category of docs that don't live in that category",
        "Make a sidebar category heading clickable",
        "Troubleshoot category views not working correctly"
      ],
      "published_at": "2021-09-01T21:52:39Z",
      "title": "Understand and edit docs site structure (nav file, sidebar, categories)",
      "updated_at": "2021-09-01T04:18:46Z",
      "type": "docs",
      "external_id": "5498c89c5d5497ac899f70f86bb8bf0cda4bc840",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains information and procedures pertaining to the structure of the docs site, including: the nav files, the sidebar, docs category (index) views, and more. For succinct instructions, see Procedures, but it is highly recommended you understand the general concepts of how the docs site structure works if you will be doing larger docs site projects. Terms When talking about the docs site structure, sometimes people use different words for the same things. Below is a list of terms that can help us communicate about the docs site structure: Nav files: In the github docs site, there are yaml files under the nav folder that are used to determine the docs site structure that we display. This structure is exposed in the docs site left sidebar and when you view docs category views (also known as index views, like this one). Folder: We sometimes use \"folders\" to refer to the actual docs site folder structure (those folders and files in the content section). This is a way to differentiate between the actual folder structure and the displayed structure that's set using the nav files. Sidebar: On public-facing docs, the sidebar is what is visible on the left hand side, showing the structure of that category of docs. The sidebar and index view are both determined by the structure set in the nav file. Category or subcategory: we use these words a bit interchangeably to refer to the various levels of docs site categories. For example, this view shows a list of docs in a specific category, as does this higher level category view. Index: In this context, an \"index\" is sometimes used to refer to a view of a certain category of docs (like this one). \"Index\" and \"category\" can be used a bit interchangably, but the gist is that the \"index\" term refers to a docs category being displayed in a page load. (Note that this is a different, more general use of the term than the index.mdx files that are used to build landing pages.) Understand how the docs site structure works This section will explain some of the logic behind how the docs site structure is determined and how the structure we display to the public relates to the actual docs folder structure. How is the displayed structure related to the actual folders? The actual docs folder structure (the folders and mdx files in the content folder) is entirely separate from the docs site structure that we display (e.g., the structure shown in the sidebar and category views like this one). The displayed structure of the docs site is determined solely by the nav files (the yaml-format files in the nav folder). It's important to understand the above point. The divergence of the docs folder structure and the displayed docs site structure is necessary: we need a way to control the displayed site structure, which is used for the sidebar and category views, without requiring us to keep the folder structure and folder names and doc file names completely parallel and matching. Because these two things are so separate, it means we have some fairly complex behind-the-scenes logic to get them to work together. And this means that there can be fairly unintuitive aspects of how that logic works. We do have procedures for common use cases, but it will help you a lot to understand the specifics below of how the displayed structure is generated. What determines a doc's URL? Where a doc file (mdx file) is located in the content folder, and the associated folder and file names, are the only factors that govern that doc's URL. For example, consider the following doc file automated-user-provisioning-single-sign.mdx: This doc's URL is solely based on its folder location and the names of the folders. In this case, its URL is: docs.newrelic.com/docs/accounts/accounts/automated-user-management/automated-user-provisioning-single-sign Copy This has important implications, including: When you move a doc from one folder to another, its URL changes, and this means that you will have to add a redirect to that doc of its original URL. If you rename an mdx file name or a folder name, that changes its URL, so that means you would have to add a redirect to that doc for its original URL. What does a nav file do? The nav files are quite simple. A nav file controls these things: The docs structure (the various levels of docs) for that category of docs. The category headers, set by title (e.g., \"On-host integrations list\") and path (e.g., \"/docs/integrations/on-host-integrations\"). The doc information, set by title (e.g., \"NGINX integration\") and path (the doc's URL). A category and a doc in a nav file have the same elements: a title and a `path. What separates a category from a doc is that: A category contains docs in the level below it. If a category has a path (which isn't required but should be present for most docs), the path points to a content docs folder that has at least one doc in it. For more on nav file format, see Nav file format Where is the docs site structure exposed? The structure set in the nav files is exposed in two places: The left sidebar of a doc that shows the structure of that category. When a category header in the sidebar is clicked, it shows a view of that docs site category. Doc category views, also sometimes called index views: for example, this view, which shows a particular section of docs. What determines a doc's sidebar? As stated above, the sidebar is just one way that the docs site structure governed by the nav files is exposed. When a doc is loaded, the docs site searches for that URL in the nav files. If it finds a match, it displays that nav file in the sidebar with that doc highlighted. If it finds that doc in more than one nav file, it attempts to find the right nav file by choosing the nav that matches the top level category in the doc URL. For example, if a doc with a relative URL /docs/accounts/accounts-billing/account-setup/create-your-new-relic-account was in two nav files, the docs site code would search to see if one of the nav files has docs/accounts as its first path field. If it finds a match, it uses that nav file. For an example of a doc that is placed in two different nav files, in this category view click the Manage data doc and see how, when it loads, it displays the sidebar for the nav file that better matches its URL. When you click a sidebar category, what determines how that category view displays? When you click on a docs category header in the sidebar and a docs category view loads (like this one), what governs what is displayed there? Here is how this process works: A category header in the sidebar has an associated URL, which is set in the nav file. In the example nav file snippet below, the Get started category view has a path set to /docs/apis/intro-apis. This is what governs the sidebar heading title of \"Get started\" and tells it the URL to use. - title: APIs path: /docs/apis pages: - title: Get started path: /docs/apis/intro-apis pages: - title: New Relic APIs path: /docs/apis/intro-apis/introduction-new-relic-apis - title: API keys path: /docs/apis/intro-apis/new-relic-api-keys Copy If the associated folder of that path has an index mdx file (representing a landing page, like this one), the docs site displays that landing page. If there is no landing page, we check to see if that path matches an actual folder that has at least one mdx file. In other words, if we instead put in a completely arbitrary URL path for a category path, like docs/random-category/random-category-2, it would not work. It requires an existing folder with at least one doc in there. Other aspects to consider: Note that a category doesn't need a path link in the nav file; that is just what tells it to create a link and a URL for that view. If a category in a nav file lacks a path, it won't have a link or associated URL for it (for an example, see the \"New Relic University\" category in this section). Having a category without an associated link/URL can be an acceptable choice if you are creating a category of docs that don't reside in that section and you simply want to give a helpful category view in the sidebar. Note that every URL based on actual folder structure can create a theoretical URL. For example, here's a URL based on an actual folder containing one doc. But because there is no path in a nav file corresponding to that URL, it doesn't display anything. Nav file format Below is a snippet of the agents.yml nav file. Note that the file has indentation that corresponds to the level of the navigation hierarchy. When making changes or creating a new nav file, be sure to use the existing spacing format. yml title: Agents path: /docs/agents pages: - title: Manage APM agents path: /docs/agents/manage-apm-agents pages: - title: Agent data path: /docs/agents/manage-apm-agents/agent-data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Tip Navigation nesting is currently limited to a maximum of six levels deep. Please reach out to the engineering team if that is not enough. Here are important elements of the nav file: Key Required? Description title yes The text shown in the navigation, either of a doc or a category. path yes The URL path to the doc or the category view. Do not use trailing slashes. For docs categories in the nav file, the path is required to create an index view. Without the path, a docs category won't be clickable as a link and won't display a view of those docs. Learn more about index views. rootNav no rootNav controls whether a nav file will be displayed or hidden on the docs site home page. It is enabled by default. If you want to hide a category from the home page (as we do for our style guide docs, for example), you would set this to false, as shown below: title: Style guide path: /docs/style-guide rootNav: false Copy children no This is hardly ever used. It indicates a sub-navigation node. Procedures Below are instructions for several common procedures. It may help you to review the terms we use before starting a procedure. Procedures include: Add a new category Add a doc to sidebar/nav-file Move docs between folders or categories Move or delete folders Create a \"dummy\" category for docs that don’t live in that area Make a category heading clickable Troubleshoot messed up category views Add a new category We'll explain two procedures: adding a subcategory of docs in an existing nav file, and adding an entirely new nav file. Add a new nav file Adding an entirely new nav file should be rare, and something we only do occasionally during large overhauls of site structure. To add an entirely new nav file: Copy an existing file nav file, or create a new nav file. Customize the new nav file with the categories and docs you want, using the structure of existing nav files as a template. For more on structure, see nav format. Tip You need at least one level of nesting inside the nav file. Without that, doc titles in the auto-generated category views will render as H2 headings. For example, src/content/level-one/level-two/doc will work, but src/content/level-one/doc will produce strange formatting. If you don't want your new nav to appear on the main landing page, add rootNav: false to your .yml file. (For an example of this, see src/nav/style-guide.yml.) Add a new category to a nav file To add a new category to a nav file: In an existing nav file, add a new category, represented by its title and path. If you're adding a path for that category (recommended), it must use the URL of an existing folder with at least one mdx file in it. Add the docs you want in that section. Ensure your new content matches the indenting of the surrounding nav file. To learn more about how this works, see: How a doc's sidebar is determined How a doc category view is determined If a category view isn't clickable, see Make category view clickable. Add a doc to sidebar/nav-file Once you create a doc, you need to place it in one or more nav files. To do this: In the nav file location where you want to locate it, add the title (its short title displayed in the sidebar and category views) and the path, which is the doc's URL. Ensure that you've emulated the indenting based on the surrounding nav file content or other nav files. Add doc in multiple sidebar locations To add a doc in more than one sidebar location, simply add that doc (its title and path) wherever you want it to be in the nav file. For more on how the sidebar is determined for docs in multiple nav files, see Sidebar. You can add a doc URL in multiple nav file locations. Move docs to other categories Because the nav file and the actual folder structure aren't connected, there are two different ways to \"move docs\": Move a doc in the nav files: preferred and most common procedure. Move a doc between folders: less frequent, mainly when doing larger projects where we want to do a significant overhaul of the docs structure and want to ensure the folder structure doesn't become too divergent from the nav file structure. Move docs using nav file You would move a doc in the nav file when you want to change its location in the displayed docs site structure (i.e., the sidebar and docs category views). To move a doc from one place to another in the nav file: In the first nav file, copy the two rows representing that doc's entry (the title and path lines) and paste that content into the place you want it to live in the new nav file. In the new nav file section, make sure that new content is aligned properly with the surrounding nav file content. See [#nav-format] for more about nav file structure. Move docs between folders Note that moving docs between the folders should be relatively rare. The main reasons to do this are when the folder structure and nav file structure are becoming very different, which can be bad for a couple reasons: Too much divergence can create issues with category view displays or sidebar actions. Too much divergence can make finding and editing docs harder, so there can be value to keeping things fairly up to date and parallel. When you move a doc between folders or rename a doc, that changes its URL. Similarly, if you rename a folder, that changes the URL of all docs in that area. To move a doc between folders: Get the current URL of the doc you want to move and add that URL to its own list of redirects. Tips: One way to do this in VSCode is to right click the file and click \"Get relative path\". If you are moving many files, ask the team about ways to programmatically add redirects. Remove the trailing slash. Move the doc to the new folder. Update nav files with the new URL. This is easily overlooked but having the correct doc URL in the nav file, and not a redirect, is important. Note that a doc URL may be in more than one nav file so searching the site for that URL can help. Move or delete a folder Sometimes when we are doing a larger restructuring project, we may want to move or delete the actual folders instead of simply editing the nav files. If you are moving an entire folder or multiple folders to another folder, docs and all: Simply move these folders using your preferred method (e.g., using drag and drop) to the new location. Next, because that move changes all the URLs of the docs and categories, you'll need to add redirects: For adding redirects for docs, see the procedures for moving a doc between folders. For category redirects: For the section of the nav file affected by your folder editing, gather all the category URLs (path fields) that relate to the moved or deleted folders. We don't need to redirect all folder-related URL paths: we only need to redirect the nav file paths because those represent the paths that we actually link to in the docs (in other words: we aren't using folder-based URLs if they don't have a nav file path). Add those category path URLs as redirects in specific docs or, if that won't work, in the taxonomy-redirects file. We should aim to add category redirects in specific docs and the reason for this is that the taxonomy-redirects file is hard to use and because it's a better customer experience to land on a doc versus a category if possible. In most cases, you'll be able to find a fitting doc to redirect to but if only a category view makes sense, use the taxonomy redirects file. For larger projects, this can be tough work, so you'll want to check out the build and make sure all the sidebar links and category headers are working as expected. For deleting folders, you'll want to essentially follow the same steps as above: either moving or deleting the docs in those folders first, gathering the affected category path URLs and adding them as redirects, adn then deleting the empty folders. Create a \"dummy\" sub-category of docs that don't live in that category Sometimes you want to create a category of docs that is there to help expose a related doc or set of docs. For example, in this view, we have added a category for 'New Relic University' even though that's not a doc that lives in that section; in this case, it's not even a doc on our site. In the example above, this 'New Relic University' category header is in regular text and not a link, and that's because it doesn't have a path set for it in the nav file. This also means that in the sidebar, this category header is not a clickable link and simply functions as a collapser/expander. This is acceptable if you don't mind it but below we explain how you can get a clickable category if you need it. To create a so-called \"dummy\" category: Add the category structure you want in the nav file. If you're okay not having a clickable category header, your new category doesn't require a path. If you want a clickable category header, you will need to use or create a folder that matches the new category path and that has at least one mdx file in it (details). In the nav file, add the title and path information for the docs you want in that new category. Test your new category to ensure it is working correctly. Make a sidebar category heading clickable If there's a sidebar category that's only acting as an expander/collapser and doesn't have a link, that's because it either a) doesn't have a path set in the nav file, or b) that path goes to a folder that doesn't have a doc in it. For more on this, see the instructions regarding clickable headers in the \"dummy\" category section. Troubleshoot category views not working correctly If a docs category view is not working correctly, review how category views are formed. If this does happen, get another opinion from another tech writer to make sure you're not missing something, as we should rarely have problems. One reason that a category view might not work is specifically for path URLs that are also landing pages. In this case, if that path is used in more than one location in the same nav file, the docs site can be confused about which category view to use. We may fix this with a coding fix but in meantime: consider pointing to other URLs and not that path, so that there's only one use of that path per nav file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.087906,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Nav file <em>format</em>",
        "body": " displayed in a page load. (Note that this is a different, <em>more</em> general use of the term than the index.mdx files that are used to build landing pages.) Understand how the docs site structure works This <em>section</em> will explain some of the logic behind how the docs site structure is determined and how"
      },
      "id": "612eff27e7b9d25b16b6f24c"
    },
    {
      "sections": [
        "Rename or redirect a document",
        "Caution",
        "URL format",
        "Change titles",
        "Change anchor links",
        "Edit redirects"
      ],
      "title": "Rename or redirect a document",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "f117225cac5b0cf73daa56bd32807c4a58c4a31e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/rename-or-redirect-document/",
      "published_at": "2021-09-01T19:30:05Z",
      "updated_at": "2021-09-01T19:30:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to change the title of a document and how to create, edit, and delete redirects. Procedures are the same for both standard docs (\"basic pages\") and release notes. Caution Changing titles or updating redirects can create issues with finding content. If you need to change a title or a redirect, create a GitHub issue or, if you're a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document's URL is based solely on its filename and filepath in the GitHub repo. For more information, see Doc URL. Change titles To change a document title, change the title being used in the title field in the frontmatter at the top of the doc. If you want to update a title in the sidebar, change the title for that doc in the nav file. Change anchor links Wherever possible, do not change the [#anchor_ids] of an H2 or collapser. There is no way to redirect from a deleted anchor to its new value. Even if the anchor id is outdated, this does not affect the majority of users who pay no attention to URLs. Edit redirects If you change the URL of a doc, make sure you add the old URL to the redirects frontmatter section at the top of the doc.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.92077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "URL <em>format</em>",
        "body": " a title or a redirect, create a GitHub issue or, if you&#x27;re a New Relic employee, contact the Docs hero via the #documentation Slack channel. URL format A document&#x27;s URL is based solely on its filename and filepath in the GitHub repo. For <em>more</em> information, see Doc URL. Change titles To change"
      },
      "id": "604220ec196a670d0ba83dd4"
    },
    {
      "sections": [
        "Define custom metrics for an alert condition",
        "Requirements for custom metrics",
        "Create a custom metric condition",
        "Tip",
        "View or update custom metric conditions",
        "Custom metric examples for alert notifications"
      ],
      "title": "Define custom metrics for an alert condition",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "482f099e7b03c251b5165f3e647959db37788650",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/define-custom-metrics-alert-condition/",
      "published_at": "2021-09-02T12:05:08Z",
      "updated_at": "2021-08-26T05:35:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To alert on custom metrics, follow standard procedures to add a condition to a policy. The condition's Thresholds section includes the option to select Custom > Search metric name, where you define your specific metric values. You can start typing the custom metric name or select from the list that automatically appears. Requirements for custom metrics Use the policy's Thresholds section to define the custom metric values. These include: The exact custom metric name for the selected product category and targets. Note: wildcard characters are not allowed. Selected threshold value function. The options are average, minimum, maximum, count, and rate. Selected threshold level. The options are above, below, and equal to. Critical (required) and Warning (optional) threshold value and duration that will open a violation. For example, 5 units for at least 5 minutes. Condition name (required) for the custom metric. Create a custom metric condition To define the custom metric values for your condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy) or add a new alert policy. From the policy's Alert conditions page, click Add a condition. From the Categorize section, select the product and type of condition for the custom metric. From the Select entities section, add one or more targets (entities) that use your custom metric. From the Define thresholds > When target application section, select Custom > Search metric name, and begin typing the custom metric name, select from the list, or type the exact metric name. Tip Exception: The custom metric search is not enabled for: Labels for New Relic APM apps New Relic Plugins To find the metric name in these situations, use the Data explorer. Then type the exact metric name in the Alerts Define thresholds page. Provide the required threshold values for your custom metric. From the Define thresholds > Condition name section, provide a meaningful name for your custom metric condition, maximum 100 characters. Optional: Include the URL with runbook instructions for handling the situation. Click Create condition. Repeat these steps as necessary to create additional conditions for custom metrics. View or update custom metric conditions After you save the condition, you can view the selected policy's Alert conditions page with a list of each condition. From here you can follow standard procedures to select and update the custom metric condition. The Condition name does not appear in the Thresholds section for a saved condition. If you want to change the condition name for a custom metric, edit it from the selected policy's Alert conditions page: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click a condition name to edit it, and then type a meaningful name for the condition. Custom metric examples for alert notifications If you have created a plugin or custom dashboard for your custom metric, you can view your custom metric name there. For other ideas about how to apply custom metrics (for example, to alert on received and transmitted network stats), visit the New Relic Explorers Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.02636,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Define custom metrics <em>for</em> an alert condition",
        "sections": "Define custom metrics <em>for</em> an alert condition",
        "body": ". From the Categorize <em>section</em>, select the product and type of condition for the custom metric. From the Select entities <em>section</em>, add one or <em>more</em> targets (entities) that use your custom metric. From the Define thresholds &gt; When target application <em>section</em>, select Custom &gt; Search metric name, and begin"
      },
      "id": "6130bdf428ccbceda556a826"
    }
  ],
  "/docs/style-guide/writing-guidelines/pricing-language-guidelines": [
    {
      "sections": [
        "New Relic One pricing and billing",
        "Important",
        "How the New Relic One pricing plan works",
        "Billing and usage in the UI",
        "Billing calculation details",
        "Data usage calculation",
        "Incident Intelligence events",
        "Determine event source",
        "Stop reporting events",
        "Full user count billing details",
        "Data retention",
        "Billing periods",
        "Usage plan details",
        "Query and alert on usage data",
        "Free tier",
        "Non-profit use of New Relic",
        "Cancel or downgrade"
      ],
      "title": "New Relic One pricing and billing ",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One pricing and billing"
      ],
      "external_id": "03d43f14ae24579c81b601571242aef540833c8c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-billing/new-relic-one-pricing-billing/",
      "published_at": "2021-09-01T21:58:46Z",
      "updated_at": "2021-09-01T21:58:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "An explanation of how New Relic One pricing works, and how to view and manage billing. Important This document explains the New Relic One pricing plan. If you’re on our original pricing plan, see Original pricing. Not sure which you're on? See Overview of pricing. How the New Relic One pricing plan works Starting July 30, 2020, all of our new customers are on a pricing plan that we call New Relic One pricing. Customers on our original pricing plan are able to transition to this pricing. For New Relic One pricing, billing is based on these factors: The amount of data ingested. 100 GBs per month is free. $0.25 per GB ingested above that. The number of provisioned full users, defined as users with access to Full Stack Observability features. Basic users are free. The cost of each full user depends on your edition: Standard, Pro, or Enterprise. Standard edition includes one full user for free, and a max of five. Pro and Enterprise give access to more account and user management features, more support, longer data retention, and other features. For Applied Intelligence, our intelligent alert/detection system: the number of incident events above the free 1000 per month. (Note that our alerting functionality is available for free and doesn't count towards this limit.) For a summary of what's included for free, see Free edition. For an overview of pricing, see our Pricing page. Keep reading for details about New Relic One pricing and billing. Billing and usage in the UI For how to view and manage billing and usage in the UI, see Pricing and billing UI. If you need more detail than the usage UI shows, you can also run queries of your usage data and set up alerts. Billing calculation details For accounts on New Relic One pricing, some high-level billing information is displayed in the UI. Here are some more details about how billing works: Data usage calculation One pricing factor is your ingested data. In this context, “ingested” refers to the data actually saved to your account after we apply various data trimming and data transformation rules. In other words, it’s not the size of the raw data sent to New Relic, but the size of the data that actually ends up stored. To view and manage your usage, go to the usage UI. Other calculation details: In the context of our pricing plan, a GB is defined as 1 billion bytes. Monthly data ingested is rounded down to the nearest integer. For example, if your account uses 100.9 GBs during a month, that’s counted as 100 GBs. For more on how data is ingested, see Manage data ingest. For how to query usage, see Query and alert on usage. Incident Intelligence events One billing factor is how many incident events your organization sends to Incident Intelligence for correlation and analysis. If your organization is on New Relic One pricing, Incident Intelligence comes with a certain number of free incident events per month. (Our original pricing plan doesn't have a free tier.) You can track usage and cost in two places in the UI: In the usage UI From the Incident Intelligence system settings UI page: From one.newrelic.com, click Alerts & AI, then click Incident Intelligence, and then click System settings. Determine event source When you set up Incident Intelligence data sources, the incident events ingested by those sources are what count towards your total. To see the sources affecting your billing, go to the Sources page: From one.newrelic.com, click Alerts & AI, click Incident Intelligence, and then click Sources. Stop reporting events Go to the Incident Intelligence Sources UI page and disconnect all the sources you don’t want. If all sources are removed, no data is sent to Incident Intelligence. Full user count billing details For accounts with New Relic One pricing, the monthly count of provisioned full users is one billing factor. To give an example: if you're on the Pro pricing edition and your organization has 100 full users during the month of January, you'd be billed for 100 full users for that month. A full user counts as a billable user the moment they're added to a New Relic organization (provisioned), whether or not that user has logged into or used New Relic yet. A user's user type is meant to be long-term setting determined by a user's expected New Relic duties and responsibilities. Because user type is a billing factor, we have restrictions around how often a full user can be downgraded to a basic user: a full user can downgrade to a basic user a maximum of two times in a rolling 12-month period. If a full user has been changed to a basic user two times in that 12-month period, that user won't be able to return to being a basic user until the start of the next 12-month period. To learn reasons for assigning one user type or another, see Tips on assigning user type. Here are more user-related billing details and caveats: You can see your full user count in the UI. We de-duplicate users based on email address. If there are multiple users in an organization that have the same email address, those user records count as a single user for billing purposes. The count of full users is prorated based on the start of a New Relic subscription, or based on when a user is created as a full user or converted to a full user. A New Relic user can have a maximum of either three concurrent active sessions, or three unique IP addresses in use at any given time. For organizations on our original account/user model that have a parent/child account structure, the count of billable users in the UI may differ from the users you can see. For more on this, see User count discrepancy. The Standard edition of the New Relic One pricing plan includes one free full user. For organizations on our original user model, because the organization-related settings aren't as robust as on our newer model, a user may be set as a basic user in one account and as a full user in another account. In such cases, the full user status takes precedence and that user is considered a full user. For how to query usage data, see Query and alert on usage. For more on user capabilities, see Users and roles. Data retention See Data retention. Billing periods For pay-as-you-go customers, billing occurs at the end of the month (UTC), and you can see this tracked in the UI. When you input your credit card and start to be charged, your end-of-month bill will take into account all activity (billable data usage and users) that occurred since the beginning of that month. For example: if you input your credit card in the middle of the month, and so far at that point your account has 200 GBs of usage for that month, that 200 GBs counts towards your end-of-month bill. For how to query user-related usage, see Query and alert on usage. Usage plan details There are two New Relic One pricing usage plans: Pay-as-you-go: This plan bills at the end of each month. There are no commitments and you can cancel at any time. For details, see Usage plans. Annual pool of funds: This plan applies to some customers who have subscribed for a year or more. For details, see Usage plans. For some frequently asked questions, see Pricing FAQs. Query and alert on usage data To create detailed queries of your usage, and get notifications when you are close to hitting certain usage levels, see Query usage data. Free tier If your organization is on New Relic One pricing and on the Standard pricing edition for Full Stack Observability, you can use New Relic free, forever, if you stay under the free allowed limits. Here's a summary of what Standard edition gets access to for free: A single account (Pro and Enterprise Full Stack Observability editions can have multiple accounts per organization). Up to 100 GBs of ingested data per month. One full user, and unlimited basic users. Access to alerts and Applied Intelligence (up to 1,000 Incident Intelligence events per month). To upgrade to Pro or Enterprise, or to learn more about pricing, see New Relic pricing. Non-profit use of New Relic If you’re a non-profit and want to use New Relic at special pricing, see our Non-profit eligibility docs. Cancel or downgrade See Downgrade account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.45615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic One <em>pricing</em> and <em>billing</em> ",
        "sections": "New Relic One <em>pricing</em> and <em>billing</em>",
        "tags": "New Relic One <em>pricing</em> and <em>billing</em>",
        "body": " of usage for that month, that 200 GBs counts towards your end-of-month <em>bill</em>. For how to query user-<em>related</em> usage, see Query and alert on usage. Usage plan details There are two New Relic One <em>pricing</em> usage plans: Pay-as-you-go: This plan bills at the end of each month. There are no commitments and you can"
      },
      "id": "6043f69a64441f7b26378eda"
    },
    {
      "sections": [
        "Query and alert on billing/usage data",
        "Available data types",
        "Query examples",
        "Data usage queries",
        "Daily data usage",
        "Daily usage by source",
        "Metrics ingest by source",
        "Month-to-date data usage",
        "Month-to-date estimated data cost",
        "User count queries",
        "Month-to-date full users",
        "Projected monthly full user count",
        "Count full users and basic users",
        "Set usage alerts",
        "Caution",
        "Ingested gigabytes exceed a fixed value",
        "Usage exceeds fixed threshold for GBs",
        "Usage exceeds fixed threshold for users",
        "Usage exceeds fixed threshold for estimated cost",
        "Available attributes"
      ],
      "title": "Query and alert on billing/usage data",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One pricing and billing"
      ],
      "external_id": "a214c27cab73c790ac6ce947a0c189db9677d215",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-pricing-users/usage-queries-alerts/",
      "published_at": "2021-09-01T19:08:32Z",
      "updated_at": "2021-07-21T22:31:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For accounts on our New Relic One pricing plan, we provide a UI for understanding your New Relic usage and managing your data. Additionally, you can: Query your usage data to get more detail than is available in the UI Set up NRQL alert conditions to get notifications about changes in your usage. Note that account hierarchy may affect queried data. See Account structure. Available data types Usage data is attached to these events: NrConsumption records usage every hour, and is the equivalent of \"real-time\" usage. Use this event to observe usage trends over time. NrMTDConsumption generates aggregate values from the NrConsumption event. Use this event to see usage or estimated cost for a billing period. NrUsage records usage every hour and is used to see usage reported per product. To see changes made to your account (for example, user management changes), you can query NrAuditEvent. Query examples The usage UI displays your data usage and billable user count. But to get more detail, you can use these NRQL queries. For definitions of some of the attributes used in these queries, see Attributes. Data usage queries Here are some data usage query examples: Daily data usage This query totals your billable ingested data, and displays a daily value for the past three months: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago TIMESERIES 1 day Copy Daily usage by source This query totals your billable ingested data, and displays a daily value for the past three months faceted by the source: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE 3 months ago FACET usageMetric TIMESERIES 1 day Copy Metrics ingest by source This query breaks down Metric data by the top ten metric names. You could also facet by appName or host to adjust the analysis. FROM Metric SELECT bytecountestimate()/10e8 as 'GB Estimate' SINCE '2021-04-01' UNTIL '2021-04-08' FACET metricName LIMIT 10 TIMESERIES 1 day Copy Month-to-date data usage This query shows the current full user count. In other words, it shows how much you'd be billed for your data for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' SINCE this month Copy Month-to-date estimated data cost This query shows the estimated cost of your ingested data: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' SINCE this month Copy User count queries Here are some user-related query examples. For details on how users are counted, see User count calculations. Month-to-date full users This query shows the billable full users for the month. In other words, it shows how much you'd be billed for your users for that month if you were billed right now. FROM NrMTDConsumption SELECT latest(usersBillable) SINCE this month Copy This query shows how many full users were counted by hour. This is useful for seeing how the full user count changed over time. from NrConsumption SELECT max(FullUsers) SINCE 10 days ago TIMESERIES 1 hour Copy Projected monthly full user count This query shows a projected count of monthly users. This query would not be good for using in a dashboard; it requires values based on a) the days remaining in the month, b) the start of the month. Here's an example querying the projected end-of-month count with 10 days left in that month: FROM NrMTDConsumption SELECT predictLinear(FullUsers, 10 days) SINCE '2020-09-01' Copy Count full users and basic users The usage UI shows the count of full users and basic users. The query used is: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric Copy To see the count of full and basic users over time: FROM NrUsage SELECT max(usage) SINCE 10 days ago WHERE productLine='FullStackObservability' WHERE metric in ('FullUsers', 'BasicUsers') FACET metric TIMESERIES 1 hour Copy Set usage alerts To help manage your billable data, you can set alerts to notify you of unexpected increases in usage. Learn how to create alerts with NRQL queries here. Caution When creating alert conditions, you should set the Evaluation offset value to 60 minutes or your conditions may not trigger. Here are some NRQL alert condition examples. For attribute definitions, see Attributes. Ingested gigabytes exceed a fixed value This query will create an alert when your hourly usage exceeds a fixed value: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' Copy If you have multiple child accounts, you may want to set threshold alerts for a specific subaccount: FROM NrConsumption SELECT sum(GigabytesIngested) WHERE productLine = 'DataPlatform' AND consumingAccountId = YOUR_CHILD-ACCOUNT_ID Copy Usage exceeds fixed threshold for GBs This query will create an alert when your usage exceeds fixed monthly threshold for GBs: FROM NrMTDConsumption SELECT latest(GigabytesIngested) WHERE productLine = 'DataPlatform' Copy Usage exceeds fixed threshold for users This query will create an alert when your usage exceeds fixed monthly threshold for billable users: FROM NrMTDConsumption SELECT latest(usersBillable) Copy Usage exceeds fixed threshold for estimated cost This query will create an alert when your usage exceeds fixed threshold for estimated cost: FROM NrMTDConsumption SELECT latest(estimatedCost) WHERE productLine = 'DataPlatform' SINCE this month Copy Available attributes Below are some of the important attributes attached to usage events. Attribute Description productLine The category of usage. There are four options: DataPlatform, FullStackObservability, IncidentIntelligence, or ProactiveDetection. For more details about these categories, see New Relic platform. metric Consolidates multiple categories of usage into a single metric. Helpful when faceting by productLine. consumingAccountId ID of the New Relic account that is directly responsible for the stored events, as determined from the license key used. estimatedCost Calculates a cost estimate based on usage and metric cost. This is an estimate of costs to date, not your monthly invoice. For more attributes, see the data dictionary.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.284134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query and alert on <em>billing</em>&#x2F;usage data",
        "sections": "Query and alert on <em>billing</em>&#x2F;usage data",
        "tags": "New Relic One <em>pricing</em> and <em>billing</em>",
        "body": "For accounts on our New Relic One <em>pricing</em> plan, we provide a UI for understanding your New Relic usage and managing your data. Additionally, you can: Query your usage data to get more detail than is available in the UI Set up NRQL alert conditions to get notifications about changes in your usage"
      },
      "id": "6043f69ae7b9d2345b579a09"
    },
    {
      "sections": [
        "Synthetics subscription usage",
        "Important",
        "Data generation",
        "Usage calculations",
        "Tip",
        "General attributes",
        "Synthetics attributes",
        "Query examples",
        "Billable checks for the last month",
        "Account hierarchy"
      ],
      "title": "Synthetics subscription usage",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original pricing plan usage"
      ],
      "external_id": "e44875ddb623f28b20215dda9ffd226b535e1e52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/new-relic-account-usage/getting-started-usage/synthetics-subscription-usage/",
      "published_at": "2021-09-01T19:32:00Z",
      "updated_at": "2021-08-08T23:11:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This doc is for accounts on our original Product-based pricing. If you're on the newer pricing plan, see New Relic One pricing plan. Not sure which you're on? See Overview of pricing plans. For accounts on our original pricing plan, this document explains how we calculate billable usage for Synthetics accounts. This document also provides available subscription usage attributes and example NRQL queries to use in the New Relic UI or with API calls. Data generation A New Relic Synthetics subscription level is based on the number of non-ping monitor checks used during a calendar month. Once per day, every Synthetics monitor location will generate an NrDailyUsage event for every monitor type. This event will summarize Synthetics usage for that location and monitor type over the last 24 hours. All Synthetics usage events have a productLine attribute value of Synthetics. For more information, see the Synthetics query examples. Usage calculations A New Relic Synthetics subscription level is based on the number of non-ping monitor checks used during a calendar month. If your monitor checks are fairly steady over time, you can estimate the current month's eventual usage. Tip Only the account Owner and Admins can view the usage UI. However, anyone in your account can query usage data using the NrDailyUsage event. To view usage information in the UI: Go to the usage UI. On the Synthetics usage page, set the time picker to Last 30 days. Multiply the Avg daily paid checks by the number of days in the current month. The Synthetics usage chart displays the daily count of monitor checks. The table value Avg daily paid checks displays the total number of monitor checks for the selected time period, divided by the number of days. For more information about the usage UI, see Introduction to subscription usage data. General attributes The following are general (not Synthetics-specific) account-related attributes. These attributes can help you understand how your accounts are using New Relic products. Attribute Description consumingAccountId ID of the New Relic account that is directly responsible for the stored events, as determined from the license key used. consumingAccountName Name of the New Relic account that is directly responsible for the stored events, as determined from the license key used. masterAccountId The ID of the parent account that is either responsible for stored events or that is the parent of the consuming account. When a parent account is the consuming account, masterAccountId is the consumingAccountId. This attribute is present even for accounts that do not have a parent account. This is to ensure continued reporting if the account is later made a parent account. masterAccountName Name of the parent account that is either responsible for stored events, or that is the parent of the consuming account. When a parent account is the consuming account, masterAccountName is the consumingAccountName. This attribute is present even for accounts that do not have a parent account. This is to ensure continued reporting if the account is later made a parent account. partnershipId Partner ID of the New Relic customer partnership associated with the account responsible for the stored events. This attribute is only present if the consuming account is associated with a New Relic customer partnership. partnershipName Name of the New Relic customer partnership associated with the account responsible for the stored events. This attribute is only present if the consuming account is associated with a customer partnership. subAccountId ID of the child account that is responsible for the stored event. When this attribute is present, subAccountId is the consumingAccountId. This attribute is only present if the consuming account is a child account (not a parent account). subAccountName Name of the child account responsible for stored events. When present, this attribute is the same as the consumingAccountName. This attribute is only present if the consuming account is a child account (not a parent account). timestamp UNIX timestamp (seconds since epoch) of the day and time when event generation was initiated. Synthetics attributes The following are usage-related attributes generated by New Relic Synthetics. To query this data, use a productLine attribute value of Synthetics. Attribute Description productLine The New Relic product the usage data is from. Synthetics data will have the value Synthetics. Use this value when querying Synthetics usage data. syntheticsFailedCheckCount Number of failed checks that ran on the given day for the given Synthetics monitor and location. Failed checks count toward subscription usage for Synthetics. Only checks with syntheticsType not equal to SIMPLE count toward billable subscription usage. syntheticsSuccessCheckCount Number of successful checks that ran on the given day for the given Synthetics monitor and location. Only checks with syntheticsType not equal to SIMPLE count toward billable subscription usage. syntheticsLocation Location the check ran in. syntheticsLocationLabel Human-readable label for the location of the check. syntheticsType The type of Synthetics monitor. Possible values: SIMPLE, BROWSER, SCRIPT_BROWSER, SCRIPT_API. For more information, see Monitor types. syntheticsTypeLabel Human-readable label for syntheticsType. Possible values: Ping, Simple Browser, Scripted Browser, Scripted API. syntheticsMonitorName Name of the monitor. syntheticsMonitorId Unique ID of the monitor. usageType The type of entity for which this event records usage data. This value is Check for Synthetics. Query examples Here are some examples of NRQL queries you can use with your Synthetics subscription usage data. You can run NRQL queries, and use the resulting charts in dashboards. Billable checks for the last month This query produces a chart of the billable monitor checks over the last month. Remember that a syntheticsType of SIMPLE refers to a ping monitor, which doesn't count towards paid usage. FROM NrDailyUsage SELECT sum(syntheticsFailedCheckCount) + sum(syntheticsSuccessCheckCount) AS 'Paid checks' where productLine='Synthetics' AND syntheticsType != 'SIMPLE' SINCE last month UNTIL this month Copy Account hierarchy This is a non-product-specific query useful for seeing your account hierarchy (partnership, parent accounts, child accounts). SELECT count(*) FROM NrDailyUsage FACET partnershipName,masterAccountName,masterAccountId,consumingAccountName,consumingAccountId LIMIT 1000 SINCE 1 day ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.83191,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Billable</em> checks for the last month",
        "tags": "Original accounts and <em>billing</em>",
        "body": "Important This doc is for accounts on our original Product-based <em>pricing</em>. If you&#x27;re on the newer <em>pricing</em> plan, see New Relic One <em>pricing</em> plan. Not sure which you&#x27;re on? See Overview of <em>pricing</em> plans. For accounts on our original <em>pricing</em> plan, this document explains how we calculate billable usage"
      },
      "id": "603e87a6196a672f33a83dd7"
    }
  ],
  "/docs/style-guide/writing-guidelines/screenshots-images": [
    {
      "sections": [
        "Docs site edit checklist",
        "Title",
        "Introduction",
        "Headings (H2s)",
        "Text",
        "Procedures",
        "Structure"
      ],
      "title": "Docs site edit checklist",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "6dcea91eb875e69ab1786a4b5787615be7964bfe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/docs-site-edit-checklist/",
      "published_at": "2021-09-01T21:50:48Z",
      "updated_at": "2021-04-05T08:33:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you're creating a new doc, there's a lot to keep track of. You can use this checklist to make sure you've done everything. Title Check that: The doc's title effectively describes the contents. Procedural doc titles use active verbs; for example, Install not Installing. Introduction Check that: The introduction leads with an outcome and provides an overview of how to get there, so customers are confident they've found the right doc. It provides a short, readable overview of the doc's contents. Headings (H2s) Check that: Heading names are concise, yet provide information that helps readers to skim or skip to the section they want. Procedural H2s use active verbs, not the ing verb form. Text Check that the text: Optimizes for easier translation: Avoid idioms, slang, specific cultural references, etc. Tells a good story: Promotes the platform (other New Relic products, alerting, etc.). Includes examples and use cases, identifies personas, explains not only what it is or how to use it but why it matters. Includes hyperlinks in UI paths. Has no typos. Procedures Procedures use active voice and focus on steps (\"do this\"). Avoid burying tips or extra details in the steps. If the procedure includes prerequisites or background information, that information appears before (not buried inside) the ordered list of procedures. If a procedure or step branches, it splits the options so they are clearly visible as bullets, collapsers, etc. If the procedure says what not to do, it also describes what to do instead. Example: What not to do and what to do instead Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership, and monitor apps from that account. Structure The original tech writer or Docs site contributor is the best judge of whether the draft doc is complete. However, in your peer edit, make notes if you have unanswered questions that aren't addressed within the doc or its cross references. Doc structure Comments Complete Check that the overall doc: Is complete, but stays on topic. Includes useful cross references, hyperlinks, and other suggestions to enhance the information, especially for SEO. Skimmable Readers can see at a glance what the doc is about and what to do. It's obvious what parts they can read and what parts they can skip. Visually clean The doc avoids excessive use of callouts, long sentences, or long paragraphs. Useful images For screenshots and images, check that: Full size images always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped images clearly show their relevance, with or without captions. In addition, make sure that screenshots and images follow the Docs site's security guidelines, and that no private information related to customers or New Relic is displayed. Levels of detail The doc uses H2s, H3s, bullets, tables, and clamshells to organize complex levels of information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 660.2532,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Processes <em>and</em> procedures",
        "body": " sentences, or long paragraphs. Useful <em>images</em> For <em>screenshots</em> and <em>images</em>, check that: Full size <em>images</em> always have captions to explain their relevance. UI paths in captions always have hyperlinks. Cropped <em>images</em> clearly show their relevance, with or without captions. In addition, make sure"
      },
      "id": "604220b2196a6775f5a83dc0"
    },
    {
      "sections": [
        "Capitalization",
        "Use sentence case in headings",
        "Important",
        "Products and features",
        "UI elements and UI page paths",
        "Watermarks"
      ],
      "title": "Capitalization",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "7a4d6c67e7c4737414cc99d452577f79dfc79ffc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/capitalization/",
      "published_at": "2021-09-01T21:52:38Z",
      "updated_at": "2021-06-20T21:09:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In general, we only capitalize things when we need to. Over use of capitalization is distracting and limits accessibility for our readers with vision impairment. Read on for some guidelines on how to decide what to capitalize in a document's title, headings, products, features, and other elements of the page. Use sentence case in headings Use sentence case for headings. This includes category headings and document titles. With sentence case, capitalize only the first letter of: The first word Proper nouns Acronyms and abbreviations We have some exceptions: If the heading is a code term, such as a variable or function, then capitalize it exactly as it's used in the code; for example: noticeError. If the heading includes a colon, follow the Microsoft Style Guide for titles and headings, and capitalize the first word that appears after the colon; for example: APM Error profiles: Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our Screenshots and images document for more information on our image guidelines. Products and features Item Example We use title case for products. Full Stack Observability We don't capitalize features (including features that used to be products). Use transaction traces to... not Use Transaction Traces to... Our infrastructure monitoring... not Our Infrastructure monitoring... UI elements and UI page paths Item Example We use sentence case and bold for UI elements, even if the UI element is in a different case in the UI. \"From the Transactions page, select Transaction traces and...\" We use sentence case and bold for each element in a path that references UI pages. Go to one.newrelic.com > APM > Transactions > Transaction traces > (select a trace) > Another thing. Watermarks Item Example We use all caps for BETA or NR ONLY. <div id=\"watermark\">NR ONLY</div> Copy Otherwise use sentence case. <div id=\"watermark\">Legacy</div> Copy Include break (br /) for longer watermarks. <div id=\"watermark\">Limited <br /> release</div> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 593.8317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Products <em>and</em> features",
        "body": ": Troubleshoot trends. Important Use sentence case for graphical illustrations such as diagrams and figures. Explore our <em>Screenshots</em> and <em>images</em> document for more information on our image guidelines. Products and features Item Example We use title case for products. Full Stack Observability We don&#x27;t capitalize"
      },
      "id": "60421e50196a67d785a83d97"
    },
    {
      "sections": [
        "Update your Nerdpack's catalog information",
        "Update your CLI",
        "Check your permissions",
        "Publish your Nerdpack",
        "Update your Nerdpack's catalog metadata",
        "Update your Nerdpack's icons",
        "Resolve issues with submitting catalog information",
        "Resize your images",
        "Check the length of your strings"
      ],
      "title": "Update your Nerdpack's catalog information",
      "type": "developer",
      "tags": [
        "nerdpack",
        "catalog"
      ],
      "external_id": "dfee75ddee87a216eb9454abcaeabcc1ee0a8c7d",
      "image": "https://developer.newrelic.com/static/4560bce9c6a1165799e6eaf9d10f4868/0086b/nav-to-apps.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/catalog/",
      "published_at": "2021-09-05T01:44:00Z",
      "updated_at": "2021-05-21T01:48:59Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn to describe your Nerdpack in the catalog",
      "body": "Add screenshots, descriptions, and other metadata to your Nerdpack, and upload it all to the New Relic One catalog. Update your CLI Before you run any commands, ensure that you have the latest version of the CLI: bash Copy $ nr1 update Check your permissions To publish your Nerdpack and update its catalog information, you need: Access to the account that published it The necessary permissions for managing Nerdpacks Publish your Nerdpack You need to publish Nerdpacks that you create before you can update their catalog information. Update your Nerdpack's catalog metadata After you've published your Nerdpack to the New Relic One catalog, update the Nerdpack's metadata to let users know all about your Nerdlets or visualizations. Step 1 of 9 Go to New Relic: Step 2 of 9 Navigate to Apps: Step 3 of 9 Find your published Nerdpack under New Relic One catalog: Notice that there is no information on the Apps or details page other than the Nerdpack's name and the brief description found in nr1.json: There are no screenshots, icons, details, or what's new features. To add these, your Nerdpack needs a catalog directory. Step 4 of 9 From the root of your Nerdpack, create a catalog directory to house your Nerdpack's screenshots and metadata: bash Copy $ nr1 create --type catalog ✔ Component created successfully! catalog is available at \"./catalog\" Inside your catalog directory, you'll find specific files and directories for portraying information about your Nerdpack to your users: bash Copy $ ls catalog README.md additionalInfo.md config.json documentation.md screenshots File Description README.md A markdown file that instructs you how to use the information and metadata in catalog config.json A JSON file that contains the following fields: tagline: A brief headline for the application. This cannot exceed 30 characters. repository: The URL for the Nerdpack's remote repository. This cannot exceed 1000 characters. details: The purpose of the Nerdpack and how to use it. This cannot exceed 1000 characters. Use newlines for formatting, and don't include any markdown or HTML. support: An object that contains: issues: A URL for the repository's issues list. For example, the Issues tab if using GitHub. email: A valid email address for the team supporting the application community: A URL for a support thread, forum, or website for troubleshooting and usage support whatsNew: A bulleted list of changes in the current release version. This cannot exceed 500 characters. Use newlines for formatting, and don't include markdown or HTML. Check out our Pageview Map application's config.json to see a real-life implementation. documentation.md A markdown file that tells users how to use the Nerdpack's Nerdlets or visualizations. This shows in the detail view's Documentation tab. additionalInfo.md An optional markdown file for any additional information about using your application screenshots A directory that contains screenshots of your Nerdlets or visualizations. This can contain no more than 6 images. All screenshots must meet the following criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide Step 5 of 9 Update your Nerdpack's documentation.md file: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"\", 3 \"details\": \"\", 4 \"repository\": \"\", 5 \"whatsNew\": \"\", 6 \"support\": { 7 \"email\": { 8 \"address\": \"\" 9 }, 10 \"issues\": { 11 \"url\": \"\" 12 }, 13 \"community\": { 14 \"url\": \"\" 15 } 16 } 17 } catalog/config.json Copy Step 6 of 9 Update your config.json file: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"Say hi!\", 3 \"details\": \"DemoApp says Hello to a user.\", 4 \"repository\": \"https://github.com/newrelic/developer-website\", 5 \"whatsNew\": \"feat: Initial commit\" 6 } catalog/config.json Copy Step 7 of 9 Include screenshots in your screenshots directory. Step 8 of 9 Submit the information to the New Relic One catalog: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for DemoApp 1.0.0 Step 9 of 9 Go to the catalog to see your changes: Click your Nerdpack to see the new details: Update your Nerdpack's icons Within a Nerdpack, you can set two types of icons: One for your entire Nerdpack, which represents your Nerdpack in the catalog One for each of your launchers, which represents your Nerdlets Replace these icons and publish your Nerdpack to see the changes. Step 1 of 7 Update the icon.png in the root of your Nerdpack. This icon is used in the catalog and the Nerdpack's detail page. Step 2 of 7 If you're building a Nerdpack with one or more launchers, update the icon.png in each of your launcher's subfolders. Step 3 of 7 Update your package.json version: { \"private\": true, \"name\": \"demo-app\", \"version\": \"1.0.1\", \"scripts\": { \"start\": \"nr1 nerdpack:serve\", \"test\": \"exit 0\" }, \"nr1\": { \"uuid\": \"f2dbc999-e9a3-49b9-933d-5a704c6750bd\" }, \"dependencies\": { \"prop-types\": \"^15.6.2\", \"react\": \"^16.6.3\", \"react-dom\": \"^16.6.3\" }, \"browserslist\": [\"last 2 versions\", \"not ie < 11\", \"not dead\"] } package.json Copy This allows you to publish a new version of your Nerdpack. Step 4 of 7 Publish your Nerdpack: bash Copy $ nr1 nerdpack:publish Step 5 of 7 Update your whatsNew string in catalog/config.json: documentation.md config.json 1 Enter your first and last name into the fields provided. When you're done, press **Submit** to see a personalized \"Hello!\" message. catalog/documentation.md Copy 1 { 2 \"tagline\": \"Say hi!\", 3 \"details\": \"DemoApp says Hello to a user.\", 4 \"repository\": \"https://github.com/newrelic/developer-website\", 5 \"whatsNew\": \"feat: Add new icons\" 6 } catalog/config.json Copy This will tell users what you added in the latest version of your Nerdpack. Step 6 of 7 Submit this new metadata to the catalog: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded ✔ Updated metadata for DemoApp 1.0.1 Step 7 of 7 Go to the catalog and subscribe to your Nerdpack to see your new icon: Resolve issues with submitting catalog information Sometimes, when you work with catalog metadata, you may run into issues. Consider some common solutions for resolving these issues. Publish your Nerdpack Remember that you can only submit catalog metadata for Nerdpacks that have already been published. If you try to submit information for a Nerdpack that hasn't been published, the CLI will try to help: bash Copy $ nr1 catalog:submit Uploading screenshots... › Error: 1 error while updating DemoApp 1.0.0 › › Invalid Version: Nerdpack version 1.0.0 not found. Have you run `nr1 nerdpack:publish` yet? › Code: UNKNOWN Resize your images Screenshots for the catalog must meet the criteria specified previously in this guide. If they don't, the CLI will try to help: bash Copy $ nr1 catalog:submit Uploading screenshots... › Error: 2 errors while updating DemoApp 1.0.1 › › catalog/screenshots/screenshot.png › Invalid Screenshot: screenshot.png has a size ratio of 4:2. Update size ratio to 3:2. › › catalog/screenshots/screenshot.png › Invalid Screenshot: screenshot.png has a width of 3054px. Update size to be between 1600px and 2400px. › Code: UNKNOWN Check the length of your strings Most of the content in config.json has string-length requirements. Make sure you review those requirements and adhere to them when you update your config.json file. Otherwise, you'll see errors when you try to submit your configuration to the catalog: bash Copy $ nr1 catalog:submit Uploading screenshots... ✔ Screenshots uploaded › Error: 2 errors while updating DemoApp 1.0.1 › › catalog/config.json › Invalid Metadata: `details` has a character length of 2204. Must be no longer than 1000 characters › › catalog/config.json › Invalid Metadata: `tagline` has a character length of 266. Must be no longer than 30 characters › Code: UNKNOWN",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.60858,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Resize your <em>images</em>",
        "body": " <em>images</em> <em>Screenshots</em> for the catalog must meet the criteria specified previously in this guide. If they don&#x27;t, the CLI will try to help: bash Copy $ nr1 catalog:submit Uploading <em>screenshots</em>... › Error: 2 errors while updating DemoApp 1.0.1 › › catalog&#x2F;<em>screenshots</em>&#x2F;<em>screenshot</em>.png › Invalid <em>Screenshot</em>"
      },
      "id": "609c868664441f2bf22f3706"
    }
  ],
  "/docs/style-guide/writing-guidelines/user-related-language-guidelines": [
    {
      "sections": [
        "Bulk user actions (original user model)",
        "Important",
        "Update users in bulk",
        "Example CSV file",
        "Troubleshooting",
        "If you have a backup CSV file",
        "If no backup file exists"
      ],
      "title": "Bulk user actions (original user model)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original users and roles"
      ],
      "external_id": "ebfb52863fb5b57a14a2c298a2518c42f23c0908",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/roles-permissions/bulk-user-actions-add-delete-or-update-batches-users/",
      "published_at": "2021-09-01T19:07:14Z",
      "updated_at": "2021-08-09T00:33:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This doc explains how to manage users on our original user model. Not sure which model you're on? See Overview of user models. With the Bulk user actions feature, you can add, update, or delete multiple users at once. This can be helpful for: adding roles when multiple new employees start deleting roles when multiple employees leave giving multiple employees Admin roles Update users in bulk Some important rules and recommendations for making bulk user actions: You cannot make updates to your own role or an Owner role. You cannot edit an existing user's email address or name. You should avoid editing an existing user by deleting and re-adding them because this can have unintended consequences (for example, API keys associated with the original user will be lost). To add new user roles, update existing user roles, or delete user roles for users on the original user model: Go to: account dropdown > Account settings > Users and roles, and add /bulk_actions at the end of the URL. Example URL: https://account.newrelic.com/accounts/123456789/users/bulk_actions Copy Download a Backup CSV file. Downloading a backup file keeps a record of the users in your account prior to changes being made, and allows you to easily re-add any users that may be removed accidentally. Download a CSV of users or a CSV template. Each bulk action (add, update, or delete) will require its own CSV file. New Relic recommends saving your files with an account number, date, and the bulk action being performed. For example: account_123456789_delete_users_2018-06-29 Populate that sheet with only the users whose roles you'll be applying the chosen bulk action for. Remove users from the spreadsheet whose roles you do not want to change. Bulk action Fields Add Required fields: user email, name, type, base role Optional field: add-on role Update Required fields: user email (do not edit), name (do not edit), base role Optional field: add-on role Delete Required fields: only user email Example CSV file The following is an example downloaded CSV of users that lists four users on the New Relic account. In this example, we want to delete the user Alex Datanerd. All other users must be removed before uploading the CSV. Email Name Type Base role Add-on roles Last active User1 @Company.com Jane Datanerd full Owner 2/6/20 User2 @Company.com Jamie Datanerd full Admin 6/6/20 User3 @Company.com Alex Datanerd full User apm_admin, browser_admin 7/25/20 User4 @Company.com Pat Datanerd basic User alerts_admin, insights_admin, apm_admin 4/6/20 The other three users, whose roles will remain unchanged, are removed. The final CSV only shows Alex's name. This file would then be uploaded using the Delete users in CSV option in the UI. Email Name Type Base role Add-on roles Last active User3 @Company.com Alex Datanerd full User apm_admin, browser_admin In the UI, select a CSV action: Add, Update, or Delete the users listed within the CSV file. Upload the new CSV, and select Save changes. Troubleshooting If a user is removed or changed during your CSV file upload by mistake, you can add them back through another CSV file upload. Important Be aware that associated permissions may be lost when a user is deleted and re-added. For example, associated API keys will need to be re-added. If you have a backup CSV file If you have a backup CSV file saved: Open the backup CSV file. Populate the backup CSV file with the users whose roles will be modified. Select a CSV action for the new CSV file: add, update, or delete Upload the new CSV, and select Save changes. If no backup file exists If no backup CSV file has been previously downloaded: Download the CSV file template. Populate the spreadsheet with the information required for the user to be restored. Action Required fields Add User email, name, type, base role. Optional: Add-on role Update User email, name, type, base role. Optional: Add-on role Delete User email Select a CSV action for the new CSV file: Add, Update, or Delete. Upload the new CSV, and select Save changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.35771,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Bulk <em>user</em> actions (original <em>user</em> model)",
        "sections": "Bulk <em>user</em> actions (original <em>user</em> model)",
        "tags": "Original <em>users</em> and <em>roles</em>",
        "body": " deleting <em>roles</em> when multiple employees leave giving multiple employees Admin <em>roles</em> Update <em>users</em> in bulk Some important rules and recommendations for making bulk <em>user</em> actions: You cannot make updates to your own <em>role</em> or an Owner <em>role</em>. You cannot edit an existing <em>user</em>&#x27;s email address or name. You"
      },
      "id": "6043f605e7b9d264815799e1"
    },
    {
      "sections": [
        "How to manage users",
        "Important",
        "Requirements",
        "Manage users in the UI",
        "Overview of user management concepts",
        "Common user management tasks",
        "Add, edit, and delete users",
        "Give users access to accounts and roles (access grants)",
        "Create new custom groups and roles",
        "Set up SAML SSO and/or SCIM provisioning",
        "Grant users ability to manage other users",
        "Control how basic users upgrade to full users",
        "Track changes",
        "User management terms and definitions"
      ],
      "title": "How to manage users",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One user management"
      ],
      "external_id": "9e37836740ce56302734d4af636bdbe087b4dbc3",
      "image": "https://docs.newrelic.com/static/a78dad5ff794da5deaaf3b514e334ea7/c1b63/new-relic-one-user-mgmt.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/add-manage-users-groups-roles/",
      "published_at": "2021-09-01T19:52:34Z",
      "updated_at": "2021-08-26T19:11:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For users on our New Relic One user model, we provide various user management features, including the ability to: Use role based access control (RBAC) to assign default or custom roles to user groups Create custom user groups Grant user groups access to specific roles and accounts Important This doc applies to users on the New Relic One user model. For managing users on our original user model, see Original users. Not sure which user model you're on? See User models. Requirements To see if you can access these user management features, go to the user management UI and see what you have access to. Access requirements: These features allow managing of users on the New Relic One user model. To learn more, see User models. To avoid configuration conflicts, ensure that only one user is managing users at a time. Simultaneous configuration by more than one user may result in errors and unexpected results. Most capabilities require the Authentication domain manager role and some require the Organization manager role. For details, see Standard roles. Pricing edition requirements: To manage user groups, roles, and access grants: Pro or Enterprise edition is required. To import users from an identity provider: Enterprise is required. A New Relic user can have a maximum of either three concurrent active sessions, or three unique IP addresses in use at any given time. Manage users in the UI For users on the New Relic One user model, to find your user management options: From the account dropdown, select Administration. There are two user management UI pages there: User management: Use this to add users, update user information, and approve upgrade requests. Organization and access: Use this page to create and manage groups, roles, and access grants, and to set up SAML SSO and SCIM provisioning. Want to see videos of the user management UI in action? See our user management videos. Important If you can't see these UI pages, it may be because you're on our original user model or because you don't have the required user management role. Overview of user management concepts If your organization has Pro or Enterprise edition, you can create and configure access grants. An access grant gives a group of users access to a specific role on a specific account. Here's a diagram showing how access grants work and how they relate to the broader organization: A diagram explaining the concept of how access grants give a user group access to a) a role on b) a specific account. (Note that this applies to users on our New Relic One user model (and not our original user model).) When your New Relic organization is created, it starts out with some default access grants for our default User or Admin groups. Each of these groups is assigned one or more roles and granted access to the primary (first created) account: A view of the Organization and access UI, showing the default access grants associated with our default groups. If you have a relatively flat organizational structure, and are okay with all or many of your users having wide administrative access and access to all accounts, you'll probably only need at most a few access grants. For example, you might decide to add new access grants to the existing default Admin or User groups, giving those roles access to other accounts. Or, if you need more granular definition over roles and permissions, you'd create access grants that define new groups that have access to specific roles (either our standard roles or custom-defined roles). For a tutorial on how to create access grants and create custom roles, see the User management tutorial. For other examples of some common user management tasks, see Example tasks. To see the UI in action, see our user management videos. Some tips on setting up access grants: It may help to first plan out how your access grants will be organized. How many accounts will you have? What user groups will get access to which roles and which accounts? Will you use our default groups and roles or create your own custom groups and roles? If you've used automated user management to provision users via SCIM, you will have to create access grants to give those users access. A common configuration for organizations with many accounts (roughly 20 or more) is setting up groups with the more organization-scoped roles (Organization manager, Authentication domain manager, and Billing user) on the primary account, and then on other accounts, setting up groups with the more product-scoped roles (like All product admin, Standard user, or custom roles). Common user management tasks In the Organization and access UI, you can create access grants, custom groups, custom roles, and configure an authentication domain. Here are some example user management procedures: Add, edit, and delete users See the user management tutorial. Give users access to accounts and roles (access grants) See our user management tutorial. Create new custom groups and roles See the user management tutorial. Set up SAML SSO and/or SCIM provisioning See Get started with SAML SSO or SCIM. Grant users ability to manage other users To grant your users the ability to manage other users, you'll need to add users to a group that has the Authentication domain manager and Organization manager role. You have two options: From the User management UI, you can add a user to the default Admin group, which includes both of those roles. OR You can create a custom group and assign it these roles. For a tutorial on creating new access grants, groups, and roles, see the user management tutorial. Control how basic users upgrade to full users See the authentication domain settings. Track changes To see an audit log of changes to your account, including user management actions, you can query the NrAuditEvent. User management terms and definitions For an explanation of how user access to accounts and roles works, see User management concepts explained. Here are some definitions for the terms we use there: A New Relic organization is the representation of your organization, containing all your accounts, users, and data. For more information, see Organization and account structure. A capability is an ability to use or edit a specific, granular New Relic feature. Examples of capabilities: The ability to modify APM settings The ability to delete alert conditions A role is a set of capabilities. It is what gives a user their permissions. Our default standard roles have various capability sets, and you can create custom roles that have a custom set of capabilities. See some specific New Relic capabilities. A user group has one or more roles associated with it. You assign your users to a group. We have default user groups (Admin and User), and you can make your own groups. An access grant is what grants a user group access to roles and to specific New Relic accounts. An access grant essentially states, \"This group is assigned this role on this New Relic account.\" Adding a user to a group doesn’t do anything unless that group is included in an access grant. An authentication domain contains a set of users who are added to New Relic and who log in to New Relic in the same way. For example, you may have one authentication domain for users who log in via username/password and another authentication domain for users who log in via SAML. If a user is a basic user, this takes precedence over any role-related limitations. For more on this, see Basic user and roles.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.7992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to manage <em>users</em>",
        "sections": "Give <em>users</em> access to accounts and <em>roles</em> (access grants)",
        "tags": "New Relic One <em>user</em> management",
        "body": " have one authentication domain for <em>users</em> who log in via username&#x2F;password and another authentication domain for <em>users</em> who log in via SAML. If a <em>user</em> is a basic <em>user</em>, this takes precedence over any <em>role</em>-<em>related</em> limitations. For more on this, see Basic <em>user</em> and <em>roles</em>."
      },
      "id": "603e7bce28ccbc415beba74c"
    },
    {
      "image": "https://docs.newrelic.com/static/565d4ebddf52a4592c594032696516b9/c1b63/New-Relic-capabilities-UI-screenshot.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/new-relic-one-user-model-understand-user-structure/",
      "sections": [
        "Users, roles, permissions (New Relic One user model)",
        "Important",
        "Overview",
        "User type: basic and full",
        "Compare full vs basic capabilities",
        "Tips on choosing user type",
        "Understand user-related billing",
        "Have questions about why you can't access something?",
        "Default groups: Admin and User",
        "How do user type, roles, and groups relate to each other?",
        "Roles and capabilities",
        "Standard (default) roles",
        "Capabilities",
        "Manage users",
        "2020 user model changes"
      ],
      "published_at": "2021-09-01T19:19:33Z",
      "title": "Users, roles, permissions (New Relic One user model)",
      "updated_at": "2021-08-20T14:13:47Z",
      "type": "docs",
      "external_id": "169383c2678ce973404db07195b2dee6eda9163d",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic organization users can be on one of two account/user structures that we have: this doc explains the New Relic One user model. Important If your New Relic organization was created before July 30 2020 and you haven't gone through a user migration process, your users are likely on our original user model. For more on this, see Pricing and user model changes. Overview This doc will explain the structure of the New Relic One user model, including: User type (basic user vs full user) Default user groups User roles and capabilities For how to add and manage users in the UI, see User management. User type: basic and full Important This section is for users on our New Relic One user model. If you're on our original user model, see Original users. The user type (basic user or full user) determines whether a user has access to our Full Stack Observability features. A user's type is something you set long-term based on that user's expected New Relic responsibilities. Below are details on the two user types. Note that billing-related aspects only apply if you're on New Relic One pricing. Basic user. Details: These users are free and have access to a wide range of features, including running queries of data, making custom charts and dashboards, and setting up alerts. Unlike full users, they do not have access to our Full-Stack Observability features and some advanced Applied Intelligence features (for a comparison of abilities, see Capabilities). Basic users will see prompts for upgrading to a full user when they attempt to access unavailable features. For details, see Upgrade. Full user. Details: Full users have access to our Full-Stack Observability features, which include curated UI experiences like APM, infrastructure monitoring, browser monitoring, mobile monitoring, synthetic monitors, access to New Relic One apps, and more. For details, see Capabilities. Standard edition includes one free full user and up to five total full users. A full user can downgrade to a basic user twice in a 12-month period. To see and edit a user's user type, use the User management UI. Learn more about basic user versus full user differences: Compare full vs basic capabilities Below is a table comparing what basic users and full users can do. In short: basic users have access to our Telemetry Data Platform and some Applied Intelligence features, while full users have theoretical access to everything (dependent on any group-related restrictions). Another way to think about this is that full users are users with access to Full Stack Observability, which gates our more curated UI features. Features Full user Basic user Full-Stack Observability (Curated UI experiences) Application performance monitoring (APM) UI Infrastructure monitoring UI Digital Experience Monitoring UI, which includes: Browser monitoring UI Mobile monitoring UI Synthetic monitoring UI Synthetics checks Serverless monitoring UI Logs in context with other UI experiences Distributed tracing Infinite Tracing (Pro and Enterprise edition) Assorted UI experiences, including: Kubernetes cluster explorer UI Key transaction UI Workloads UI Access to New Relic One apps Can build apps but can't access other apps Applied Intelligence Automatic anomaly detection Correlated alerts and events Anomaly/alert analysis Root cause details in issues Telemetry Data Platform Data ingest from any source (our agents, integrations, and APIs) Query your data Create custom charts and dashboards Alerts and notifications Our APIs, including NerdGraph (GraphQL) (with some restrictions) Logs UI Build New Relic One apps (but cannot access other apps) Encryption at rest Standard data retention Security and compliance Data management Note that the pricing edition (Standard, Pro, or Enterprise) will also affect what features you have access to. For organizations with New Relic One pricing, learn more about how full users impact billing. Tips on choosing user type A user's type (basic user vs full user) is meant to be a long-term assignment, based on the New Relic responsibilities that user is expected to perform. A full user can be downgraded to a basic user only twice in one year. Below are tips for why you'd choose full user versus basic user. Reasons to make someone a full user: They play a key role in the development, testing, deployment, and maintenance phases of the application development lifecycle. They break/fix code regularly; they are responsible for triaging workflows, troubleshooting, or managing users and roles for their team. They have DevOps practices (i.e. version control systems and implement CI/CD). They need to use New Relic's curated dashboards and experiences (not just the ability to create their own custom queries and charts); in other words, they need full access to our platform. They need to be able to manage users and/or billing. Reasons to make someone a basic user: They play a key role in the planning phase of the application development lifecycle. They use and configure New Relic agents, APIs, and integrations to send us data, and access, configure, and use alerts on such data (not necessarily responsible for triaging workflows, troubleshooting, or managing users and roles for their team). They want to see high-level analytics and business metrics for future planning (such as C-Suite executives). They do not need to use our curated experiences and dashboards, but would benefit from the ability to create their own custom queries and charts of data; in other words, they don't need full access to the platform. They don't manage users. For accounts on New Relic One pricing, learn more about user-related billing calculations. Understand user-related billing If you're on the New Relic One pricing plan, full users are billable, and there are restrictions around how often a full user can downgrade to a basic user. For details, see User count billing details. For how to query and alert on usage data, see Query usage data. Have questions about why you can't access something? See Factors affecting access. Default groups: Admin and User For users on our New Relic One user model, a \"group\" is what allows the grouping together and managing of multiple users at the same time. Your New Relic users are assigned to a group, and that group is granted access to specific roles on specific accounts. We have two default groups: User: This group allows a user to use and configure monitoring/analysis features but not perform account-related tasks like managing billing or users. It has access to the All product admin role, which gives access to our observability platform tools but not to the organization and user management capabilities governed by the Organization manager and Authentication manager roles. Admin: has full access and capabilities, including the organization-level admin abilities. This is the equivalent of having the All product admin, the Billing user, the Organization manager and the Authentication domain manager roles. These groups are added inside your default authentication domain, which includes the default settings of users a) being managed via New Relic and b) logging in via standard email and password. If you add other authentication domains (for SAML SSO and/or SCIM provisioning of users), you'd have new custom groups in those new domains to govern those users. Note that groups, whether default or custom, are not what limit a user's capabilities: it is the role that is assigned to that group (with any basic user restrictions on top of that). If your organization is Pro or Enterprise edition and you want to understand how users are granted access to specific roles and accounts, see Access grants. To change the group a user is in, use the User management UI. How do user type, roles, and groups relate to each other? For users on the New Relic One user model, here's a table explaining how user type (basic vs full user), roles, and groups relate to each other: Full user Basic user Group Full users can be assigned to default groups (User and Admin) or custom groups. When basic users are added to a group, that group's role-related restrictions apply. A basic user's capabilities can be restricted in that way, but a basic user can never be granted more capabilities than they start with. For Standard edition, basic users can't be assigned to groups. For Pro and Enterprise edition, they can. Role For an explanation of the roles our default groups have, see Default groups. Custom groups can have either our default standard roles, or custom roles. A basic user's abilities aren't directly defined by a specific role. A basic user can best be described as having the All product admin role but without access to Full Stack Observability features (learn more about user type). When basic users are added to a group, that group's role-related restrictions apply, but a basic user can never be granted more capabilities than they start with. Roles and capabilities For users on the New Relic One user model, a \"role\" can be defined as \"a set of capabilities.\" A capability is defined as the ability to do a specific New Relic task, like 'Delete alert conditions' (learn more about capabilities). Roles are assigned to user groups. Our default groups Admin and User already have our standard roles (defined below) assigned. Organizations on Pro or Enterprise edition can also create custom roles. Standard (default) roles Roles are sets of capabilities. We have several \"standard roles,\" which are roles that satisfy some commonly needed use cases. To view roles and their associated capabilities, use the Organization and access UI. Important Note that some of our standard roles have hidden, non-exposed capabilities that are not available for selection when creating a custom role. The only standard roles that can be replicated with a custom role are Standard user and Read only; all others have some hidden capabilities. Our standard roles include: Standard roles Scope Description All product admin Account Provides admin-level access to observability platform features but not organization-level and user management features. In other words, this role includes all New Relic capabilities with the exception of managing users (Authentication domain manager role), managing organization/account-structure settings (Organization manager role), and managing billing (Billing user role). Note: the Standard user role is essentially the All product admin role minus observability feature configuration capabilities. Standard user Account Provides access to observability platform features, but lacks permissions for configuring those features (for example, ability to configure synthetic monitor secure credentials) and lacks organization-level and user management permissions. Note: the Standard user role is essentially the All product admin role without that role's ability to configure platform features. Billing user Account Provides ability to manage subscriptions and billing setup, and read-only access to the rest of the platform. For organizations with multiple accounts, billing is aggregated in the primary (first-created) account, which is why assigning this role to that primary account grants billing permissions for the entire organization. Organization manager Organization Provides the ability to manage organization settings, including organization structure, name, and preferences. Due to our recent switch to the New Relic One account/user model, this role currently has few abilities but more will be added over time. For how to grant this role, see Add user management capability. Organization read only Organization Provides the ability to view organization-level settings. For how to grant this role, see Add user management capability. Authentication domain manager Organization Provides ability to add and manage users, and configure authentication domains for users on the New Relic One user model. For how to grant this role, see Add user management capability. Authentication domain read only Organization Provides the ability to view users in your organization and view the configuration of authentication domains. For how to grant this role, see Add user management capability. Read only Account Provides read-only access to the New Relic platform (except for synthetic monitor secure credentials). Manage v1 users Account For New Relic organizations that existed before July 30 2020 and have users on our original user model, this role lets you manage those \"v1\" users. For more about how you'd assign roles to groups and create custom roles, see the user management tutorial. Capabilities A role, whether one of our standard roles or a custom role, is defined as a set of capabilities. To view roles and their associated capabilities, use the Organization and access UI. Important Some of our standard roles have hidden capabilities that aren't available for selection when creating a custom role. For details, see Standard roles. A view of the capabilities associated with the All product admin role. When creating a custom role, you select a custom set of capabilities. Note that the capabilities we expose may change over time: this screenshot was taken in April of 2021. For how to set up roles with custom capabilities, see the user management tutorial. Manage users To learn how to add users, assign them to groups, and create custom groups and roles, see Manage users. 2020 user model changes If you'd like to understand how our user model changed in 2020 and what the impacts of that change were, see User model changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.65976,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Users</em>, <em>roles</em>, permissions (New Relic One <em>user</em> model)",
        "sections": "How do <em>user</em> type, <em>roles</em>, and groups <em>relate</em> to each other?",
        "body": " access to specific <em>roles</em> on specific accounts. We have two default groups: <em>User</em>: This group allows a <em>user</em> to use and configure monitoring&#x2F;analysis features but not perform account-<em>related</em> tasks like managing billing or <em>users</em>. It has access to the All product admin <em>role</em>, which gives access to our"
      },
      "id": "603e88e328ccbcfcbaeba7a8"
    }
  ],
  "/docs/style-guide/writing-guidelines/voice-strategies-docs-sound-new-relic": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-09-05T01:38:27Z",
      "title": "Collect data",
      "updated_at": "2021-09-02T01:39:04Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source 15 min APIs, agents, OS emitters - get any data Add custom attributes   Use custom attributes for deeper analysis Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.78978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Through our opensource agents or APIs, <em>New</em> <em>Relic</em> makes it easy to collect data from any source. The guides in this section provide <em>strategies</em> for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Usage dictionary",
        "account ID",
        "agent",
        "am and pm",
        "Amazon Web Services (AWS) product names",
        "app name vs. app alias",
        "beta",
        "bits and bytes",
        "Tip",
        "blacklist and whitelist",
        "capitalization",
        "Child account",
        "click",
        "collector vs. connect to New Relic",
        "contractions",
        "customer vs. user",
        "dashboard",
        "doc, document, documentation",
        "dropdown",
        "e.g. and i.e.",
        "em dash (—)",
        "etc.",
        "hostname",
        "icons",
        "index",
        "infrastructure",
        "introduction",
        "macOS",
        "master account",
        "menu",
        "mouse over",
        ".NET",
        "New Relic One",
        "Node.js",
        "NR ONLY",
        "Oxford comma",
        "open source",
        "page",
        "parent account",
        "permissions",
        "pricing",
        "real user monitoring (RUM)",
        "record vs. report vs. collect",
        "RPM",
        "serial comma",
        "time zone",
        "UI",
        "UI paths",
        "update vs. upgrade",
        "users",
        "username, not user name",
        "version number references",
        "we",
        "you"
      ],
      "title": "Usage dictionary",
      "type": "docs",
      "tags": [
        "Basic style guide",
        "Style guide quick reference"
      ],
      "external_id": "eb1b15a359f1676c50bb9f0a1270f4659c435f63",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/quick-reference/usage-dictionary/",
      "published_at": "2021-09-01T21:56:16Z",
      "updated_at": "2021-09-01T21:56:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use this dictionary to guide your writing on docs.newrelic.com. We use this to help ensure consistency across our Docs site. Other than the terms listed here, we generally follow the Microsoft Style Guide, but we'll use Chicago Manual of Style in a pinch. We also follow American English conventions, rather than British English ones. For a glossary of terminology specific to New Relic, see the public glossary on the Docs site. account ID A unique number that identifies a particular New Relic account. Don't use account number. agent Don't capitalize. Install the Ruby agent, not Install the Ruby Agent. Don't refer to a Synthetics private minion as an agent. am and pm Use the 12-hour clock followed by the (lowercased) time period am or pm. Don’t put a space after the last number in a timestamp (12:00am, not 12:00 am). Don't include a leading 0 when the hour is less than 10. 9:30am, 12:30pm, 8:30pm Copy Amazon Web Services (AWS) product names Refer to the specific product, not just AWS broadly. As a courtesy to your readers, on first mention always refer to Amazon products by their full names; for example Amazon Web Services (AWS). You can use the acronym after that, if there is one. Example: Amazon Elastic Compute Cloud. After that, use the short name according to the AWS Documentation site. Example: Amazon EC2. app name vs. app alias The \"machine name\" that the collector uses to uniquely identify an app is its app name. The server-side configuration setting that changes the visible \"name\" of an app without changing its unique identifier is its app alias. beta When using as a watermark or in the doc's title, use all caps: <div id=\"watermark\">BETA</div> Copy Don't include a callout within the document unless the beta requires additional explanation. In the body text, use lowercase. For example: <Callout variant=\"important\"> This feature currently is in private beta. To join the beta, contact your New Relic account rep. </Callout> Copy If the developer team prefers to use a term other than beta or private beta, clarify what is driving that use of the term (Legal requirement?), and add any relevant info here in the usage dictionary. bits and bytes Use standard prefixes and capitalization for International System of Units (SI), International Organization for Standardization (ISO), or Joint Electron Device Engineering Council (JEDEC memory) values when referring to multiples of bits (b) and bytes (B). 1 byte = 8 bits. Decimal value SI prefix Binary value ISO prefix JEDEC prefix 1000 k: kilo 1024 Ki: kibi K: kilo 1000^2 M: mega 1024^2 Mi: mebi M: mega 1000^3 G: giga 1024^3 Gi: gibi G: giga 1000^4 T: tera 1024^4 Ti: tebi - -- 1000^5 P: peta 1024^5 Pi: pebi - -- Tip For help with converting byte values (such as bytes to kilobytes), try this byte converter. blacklist and whitelist Don't use. Instead, use deny list and allow list; for example, \"Add a hostname to your deny list.\" capitalization This is more complex than can be covered in this usage dictionary. For detailed information, see: Heading capitalization Capitalization of features and UI elements Child account A parent account contains one or more child accounts. Child accounts were previously referred to as \"sub-accounts\". click In general, use click rather than the vaguer select. For example, you might click something in the UI, but then select something from a list. Be particularly careful to use click to describe actions that only make sense with a mouse; for example, with a right click or a click and drag. Also use click when the user must click on a non-selectable object (to save your changes, click anywhere outside the dialog box). See also [mouse over] #mouse-over). collector vs. connect to New Relic When referring to an agent talking to the New Relic servers, describe this as the New Relic collector. Although internally the collector refers only to specific parts of our architecture, we use it more broadly in our documentation to mean \"any endpoint a customer must connect to report data, for any product.\" Avoid \"connect to New Relic,\" and do not use \"connect to the New Relic UI.\" contractions When it makes sense for clarity, conciseness, and tone and voice, use contractions. Use them where they make the writing sound more like natural speech, and where they improve clarity and accessibility without sacrificing expertise and authority. There are no hard and fast rules for which contractions are or aren't acceptable, but simple and common is preferable to complicated and rare. For example, it's for it is is fine, but less common constructions like mustn't or wouldn't've are best avoided. Also: When using a negative contraction (don't, can't, won't) try to provide some additional info about what what to do and what can be done. (See the style guide intro for more on this.) There are places in our docs—for example, in notes and warnings—where spelling out do not, cannot, or will not is preferable to contractions to emphasize the action or blockage to be avoided. customer vs. user When possible, use the second person you to form a sense of connection with the reader. For times when you need a descriptive third-person noun, keep the following guidelines in mind: customer and user are both appropriate depending on context. customer makes more sense when talking about billing, or about a group of people or a business entity. For example, one customer may have one or more individual users who interact with New Relic through the customer's account(s). user makes more sense as a general term for an individual user, or when talking about users as an object in the account model. For example, when discussing account models, it's important to be specific about what constitutes a single person identity in our system. dashboard Don't use. Instead, use page. doc, document, documentation Avoid referring to the document itself (the docs site page) as much as possible. If there's not a good alternative, you can use doc, document, or documentation (whatever sounds most natural; try reading it aloud). For example, This document explains how to... or For related docs, see... dropdown Use dropdown instead of drop-down or drop down. Although it isn't common usage, you can use dropdown independently as a noun, without needing to say dropdown menu or dropdown list. For example, select a date from the <b>date</b> dropdown. e.g. and i.e. Don't use Latin abbreviations. Instead of e.g., use for example or such as. Instead of i.e. or its English equivalent in other words, rewrite so your description is clear. em dash (—) Em dashes are rarely needed in tech docs, sadly. You can usually accomplish what you need to by breaking the thought into multiple sentences or using parentheses. In some rare cases, though, an em dash can add drama and spice. If you think you've found such a case, make sure you use them right. An em dash should always use the real em dash character (not a hyphen), and no space before and after. For example: You can sign up for New Relic fast and free—we won't even ask for a credit card number. Copy You can insert an em dash with the COMMAND+OPTION+- shortcut or use the HTML entity. etc. Unlike the Latin abbreviations e.g. or i.e.), you're welcome to use etc. Please ensure that you have several meaningful examples, though, before using. For example, cities including Portland, Seattle, Dublin, etc. but not cities including Portland, etc.. hostname This is one word. Don't hyphenate. icons When using an inline icon from the UI, always describe it first, then embed the icon image, and then end with the word icon. For example, select the delete icon. Don't put icons in bold. When writing about icons, describe the icon for its purpose or action, not what the icon looks like. For example: Yes: Select the edit icon. No: Select the pencil icon. For technical information on embedding images, see Inserting inline images and Embedding Font Awesome icons. index A list of entities, such as the APM applications index, the Synthetics Monitors index, or the Alerts Incidents index. See also page. infrastructure Don't use, unless referring to the New Relic Infrastructure product. Instead, use an appropriate substitute such as architecture, environment, system, host, etc. introduction Always use Introduction to for overview docs for a particular product. For example, Introduction to New Relic Infrastructure or Introduction to the PHP agent or Introduction to transaction traces. Don't use welcome to, basics, intro, overview, etc. Also avoid the Thing: Tagline format, as in X-Ray sessions: Traces and thread profiles for key transactions, unless having a title with keywords will help with SEO. macOS The proper name for Apple's desktop operating system is macOS. Don't use the older product names Mac OS X or OS X. master account We previously used \"master account\" and \"sub-account\" but now we use parent account and child account. menu The list of pages and indexes on the top and left sides of the New Relic user interface. mouse over For mouse movements that involve placing the mouse pointer over an area, but not clicking it. For example, the APM Overview page includes functions that are only visible when the mouse pointer is over a particular chart. Do not use point to or hover over. See also click. .NET Always refer to the agent and language as .NET, never as .Net or .net or dotnet. New Relic One New Relic One isn't a product. It's a way to view New Relic data more easily, all in one place, and from multiple related accounts. This has several implications for how we should refer to it: Avoid phrasing that makes New Relic One sound like a separate product or a separate platform. There is a single New Relic platform through which our users interact with our products. Avoid mentioning New Relic One where it can be avoided. For example, instead of saying \"Use New Relic One workloads to...\", you could instead say, \"In New Relic, you can use workloads to...\" and then in the doc explain where to find the feature. Another example: instead of referring to \"The programmable New Relic One platform,\" we might say, \"The New Relic platform is programmable: To start building, go to one.newrelic.com and...\" Do not use NR1 or nr1 as an abbreviation of New Relic One. The only reason to use nr1 is when referring to the nr1 package or library (for example: a reference to the command nr1 nerdpack:serve). In general, we want to avoid overloading our docs with \"New Relic\". For more details, see the New Relic One messaging guidelines, the docs glossary entry, or the New Relic One docs. Node.js Always refer to the programming language as Node.js, not Node. NR ONLY Use NR ONLY for watermarking docs for internal consumption only (such as this style guide). Don't use NR-ONLY or NRONLY or New Relic Only. Oxford comma See serial comma. open source Use lower case for open source. Some legal contracts may require upper case. page A specific place in the New Relic UI, located at a particular URL. Compare and contrast index, menu, and UI. Don't use dashboard, menu, tab, screen, or similar terms. parent account New Relic organizations can have a parent/child account structure. This is more important for our original account/user model but still plays a role for some behind-the-scenes features on our New Relic One account/user model. Learn more about account structure. Parent accounts were previously referred to as master accounts, and there are still some uses of this in the codebase. permissions See User-related language. For pricing tier/edition language, see Pricing language. pricing See Pricing language. real user monitoring (RUM) Don't use this outside of browser monitoring docs. Often abbreviated as RUM, this is a generic industry term for browser monitoring. New Relic refers to this as page load timing or browser monitoring. Use this term only for SEO or clarification, not to refer to the actual feature. record vs. report vs. collect Use report when discussing data sent to New Relic, such as, \"your host reports data to New Relic.\" Avoid using report as a noun. Instead use \"the reported metrics\" or \"the collected data.\" If \"report\" sounds too clunky, you can also use collect as long as whatever New Relic is collecting doesn't sound security sensitive. RPM Don't refer to the New Relic UI as RPM. Always refer to the specific product, such as the APM UI or the Browser UI. However, you may use rpm when required in the visible URL string in UI paths. serial comma Also referred to as an Oxford comma. Always use serial commas with inline lists. For example, Portland, Seattle, and Dublin rather than Portland, Seattle and Dublin. time zone Include a space (time zone). Don't hyphenate or run together as timezone. UI The graphical component of a New Relic product, encompassing all its pages, menus, and indexes. See also UI paths. UI paths If you need to tell a user how to path through the UI, see our style guide page on UI paths. update vs. upgrade Use update when users need to change the version of whatever they're using. No money or payment is needed for an update. Use upgrade whenever money or payment may be involved, such as upgrading to the Pro version of a product. The new pricing model makes it unlikely that you'll need to use this. users For styles and formats related to user roles and groups and more, see User-related style. username, not user name One word (username), not two. This is the most common usage and is recommended by Microsoft and Google style guides. version number references When referring to multiple version numbers, always use or higher. Don't use and higher, or the words greater or later. Also don't use punctuation, as in version 1.2+. For example: Foo requires Ruby agent version 1.2.3 or higher. Copy In addition: Tell users to use the latest version and not an up-to-date or current version. To abbreviate the word version, use a lowercase v with no space before the number; for example, v2 or v1.2.3. Use update not upgrade when talking about agent versions, as in \"To update to the latest version...\" For security reasons, do not use version numbers with licensing docs. The Tech Docs team doesn't have a set standard when referring to previous versions. Recommendation: Consider using version x.x or lower when identifying a specific version. Consider using In earlier agent versions when referring to versions more vaguely. we Say “we” and “our” when it works with the flow of your writing. Avoid overloading paragraphs with “New Relic” mentions, or reword so the focus is on the user, not New Relic. For example, avoid writing something like this: New Relic recommends setting a startup timeout. Copy Instead, write something like this: Recommendation: To help with troubleshooting, include a startup timeout in your configuration. Copy OR We recommend setting a startup timeout. Copy you We use “you” and “your” liberally in our docs. Addressing the reader directly makes for simpler, cleaner sentences. It also tends to expose lazy uses of passive construction and it helps users to understand procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.0852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "collector vs. connect to <em>New</em> <em>Relic</em>",
        "body": " phrasing that makes <em>New</em> <em>Relic</em> One <em>sound</em> <em>like</em> a separate product or a separate platform. There is a single <em>New</em> <em>Relic</em> platform through which our users interact with our products. Avoid mentioning <em>New</em> <em>Relic</em> One where it can be avoided. For example, instead of saying &quot;Use <em>New</em> <em>Relic</em> One workloads"
      },
      "id": "60421ec1196a676986a83d87"
    },
    {
      "image": "https://developer.newrelic.com/static/developer-champions-c61b7fb3b08d228679edab34b2d15a0e.jpg",
      "url": "https://developer.newrelic.com/developer-champion/",
      "sections": [
        "New Relic Developer Champions",
        "What do Developer Champions do?",
        "Open-source contributions",
        "Content creation",
        "Community engagement",
        "Why should you join and how will we support?",
        "Developer Champions benefits:"
      ],
      "published_at": "2021-09-05T01:42:50Z",
      "title": "New Relic Developers",
      "updated_at": "2020-12-04T01:45:02Z",
      "type": "developer",
      "external_id": "2cef9996dadc081ed4331e85992a4af9defc87ff",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Champions are the voice of the developer community. As experts and innovators, they are given the resources to not only share the newest product innovations and updates but also to provide feedback of the community back to New Relic product and engineering teams. Champions solve big problems using New Relic as their toolkit and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion What do Developer Champions do? New Relic Champions demonstrate expertise in using New Relic products by solving large problems and positioning New Relic as a central force in their strategies. The New Relic Champions is a recognition and partnership program designed to acknowledge the developers that are driving innovation within their companies and making top contributions to the developer community.They also commit to making their work public by: Open-source contributions Serving as an open-source author or maintainer for an accepted public project related to New Relic One Content creation Authoring two pieces of content in the New Relic Explorers Hub / Dev website Community engagement Delivering and/or organizing two events focused on an observability platform theme in which New Relic plays a crucial role Nominate a Developer Champion Why should you join and how will we support? As a benefit of being a Developer Champion, New Relic provides unique access to our Developer Advocacy team and the resources of our product organization, as well as specialized recognition and rewards. Developer Champions benefits: Formal, specialized access to the New Relic Product organization Champions have direct access to the New Relic’s Developer Ecosystem team Custom badge to wear with pride at events Public recognition on the New Relic Developer website and badging in the New Relic Explorers Hub as a Champion Exclusive Champion-only swag Early access program for some of our products (under NDA) Priority access to off-site FutureHack events (including when Lew is participating) Increased Explorer’s Hub support SLA Access to private Developer Champion Explorer’s Hub group",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.86476,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> Developer Champions",
        "body": "<em>New</em> <em>Relic</em> Champions are the <em>voice</em> of the developer community. As experts and innovators, they are given the resources to not only share the newest product innovations and updates but also to provide feedback of the community back to <em>New</em> <em>Relic</em> product and engineering teams. Champions solve big"
      },
      "id": "5efa993c64441fc2a25f7e65"
    }
  ],
  "/docs/synthetics/index": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.56441,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetics</em>",
        "body": " real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; Create monitor. Specify a monitor type, name"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.755676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> monitoring: Summary page",
        "sections": "<em>Synthetic</em> monitoring: Summary page",
        "tags": "<em>Synthetics</em>",
        "body": " the Summary page To access your monitor&#x27;s Summary page: Go to one.newrelic.com &gt; Explorer &gt; Synthetic monitors &gt; (select a monitor). You can also access it from one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a monitor). The Summary page gives you a high-level view of your website&#x27;s performance, and has shortcuts"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.75483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> monitors",
        "sections": "Index of <em>synthetic</em> monitors",
        "tags": "<em>Synthetics</em>",
        "body": " that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com &gt; <em>Synthetics</em>. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer"
      },
      "id": "60455a8464441f3f23378ebd"
    }
  ],
  "/docs/synthetics/new-relic-synthetics/pages/synthetics-results-access-individual-monitor-runs": [
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.34174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary <em>page</em>. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.33884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary <em>page</em> and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.6135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> monitors are API checks or virtual browser instances that <em>monitor</em> your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each <em>page</em> resource, and downtime incidents. <em>Synthetic</em>"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1": [
    {
      "sections": [
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Caution",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Patch an existing monitor",
        "Delete an existing monitor",
        "Get a list of valid locations",
        "Script API for scripted browser and API test monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Using private location scripts with verified script execution",
        "Important",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Tip"
      ],
      "title": "Manage synthetic monitors via REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "83a3e8ad751c7f0865785a1c2fad193604a7f7da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api/",
      "published_at": "2021-09-02T04:44:36Z",
      "updated_at": "2021-07-09T14:46:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api Copy For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api Copy Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Copy Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 20. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' Copy The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Copy Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } Copy In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' Copy PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Copy Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload Copy If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' Copy Important You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. Tip In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.86656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "sections": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " will disable line wrapping: base64 -w 0 $scriptfile #!&#x2F;bin&#x2F;bash # <em>API</em> key from your account settings <em>API</em>_KEY=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>"
      },
      "id": "60440d4628ccbc74532c606a"
    },
    {
      "sections": [
        "Payload attributes for the Synthetics REST API",
        "Synthetic monitoring attributes",
        "Specific monitor endpoint",
        "For more help"
      ],
      "title": "Payload attributes for the Synthetics REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "ed3202f6715ae367d5c7c58d63a332d073535995",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api/",
      "published_at": "2021-09-02T03:18:04Z",
      "updated_at": "2021-03-11T11:46:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For REST API requirements for synthetics, see Use the API. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the Synthetics REST API: Synthetics API attribute Definition apiVersion String: The version number. count Integer: The number of monitors returned. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific synthetic monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. options Object: options for SIMPLE and BROWSER monitor types. Options include: validationString: string verifySSL: boolean (true, false) bypassHEADRequest: boolean (true, false) treatRedirectAsFailure: boolean (true, false) Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected synthetic monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/. For more help Additional documentation resources include: Manage synthetic monitors via the REST API (API procedures for synthetic simple and scripted monitors) Manage synthetic alert notifications via the REST API (REST API calls for email alerts for synthetic monitors) Use synthetics label APIs (REST API calls for labels and categories used by synthetic monitors)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.04572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "sections": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " The <em>monitor</em>_uuid is the value that follows &#x2F;monitors&#x2F;. For more help Additional documentation resources include: Manage synthetic monitors via the <em>REST</em> <em>API</em> (<em>API</em> procedures for synthetic simple and scripted monitors) Manage synthetic alert notifications via the <em>REST</em> <em>API</em> (<em>REST</em> <em>API</em> calls for email alerts for synthetic monitors) Use <em>synthetics</em> label <em>APIs</em> (<em>REST</em> <em>API</em> calls for labels and categories used by synthetic monitors)"
      },
      "id": "6043f9ae28ccbc98002c607a"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "APIs for data ingest",
        "NerdGraph (GraphQL)",
        "REST API",
        "APIs by feature",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-09-01T21:24:31Z",
      "updated_at": "2021-08-27T04:51:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Send data to New Relic. Retrieve data from New Relic. View and configure settings. This document provides examples and reference information for our APIs. APIs for data ingest Our four primary data ingest APIs are some of the many solutions for reporting data to New Relic. These APIs can be used directly, but they're also the underlying ingest route for many of our more curated tools, such as our open source telemetry integrations and our Telemetry SDKs. Data type Description Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Event API Send custom event data to New Relic without the use of an agent or integration. Log API Send your log data to New Relic. Trace API Send distributed tracing data to New Relic without the use of an agent or integration. NerdGraph (GraphQL) NerdGraph is the API we recommend for querying New Relic data, querying account information, and making a range of feature configurations. To learn what you can do, check out the NerdGraph tutorials. NerdGraph is our newest API and is our attempt to bring together in one place some of our older APIs, like our REST API. Note that there is still some functionality you can do with REST APIs that can't yet be done with NerdGraph, and this is why some New Relic organizations still use the REST API. REST API Our REST API is our older API for querying and configuration, which NerdGraph is in the process of replacing. The REST API has some configuration abilities that NerdGraph doesn't yet have, but when possible you should use NerdGraph. The REST API can be used for a wide range of features: for detail, see APIs by feature. APIs by feature New Relic tools and features, like APM, infrastructure monitoring, browser monitoring, and alerts, are often used together, and sometimes can overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To query New Relic data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To query New Relic data, use NerdGraph. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To query New Relic data, use NerdGraph. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage (original pricing plan) For organizations on our original pricing plan, you can use NerdGraph to query subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API If you're a New Relic partnership organization, you can use the Partner API to retrieve data and make configurations. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API Our Insights Query API is mostly deprecated. Instead, use NerdGraph for querying your New Relic data. Dashboard API Use the Dashboards API. Plugins New Relic Plugins have been deprecated. For details, see Plugins EOL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.790695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "<em>REST</em> <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": " alerts conditions for your mobile apps. Query <em>API</em> To query New Relic data, use NerdGraph. Account management <em>APIs</em> For account-related <em>APIs</em>, see Account <em>APIs</em>. Synthetic monitoring <em>Synthetics</em> <em>API</em> resources include: Resource Details <em>Synthetics</em> <em>REST</em> <em>API</em> The <em>Synthetics</em> <em>REST</em> <em>API</em> functionality includes: Create"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring": [
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-09-02T16:50:54Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.3298,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-09-02T16:49:47Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.45146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/identify-synthetic-monitoring-requests-your-app": [
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-09-02T16:50:54Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.99599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32971,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-09-02T16:48:44Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.67477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips": [
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-09-02T16:50:54Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.99599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32971,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-09-02T16:48:44Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.67477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/synthetic-monitoring-audit-log-track-changes-made-users": [
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-09-02T16:50:54Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.99599,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32971,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-09-02T16:48:44Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.67477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-09-02T16:48:44Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.67477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    },
    {
      "sections": [
        "Upcoming synthetic monitor public minion IP addresses",
        "US public minions: Upcoming IP addresses",
        "EU public minions: Upcoming IP addresses"
      ],
      "title": "Upcoming synthetic monitor public minion IP addresses",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "81c0e0d3f87a627ad01f220f215f7b848f54608d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/new-synthetic-public-minion-ips/",
      "published_at": "2021-09-02T16:49:47Z",
      "updated_at": "2021-04-04T20:14:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On July 15 2021, we'll be adding new IP addresses for several synthetics locations for both US locations and EU locations. To ensure your monitors are not affected by these changes, please add the appropriate IP addresses to your firewalls allow list. For the current list of IP addresses and more about this topic, see Synthetic monitor public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 54.250.11.193 3.113.102.86 52.193.74.189 18.177.40.17 ec2-54-250-11-193.ap-northeast-1.compute.amazonaws.com ec2-3-113-102-86.ap-northeast-1.compute.amazonaws.com ec2-52-193-74-189.ap-northeast-1.compute.amazonaws.com ec2-18-177-40-17.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 3.34.173.249 52.79.48.153 ec2-3-34-173-249.ap-northeast-2.compute.amazonaws.com ec2-52-79-48-153.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 65.1.222.35 ec2-65-1-222-35.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 52.76.41.181 54.179.195.220 18.138.16.42 ec2-52-76-41-181.ap-southeast-1.compute.amazonaws.com ec2-54-179-195-220.ap-southeast-1.compute.amazonaws.com ec2-18-138-16-42.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 3.96.243.128 3.97.226.155 ec2-3-96-243-128.ca-central-1.compute.amazonaws.com ec2-3-97-226-155.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.94.27.80 18.229.241.206 ec2-54-94-27-80.sa-east-1.compute.amazonaws.com ec2-18-229-241-206.sa-east-1.compute.amazonaws.com AWS_US_WEST_2 \"Portland, OR, USA\" 44.236.111.66 54.203.108.135 ec2-44-236-111-66.us-west-2.compute.amazonaws.com ec2-54-203-108-135.us-west-2.compute.amazonaws.com EU public minions: Upcoming IP addresses The following table lists the upcoming IP addresses that will be added to public minions on July 15 2021 for EU customers. Public minion location Location label New IP addresses New DNS addresses AWS_AP_NORTHEAST_1 \"Tokyo, JP\" 35.72.129.240 35.73.187.89 ec2-35-72-129-240.ap-northeast-1.compute.amazonaws.com ec2-35-73-187-89.ap-northeast-1.compute.amazonaws.com AWS_AP_NORTHEAST_2 \"Seoul, KR\" 13.125.155.211 15.164.119.0 ec2-13-125-155-211.ap-northeast-2.compute.amazonaws.com ec2-15-164-119-0.ap-northeast-2.compute.amazonaws.com AWS_AP_SOUTH_1 \"Mumbai, IN\" 15.207.93.61 ec2-15-207-93-61.ap-south-1.compute.amazonaws.com AWS_AP_SOUTHEAST_1 \"Singapore, SG\" 3.0.28.216 ec2-3-0-28-216.ap-southeast-1.compute.amazonaws.com AWS_CA_CENTRAL_1 \"Montreal, Quebec, CA\" 99.79.17.185 ec2-99-79-17-185.ca-central-1.compute.amazonaws.com AWS_SA_EAST_1 \"São Paulo, BR\" 54.207.198.234 ec2-54-207-198-234.sa-east-1.compute.amazonaws.com",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.45146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "sections": "Upcoming <em>synthetic</em> <em>monitor</em> public minion IP addresses",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " about this topic, see <em>Synthetic</em> <em>monitor</em> public minion IPs. US public minions: Upcoming IP addresses The following table lists the IP addresses that will be added on July 15 2021 to public minions for US customers. Public minion location Location label New IP addresses New DNS addresses"
      },
      "id": "606a1e4364441fbec2617a7c"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/administration/user-roles-synthetic-monitoring": [
    {
      "sections": [
        "Synthetic monitor public minion IPs",
        "IP addresses are not personal data",
        "Daily JSON listings for IP addresses",
        "Important",
        "Tip",
        "Public minion locations and location labels"
      ],
      "title": "Synthetic monitor public minion IPs",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "773534b4f076c3b421b6e0ca0dfc26f1e1ef6f73",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-public-minion-ips/",
      "published_at": "2021-09-02T16:50:54Z",
      "updated_at": "2021-08-08T21:09:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic uses a group of minions to execute your synthetic monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses are publicly available in JSON format, so you can easily read and parse them. Recommendation: For easier maintenance, use these options: Automate your rules for your allow list based on these files. Add the IP addresses to your allow list by using a custom header. IP addresses are not personal data Minions are deployed on servers, and the agents are expected to be activated using non-personal credentials. IP addresses associated with minions running on servers are not personal data under data protection and privacy laws. For more information, see the Synthetic's security documentation. Daily JSON listings for IP addresses IP addresses for released locations are subject to change. If a change is needed, we'll attempt to proactively notify customers prior to any changes via e-mail. You can also check the Explorers Hub for updates. Important Synthetics is adding new IP addresses on July 15 2021. Tip In the S3 URL paths for this feature, production represents US-based accounts and eu represents EU-based accounts. US accounts IP-only list DNS name-only list IP and DNS name list EU accounts IP-only list DNS name-only list IP and DNS name list Public minion locations and location labels The following table cross-references the synthetic's public minion locations with their location labels. You can query the location and locationLabel attributes from the SyntheticCheck and SyntheticRequest events. Public minion location Location label AWS_AP_EAST_1 \"Hong Kong, HK\" AWS_AP_SOUTH_1 \"Mumbai, IN\" AWS_AP_SOUTHEAST_1 \"Singapore, SG\" AWS_AP_NORTHEAST_2 \"Seoul, KR\" AWS_AP_NORTHEAST_1 \"Tokyo, JP\" AWS_AP_SOUTHEAST_2 \"Sydney, AU\" AWS_US_WEST_1 \"San Francisco, CA, USA\" AWS_US_WEST_2 \"Portland, OR, USA\" AWS_US_EAST_2 \"Columbus, OH, USA\" AWS_US_EAST_1 \"Washington, DC, USA\" AWS_CA_CENTRAL_1 \"Montreal, Québec, CA\" AWS_SA_EAST_1 \"São Paulo, BR\" AWS_EU_WEST_1 \"Dublin, IE\" AWS_EU_WEST_2 \"London, England, UK\" AWS_EU_WEST_3 \"Paris, FR\" AWS_EU_CENTRAL_1 \"Frankfurt, DE\" AWS_EU_NORTH_1 \"Stockholm, SE\" AWS_EU_SOUTH_1 \"Milan, IT\" AWS_ME_SOUTH_1 \"Manama, BH\" AWS_AF_SOUTH_1 \"Cape Town, ZA\"",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.99597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "sections": "<em>Synthetic</em> <em>monitor</em> public minion IPs",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "New Relic uses a group of minions to execute your <em>synthetic</em> monitors. These minions are deployed in different data centers around the globe, and they are in charge of actually running your monitors. Because of this, ensure your firewall allows their network requests through it. Minion IP addresses"
      },
      "id": "6045257d28ccbcdc552c60a5"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Compare page load performance in browser and synthetic monitoring",
        "Compare performance and trends",
        "What you need",
        "Enable comparison data",
        "Enable comparative charting from Synthetics UI",
        "Enable comparative charting from browser monitoring UI",
        "View comparison data",
        "Hide or return comparison data",
        "Data sources"
      ],
      "title": "Compare page load performance in browser and synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "a789c407a0fecbd2ce888fdee7805abe8152f0a4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/compare-page-load-performance-browser-synthetic-monitoring/",
      "published_at": "2021-09-02T16:48:44Z",
      "updated_at": "2021-07-09T23:24:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring regularly checks your websites, critical business transactions, and API endpoints to measure optimal performance. Browser monitoring tracks the actual results of webpage performance across all variations of devices, browsers, and connection speeds. Used together, they provide a direct page load time comparison between real user (browser) interactions and the synthetic monitors. Compare performance and trends New Relic's comparative charting feature helps operations managers and teams by providing: Benchmarks for page load times Additional insights to help you plan where to optimize your site Comparisons of synthetic trends vs. actual browser performance without needing to switch between our monitoring capabilities. For example, during a page outage, you can compare synthetic monitoring trends to actual browser monitoring comparisons to see if an issue is also visible in Synthetics UI, or if it is caused by variables outside of New Relic. This helps you more efficiently know where to take action. What you need The comparative charting feature requires: Browser monitoring enabled with the browser SPA agent (version 885 or higher). A synthetic browser or scripted monitor with one or more tests on the same URLs monitored by the browser agent. After you enable the comparative charting feature either from synthetic or from browser monitoring, no additional setup is required. The comparative charting feature will appear when New Relic finds matching URLs. Enable comparison data After you enable the comparative charting feature from either synthetic or browser monitoring, no additional setup is required. The comparative charting feature will appear whenever synthetics or browser monitoring finds matching URLs. Enable comparative charting from Synthetics UI To enable the comparative charting feature from Synthetics UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. Above the selected monitor's Availability chart, select the ellipsis icon. Select Enable Synthetics comparison. Enable comparative charting from browser monitoring UI To enable the comparison data feature from browser monitoring: Go to one.newrelic.com > Browser > (select a browser app) > Page views. Select a page monitored by synthetic monitoring. From the selected page's Performance tab, select the ellipsis icon. Select Enable Synthetics comparison. View comparison data The comparative charting feature appears whenever synthetic monitoring identifies a URL match with browser monitoring and can compare it. You can compare browser and synthetic's performance either from the synthetic monitoring Summary page or from the browser monitoring Page views page (for browser apps or single page apps) without needing to switch between New Relic capabilities. Based on the selected data sources, the summary shows: Overall speed percentage comparison between browser (real user) page views and any matching URLs found in synthetic monitors that the user has permissions to view Number of URLs found in synthetic monitors that match the browser rollup URL To view the comparative charting summary: From synthetic monitoring UI: Go to one.newrelic.com > Synthetics > (select a monitor) > Summary. OR From browser monitoring UI: Go to one.newrelic.com > Browser > (select a browser app) > Page views, then select a page monitored by synthetic monitoring. Review the comparative charting feature's summary of overall speed percentage and number of matching URLs. To view additional details, select the summary's right arrow icon. Please note that in some cases the simple browser monitor ends before the browser agent has had a chance to collect the BrowserInteraction event. In this case, no comparative charting data is displayed in the UI. In order to resolve this issue, create a scripted browser monitor instead, and add a call to wait (sleep) after the page is loaded. Here is an example: $browser.get('https://www.mywebsite.com').then(function(){ return $browser.sleep(1000); }) Copy Hide or return comparison data To hide the comparative charting feature, select the ellipsis icon. To keep it visible but move it away from the top of the page, select Move to bottom. To return it to its original place on the page, select Move to top. To remove it from the page, select Hide all Synthetics/Browser comparisons. To return it to the page after removing it, follow standard procedures to enable comparison charting. Data sources New Relic uses these data sources for the synthetics and browser comparison in the UI. For deeper analysis of the comparative chart data you see in the UI, use the query builder to run NRQL queries. Variable Description Monitor account ID The account from which you are running the monitor: SELECT monitorAccountId FROM BrowserInteraction Copy Monitor ID The unique ID assigned to your synthetic monitor: SELECT monitorId FROM BrowserInteraction Copy Monitor job ID The ID of a single synthetics monitor run, which began at a specific time and originated from a specific location: SELECT monitorJobId FROM BrowserInteraction LIMIT 1 Copy Real user average The average page load time for real users viewing your website (excludes synthetic monitors). Real user page views Page view details coming from visitors to your website (exclude synthetic monitors). Synthetic's average The average page load time from the synthetic simple or scripted monitors that ran on your website. Synthetic's page views Only traffic generated by synthetic simple or scripted monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.67477,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "sections": "Compare page load performance in browser and <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " permissions to view Number of URLs found in <em>synthetic</em> monitors that match the browser rollup URL To view the comparative charting summary: From <em>synthetic</em> <em>monitoring</em> UI: Go to one.newrelic.com &gt; <em>Synthetics</em> &gt; (select a <em>monitor</em>) &gt; Summary. OR From browser <em>monitoring</em> UI: Go to one.newrelic.com &gt; Browser"
      },
      "id": "604525b7e7b9d251f85799e1"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Security for synthetic monitoring",
        "What we do",
        "What you can do"
      ],
      "title": "Security for synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "c36cbaf0bec47e56e54e66f7eb39484a3ef7f426",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring/",
      "published_at": "2021-09-02T16:52:02Z",
      "updated_at": "2021-07-27T18:44:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring uses monitors distributed throughout data centers around the world. By design, it captures what is essentially performance data for simulated traffic. It does not capture or handle any personal data by default. All data handled by synthetic monitors is expected to be non-personal. This document provides additional details about what we do to ensure data privacy and security with synthetic monitoring, plus additional options you can use. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. What we do Here's a summary of the data privacy and security measures that New Relic provides for you. Data privacy and security Comments No personal data By definition, all data collected through synthetic monitoring is test data created for the purpose of monitoring. None of this data includes personal data from any individual. TLS TLS encryption is required for all domains. This applies to public locations and private locations. Authentication Synthetic monitoring supports a variety of authentication mechanisms, including Basic, Digest, NTLM, and NTLMv2. Available options depend on the type of monitor you choose. Data collection The data transferred to the synthetic endpoint includes: Monitor run results, including full request and response headers of all requests, a complete HAR file of the session, and any screenshots captured (on failure or manually) Polling for available jobs in the private location's queue Private minion \"heartbeat\" every 30 seconds The SyntheticsPrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the synthetic monitoring endpoint contains the scheduled check's details. This includes the information necessary to complete the check for the minion: Target URL Validation text Full script (for synthetic scripted browser monitors) Data storage location Data collected by synthetic monitoring is stored in the region selected by each customer for their account (US or EU). Monitor configuration details (including frequency, check locations, target URL, and the full script for any scripted browser or API test monitors) are stored on our end. We also store all monitor check results for each monitor type. Data storage by monitor type For ping monitors, data storage includes the HAR file, which includes all requests and responses made during the check. For simple browsers, scripted browsers, and API tests, data storage includes the following: The HAR file includes full request and response headers for all requests made during the check. Any screenshots taken during the check are automatically included for simple and scripted browser monitors only on failure. However, you can manually configure this with scripting. The browser log (JS console) is automatically included for simple and scripted browsers. Any script output is included for scripted browsers and API test monitors. Response bodies New Relic never stores response bodies from requests originated by synthetic monitoring, unless you have manually configured a monitor script to do so. IP addresses Synthetic public minions are expected to be activated using non-personal credentials. Their IP addresses are not defined as personal data under data protection and privacy laws. What you can do For additional levels of security and data privacy, consider using these options. Additional measures Comments User access To control which of your users can access your monitors and private locations, set up role-based synthetic monitoring permissions and user groups. In addition, to track and be notified about changes, use audit logs and alert notifications. Passwords, API keys, user names, etc. To securely store sensitive information, use secured credentials for scripted browsers and API tests. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). Sites behind firewalls To control what sites you want to monitor behind your firewall, you can: Add the synthetic public minion IP addresses to your allow list or deny list. Use private locations to monitor sites or endpoints. This can provide an extra layer of security when monitoring your internally hosted sites and services. Web pages behind login pages If you configure synthetic monitoring to track website areas that are located behind a login page, be sure to create a non-personal login specifically for this purpose. This unique login will reduce the risk of unintended personal data exposure. Proxy configuration Aside from the target URLs monitored by New Relic, private minions will regularly send data to and receive from the synthetic monitoring endpoint. To configure a proxy for all traffic to and from this endpoint, set the MINION_API_PROXY environment variable on the minion host. Private minions security To ensure that only the scripts you intend to run are allowed to run on private minions, use verified script execution.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.29007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>synthetic</em> <em>monitoring</em>",
        "sections": "Security for <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for available jobs in the private location&#x27;s queue Private minion &quot;heartbeat&quot; every 30 seconds The <em>Synthetics</em>PrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the <em>synthetic</em> <em>monitoring</em> endpoint"
      },
      "id": "604525b8e7b9d270a35799c8"
    },
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-09-02T16:52:02Z",
      "updated_at": "2021-07-27T17:34:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Hover an element Navigate to a URL Secure a credential Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.88249,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>synthetic</em> <em>monitors</em>",
        "sections": "Types of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can proactively <em>monitor</em> your website or API endpoints with <em>synthetic</em> monitors. Depending on the type of <em>monitor</em>, you can: Add and edit monitors. Use the <em>Synthetics</em> REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host"
      },
      "id": "603e873864441f3e154e888f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Get started with synthetic monitoring",
        "Why it matters",
        "Advanced testing",
        "Enhanced monitoring and reporting",
        "Additional features",
        "Data protection and privacy",
        "Compatibility and requirements",
        "Important",
        "Permissions"
      ],
      "title": "Get started with synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "0e5bba5ee7c140314180bff96253dce241ced14f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/",
      "published_at": "2021-09-02T16:50:56Z",
      "updated_at": "2021-07-27T18:43:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. You can simulate user traffic to proactively detect and resolve outages and poor performance of critical endpoints before your customers notice. Why it matters With synthetic monitoring, you can: Get the context of failures by connecting the availability and performance of endpoints to the underlying applications and infrastructure. Easily diagnose if an issue stems from the network or AWS location, a slow third party resource, or the health of backend services or infrastructure. Add synthetic monitoring into build automation and CI/CD pipelines to automatically track performance and check functionality for each deployment. Expand your monitoring further with real, Selenium-powered scripted browsers, which test login procedures, searches, and other critical business transactions. Monitor your API endpoints with API tests Advanced testing Synthetic monitoring allows you to proactively monitor your website or API endpoint to ensure your content is not only available, but fully functional. Synthetic monitoring browser tests send real, Selenium-powered Google Chrome browsers to your site from locations around the world to ensure your content is always up, everywhere. Scripted browsers expand your testing capabilities, so you can test uncommon user flows or beta-test complex procedures. For example, ensure your users are able to sign up for your newsletter, add an item to their cart, or search for and find a piece of critical content with a simple JavaScript-like language. Test your backend with API monitors, which allow you to run scripted tests against any API endpoint. Enhanced monitoring and reporting Synthetic monitoring aggregates the results of each check into metrics, allowing you to see patterns and identify causes of poor performance. Synthetic monitoring also stores each and every monitor result, so you can see exactly where your website broke down. Alerts notify you if your website or API endpoint is inaccessible. You can even expand your geographical coverage or monitor internal websites by creating private locations. You can also query your monitor results for a closer look. New Relic retains monitor results for thirteen months, ensuring you can compare usage year over year. Additional features Synthetic monitoring includes the following features: Feature Description Real browsers With simple browser and scripted browser monitors, synthetic monitoring doesn't simply check that your host is up. It loads the actual page content in a real, fully virtualized Google Chrome browser (powered by Selenium) to provide testing that mirrors your users' actions. Detailed results view Synthetic monitoring stores every single run of your monitor for 13 months, so you can view a detailed breakdown of each and every check. You can get a snapshot of your website's performance and availability, or hunt down specific problems. Comparative charts with browser monitoring Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the synthetic monitors. For example, during a page outage, you can compare trends to see if an issue is also visible in synthetic monitoring, or if it is caused by other variables. Advanced scripted monitoring Use scripted browsers to run complex test cases against your website. Ensure critical processes like checkout and login are always running smoothly, and build a baseline to compare against when things go wrong. With a built-in scripting IDE based on Node.js, create scripts quickly without leaving your browser. Global test coverage Check coverage from locations around the world to ensure your users can access your website from anywhere, anytime. Monitor sites behind your firewall by adding the synthetic monitoring static IP addresses to your allow list. Use private locations to monitor internal sites or to expand your coverage to new locations. Compatibility with popular analytics platforms Synthetic monitoring specifically excludes scripts for popular analytics services, like Google Analytics. This ensures your analytics tools continue to receive the exact same data, even with thousands of monitors checking your website each month. You can unblock any of the services blocked by default, or block additional services. REST API functions Synthetic monitoring includes a REST API, which you can use to manage: Simple monitors and scripted monitors Categories and labels for monitors Alert notifications Data protection and privacy The data from synthetic monitoring is test data, representing typical interaction with the webpage or application. It is never actual data from human beings. The data collected when you use synthetic monitoring therefore is not personal data. For more information, see the Synthetic monitoring security documentation. Compatibility and requirements Synthetic monitoring does not require any software except a supported browser. Important To monitor a site behind your firewall, add the synthetic monitoring public minion IP addresses to your allow list. Permissions By default, all users in your account can: View synthetic monitoring pages. Add, edit, and delete monitors. For more fine-grained control, you can enable the optional permissions system. The permissions system allows you to manage the level of access for users to view and edit within synthetic monitoring (for example, monitors and private locations).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.73616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ") to provide testing that mirrors your users&#x27; actions. Detailed results view <em>Synthetic</em> <em>monitoring</em> stores every single run of your <em>monitor</em> for 13 months, so you can view a detailed breakdown of each and every check. You can <em>get</em> a snapshot of your website&#x27;s performance and availability, or hunt down specific"
      },
      "id": "6045257e64441fa637378efe"
    },
    {
      "sections": [
        "Types of synthetic monitors",
        "Types of monitors"
      ],
      "title": "Types of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "f7fe7faff740058c77bdf27b2c1bfb5c6a206b40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors/",
      "published_at": "2021-09-02T16:52:02Z",
      "updated_at": "2021-07-27T17:34:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can proactively monitor your website or API endpoints with synthetic monitors. Depending on the type of monitor, you can: Add and edit monitors. Use the Synthetics REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host not reporting feature in infrastructure monitoring. This allows you to take advantage of enhanced monitoring options and be notified when New Relic has stopped receiving data from your hosts. Types of monitors These are the seven types of synthetic monitors: Type of synthetic monitor Description Broken links monitor Provide a url and this monitor will test all the links on the page for success. If a failure is detected you can view the individual non-successful links that caused the failure. Certificate check monitor Proactively ping your domain certificates based on a configurable threshold. Pair with an alert to ensure you are notified when your certificates need renewed. Ping monitor API name: SIMPLE Ping monitors are the simplest type of monitor. They simply check to see if an application is online. The synthetic ping monitor uses a simple Java HTTP client to make requests to your site. For consistency with other synthetic monitor types, the user agent is identified as Google Chrome. However, the HTTP client is not a full browser, and it does not execute JavaScript. If you need JavaScript functionality, use a simple browser monitor. Step monitor API name: STEP_MONITOR Step monitors are advanced monitors which require no code to set up. The monitor can be configured to: Assert text Assert title Assert an element Click an element Dismiss a modal Double click an element Hover an element Navigate to a URL Secure a credential Select from a dropdown Type text Simple browser monitors API name: BROWSER Simple browser monitors essentially are simple, pre-built scripted browser monitors. They make a request to your site using an instance of Google Chrome. Compared to a simple ping monitor, this is a more accurate emulation of an actual customer visit. The user agent is identified as Google Chrome. Scripted browser monitors API name: SCRIPT_BROWSER Scripted browser monitors are used for more sophisticated, customized monitoring. You can create a custom script that navigates your website, takes specific actions, and ensures specific resources are present. The monitor uses Google Chrome browser. You can also use a variety of third-party modules to build your custom monitor. API tests API name: SCRIPT_API API tests are used to monitor your API endpoints. This can ensure that your app server works in addition to your website. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.88249,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Types of <em>synthetic</em> <em>monitors</em>",
        "sections": "Types of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can proactively <em>monitor</em> your website or API endpoints with <em>synthetic</em> monitors. Depending on the type of <em>monitor</em>, you can: Add and edit monitors. Use the <em>Synthetics</em> REST API to manage monitors. Set up monitors from specific locations or for private servers. You can also use the host"
      },
      "id": "603e873864441f3e154e888f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/getting-started/types-synthetic-monitors": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.32948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Get started with synthetic monitoring",
        "Why it matters",
        "Advanced testing",
        "Enhanced monitoring and reporting",
        "Additional features",
        "Data protection and privacy",
        "Compatibility and requirements",
        "Important",
        "Permissions"
      ],
      "title": "Get started with synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "0e5bba5ee7c140314180bff96253dce241ced14f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/",
      "published_at": "2021-09-02T16:50:56Z",
      "updated_at": "2021-07-27T18:43:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. You can simulate user traffic to proactively detect and resolve outages and poor performance of critical endpoints before your customers notice. Why it matters With synthetic monitoring, you can: Get the context of failures by connecting the availability and performance of endpoints to the underlying applications and infrastructure. Easily diagnose if an issue stems from the network or AWS location, a slow third party resource, or the health of backend services or infrastructure. Add synthetic monitoring into build automation and CI/CD pipelines to automatically track performance and check functionality for each deployment. Expand your monitoring further with real, Selenium-powered scripted browsers, which test login procedures, searches, and other critical business transactions. Monitor your API endpoints with API tests Advanced testing Synthetic monitoring allows you to proactively monitor your website or API endpoint to ensure your content is not only available, but fully functional. Synthetic monitoring browser tests send real, Selenium-powered Google Chrome browsers to your site from locations around the world to ensure your content is always up, everywhere. Scripted browsers expand your testing capabilities, so you can test uncommon user flows or beta-test complex procedures. For example, ensure your users are able to sign up for your newsletter, add an item to their cart, or search for and find a piece of critical content with a simple JavaScript-like language. Test your backend with API monitors, which allow you to run scripted tests against any API endpoint. Enhanced monitoring and reporting Synthetic monitoring aggregates the results of each check into metrics, allowing you to see patterns and identify causes of poor performance. Synthetic monitoring also stores each and every monitor result, so you can see exactly where your website broke down. Alerts notify you if your website or API endpoint is inaccessible. You can even expand your geographical coverage or monitor internal websites by creating private locations. You can also query your monitor results for a closer look. New Relic retains monitor results for thirteen months, ensuring you can compare usage year over year. Additional features Synthetic monitoring includes the following features: Feature Description Real browsers With simple browser and scripted browser monitors, synthetic monitoring doesn't simply check that your host is up. It loads the actual page content in a real, fully virtualized Google Chrome browser (powered by Selenium) to provide testing that mirrors your users' actions. Detailed results view Synthetic monitoring stores every single run of your monitor for 13 months, so you can view a detailed breakdown of each and every check. You can get a snapshot of your website's performance and availability, or hunt down specific problems. Comparative charts with browser monitoring Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the synthetic monitors. For example, during a page outage, you can compare trends to see if an issue is also visible in synthetic monitoring, or if it is caused by other variables. Advanced scripted monitoring Use scripted browsers to run complex test cases against your website. Ensure critical processes like checkout and login are always running smoothly, and build a baseline to compare against when things go wrong. With a built-in scripting IDE based on Node.js, create scripts quickly without leaving your browser. Global test coverage Check coverage from locations around the world to ensure your users can access your website from anywhere, anytime. Monitor sites behind your firewall by adding the synthetic monitoring static IP addresses to your allow list. Use private locations to monitor internal sites or to expand your coverage to new locations. Compatibility with popular analytics platforms Synthetic monitoring specifically excludes scripts for popular analytics services, like Google Analytics. This ensures your analytics tools continue to receive the exact same data, even with thousands of monitors checking your website each month. You can unblock any of the services blocked by default, or block additional services. REST API functions Synthetic monitoring includes a REST API, which you can use to manage: Simple monitors and scripted monitors Categories and labels for monitors Alert notifications Data protection and privacy The data from synthetic monitoring is test data, representing typical interaction with the webpage or application. It is never actual data from human beings. The data collected when you use synthetic monitoring therefore is not personal data. For more information, see the Synthetic monitoring security documentation. Compatibility and requirements Synthetic monitoring does not require any software except a supported browser. Important To monitor a site behind your firewall, add the synthetic monitoring public minion IP addresses to your allow list. Permissions By default, all users in your account can: View synthetic monitoring pages. Add, edit, and delete monitors. For more fine-grained control, you can enable the optional permissions system. The permissions system allows you to manage the level of access for users to view and edit within synthetic monitoring (for example, monitors and private locations).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.73616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ") to provide testing that mirrors your users&#x27; actions. Detailed results view <em>Synthetic</em> <em>monitoring</em> stores every single run of your <em>monitor</em> for 13 months, so you can view a detailed breakdown of each and every check. You can <em>get</em> a snapshot of your website&#x27;s performance and availability, or hunt down specific"
      },
      "id": "6045257e64441fa637378efe"
    },
    {
      "sections": [
        "Security for synthetic monitoring",
        "What we do",
        "What you can do"
      ],
      "title": "Security for synthetic monitoring",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Getting started"
      ],
      "external_id": "c36cbaf0bec47e56e54e66f7eb39484a3ef7f426",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/getting-started/security-synthetic-monitoring/",
      "published_at": "2021-09-02T16:52:02Z",
      "updated_at": "2021-07-27T18:44:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's synthetic monitoring uses monitors distributed throughout data centers around the world. By design, it captures what is essentially performance data for simulated traffic. It does not capture or handle any personal data by default. All data handled by synthetic monitors is expected to be non-personal. This document provides additional details about what we do to ensure data privacy and security with synthetic monitoring, plus additional options you can use. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. What we do Here's a summary of the data privacy and security measures that New Relic provides for you. Data privacy and security Comments No personal data By definition, all data collected through synthetic monitoring is test data created for the purpose of monitoring. None of this data includes personal data from any individual. TLS TLS encryption is required for all domains. This applies to public locations and private locations. Authentication Synthetic monitoring supports a variety of authentication mechanisms, including Basic, Digest, NTLM, and NTLMv2. Available options depend on the type of monitor you choose. Data collection The data transferred to the synthetic endpoint includes: Monitor run results, including full request and response headers of all requests, a complete HAR file of the session, and any screenshots captured (on failure or manually) Polling for available jobs in the private location's queue Private minion \"heartbeat\" every 30 seconds The SyntheticsPrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the synthetic monitoring endpoint contains the scheduled check's details. This includes the information necessary to complete the check for the minion: Target URL Validation text Full script (for synthetic scripted browser monitors) Data storage location Data collected by synthetic monitoring is stored in the region selected by each customer for their account (US or EU). Monitor configuration details (including frequency, check locations, target URL, and the full script for any scripted browser or API test monitors) are stored on our end. We also store all monitor check results for each monitor type. Data storage by monitor type For ping monitors, data storage includes the HAR file, which includes all requests and responses made during the check. For simple browsers, scripted browsers, and API tests, data storage includes the following: The HAR file includes full request and response headers for all requests made during the check. Any screenshots taken during the check are automatically included for simple and scripted browser monitors only on failure. However, you can manually configure this with scripting. The browser log (JS console) is automatically included for simple and scripted browsers. Any script output is included for scripted browsers and API test monitors. Response bodies New Relic never stores response bodies from requests originated by synthetic monitoring, unless you have manually configured a monitor script to do so. IP addresses Synthetic public minions are expected to be activated using non-personal credentials. Their IP addresses are not defined as personal data under data protection and privacy laws. What you can do For additional levels of security and data privacy, consider using these options. Additional measures Comments User access To control which of your users can access your monitors and private locations, set up role-based synthetic monitoring permissions and user groups. In addition, to track and be notified about changes, use audit logs and alert notifications. Passwords, API keys, user names, etc. To securely store sensitive information, use secured credentials for scripted browsers and API tests. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). Sites behind firewalls To control what sites you want to monitor behind your firewall, you can: Add the synthetic public minion IP addresses to your allow list or deny list. Use private locations to monitor sites or endpoints. This can provide an extra layer of security when monitoring your internally hosted sites and services. Web pages behind login pages If you configure synthetic monitoring to track website areas that are located behind a login page, be sure to create a non-personal login specifically for this purpose. This unique login will reduce the risk of unintended personal data exposure. Proxy configuration Aside from the target URLs monitored by New Relic, private minions will regularly send data to and receive from the synthetic monitoring endpoint. To configure a proxy for all traffic to and from this endpoint, set the MINION_API_PROXY environment variable on the minion host. Private minions security To ensure that only the scripts you intend to run are allowed to run on private minions, use verified script execution.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.29007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>synthetic</em> <em>monitoring</em>",
        "sections": "Security for <em>synthetic</em> <em>monitoring</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for available jobs in the private location&#x27;s queue Private minion &quot;heartbeat&quot; every 30 seconds The <em>Synthetics</em>PrivateMinion event contains basic minion status, including job success and failure counts, queue size, minion version, etc. Data received Data received from the <em>synthetic</em> <em>monitoring</em> endpoint"
      },
      "id": "604525b8e7b9d270a35799c8"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-aggregate-monitor-metrics": [
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.34146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary <em>page</em>. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.33856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary <em>page</em> and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61311,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> monitors are API checks or virtual browser instances that <em>monitor</em> your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each <em>page</em> resource, and downtime incidents. <em>Synthetic</em>"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary": [
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.33856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary <em>page</em> and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61311,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> monitors are API checks or virtual browser instances that <em>monitor</em> your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each <em>page</em> resource, and downtime incidents. <em>Synthetic</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions",
        "For more help"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-09-02T14:40:15Z",
      "updated_at": "2021-07-10T00:07:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. For more help Additional documentation resources include: Summary page (view an overview of your simple or scripted monitor's performance) Results page (full list of monitor results) Resources page (view load times for each element on a monitored page) Response codes (list of response codes specific to synthetic monitoring)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.87866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to adjust the number of downtime incidents returned. For more help Additional documentation resources include: Summary <em>page</em> (view an overview of your simple or scripted <em>monitor</em>&#x27;s performance) Results <em>page</em> (full list of <em>monitor</em> results) Resources <em>page</em> (view load times for each element on a monitored <em>page</em>) Response codes (list of response codes specific to <em>synthetic</em> <em>monitoring</em>)"
      },
      "id": "603e9efd64441faf344e8865"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime": [
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.34142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary <em>page</em>. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.33852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary <em>page</em> and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> monitors are API checks or virtual browser instances that <em>monitor</em> your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each <em>page</em> resource, and downtime incidents. <em>Synthetic</em>"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-understand-load-times": [
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.34142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary <em>page</em>. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.33852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary <em>page</em> and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> monitors are API checks or virtual browser instances that <em>monitor</em> your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each <em>page</em> resource, and downtime incidents. <em>Synthetic</em>"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index": [
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.34137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary <em>page</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary <em>page</em>. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "<em>Synthetic</em> monitors are API checks or virtual browser instances that <em>monitor</em> your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each <em>page</em> resource, and downtime incidents. <em>Synthetic</em>"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Troubleshoot downtime",
        "View the failures page",
        "View individual downtimes",
        "Use page functions",
        "For more help"
      ],
      "title": "Synthetic monitoring: Troubleshoot downtime",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "fd938ba2389afeb1fe8d8dcf03d91a516f9c983b",
      "image": "https://docs.newrelic.com/static/fc64706d910027f9c05840423fa74fdd/c1b63/failures.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-troubleshoot-downtime/",
      "published_at": "2021-09-02T14:40:15Z",
      "updated_at": "2021-07-10T00:07:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Failures page to locate and troubleshoot downtime incidents or other errors. A downtime incident occurs whenever a monitor fails to completely execute. For example, a ping monitor is \"down\" when the GET request fails, while a scripted browser monitor is \"down\" if any part of the script fails to execute. After locating an interesting downtime, select it to view detailed results from that downtime incident and troubleshoot. View the failures page To access your monitor's failures: Go to one.newrelic.com > Synthetics > (select a monitor) > Failures. Hover the mouse over a failure to get quick data about it. Click on the dot to open a detailed report of the failure. You can also click Run check to recheck the failed monitors. View individual downtimes You can select individual downtime incidents to view them in more detail. Depending on the specific failure, a downtime result could include only the server error message (such as Server replied with \"HTTP 500\" error), or a full or partial waterfall view. Downtime results include waterfalls when only part of a monitor executed correctly. For example, a 301 redirect could link to a failing web page. The browser correctly executes the redirect, but the destination web page returns an error. Use the error message or waterfall to troubleshoot the downtime incident. Use page functions The Failures page supports the following features: If you want to... Do this... Sort the list of downtimes In the table header, select Time or Message to sort the list. Select Time or Message again to change from ascending sort to descending sort order. Filter by location Select a location label to hide downtime incidents from that location. Select the location label again to unhide those results. To view results from only one location, hide every other location. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of downtime incidents returned. For more help Additional documentation resources include: Summary page (view an overview of your simple or scripted monitor's performance) Results page (full list of monitor results) Resources page (view load times for each element on a monitored page) Response codes (list of response codes specific to synthetic monitoring)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.87865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Troubleshoot downtime",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to adjust the number of downtime incidents returned. For more help Additional documentation resources include: Summary <em>page</em> (view an overview of your simple or scripted <em>monitor</em>&#x27;s performance) Results <em>page</em> (full list of <em>monitor</em> results) Resources <em>page</em> (view load times for each element on a monitored <em>page</em>) Response codes (list of response codes specific to <em>synthetic</em> <em>monitoring</em>)"
      },
      "id": "603e9efd64441faf344e8865"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-configuration": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-09-02T14:42:08Z",
      "updated_at": "2021-08-21T13:16:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution Amazon ECS is not supported. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.02576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-09-02T14:42:07Z",
      "updated_at": "2021-08-09T07:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including activating the feature by contacting your account representative. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The Private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.9924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    },
    {
      "sections": [
        "Verified script execution for private locations",
        "Passphrase security",
        "Important",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)"
      ],
      "title": "Verified script execution for private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "84a4f617447ed6f360feafc8432540025546dde8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations/",
      "published_at": "2021-09-02T14:56:41Z",
      "updated_at": "2021-08-02T05:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. Important This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution Do the following to enable verified script execution for containerized private minions. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, and then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSPHRASE environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.81155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Verified script execution for <em>private</em> <em>locations</em>",
        "sections": "Verified script execution for <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " verified script execution, then save. From the <em>Synthetics</em> UI, select a <em>monitor</em> assigned to that location. Then select Settings &gt; General. From the list of <em>private</em> <em>locations</em>, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each <em>monitor</em> you want to assign to your location"
      },
      "id": "60452628e7b9d217695799ee"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/containerized-private-minion-cpm-maintenance-monitoring": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-09-02T14:42:08Z",
      "updated_at": "2021-08-21T13:16:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution Amazon ECS is not supported. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.02573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-09-02T14:42:07Z",
      "updated_at": "2021-08-09T07:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including activating the feature by contacting your account representative. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The Private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.9924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    },
    {
      "sections": [
        "Verified script execution for private locations",
        "Passphrase security",
        "Important",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)"
      ],
      "title": "Verified script execution for private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "84a4f617447ed6f360feafc8432540025546dde8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations/",
      "published_at": "2021-09-02T14:56:41Z",
      "updated_at": "2021-08-02T05:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. Important This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution Do the following to enable verified script execution for containerized private minions. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, and then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSPHRASE environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.81155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Verified script execution for <em>private</em> <em>locations</em>",
        "sections": "Verified script execution for <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " verified script execution, then save. From the <em>Synthetics</em> UI, select a <em>monitor</em> assigned to that location. Then select Settings &gt; General. From the list of <em>private</em> <em>locations</em>, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each <em>monitor</em> you want to assign to your location"
      },
      "id": "60452628e7b9d217695799ee"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms": [
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-09-02T14:42:07Z",
      "updated_at": "2021-08-09T07:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including activating the feature by contacting your account representative. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The Private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.9924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    },
    {
      "sections": [
        "Verified script execution for private locations",
        "Passphrase security",
        "Important",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)"
      ],
      "title": "Verified script execution for private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "84a4f617447ed6f360feafc8432540025546dde8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations/",
      "published_at": "2021-09-02T14:56:41Z",
      "updated_at": "2021-08-02T05:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. Important This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution Do the following to enable verified script execution for containerized private minions. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, and then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSPHRASE environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.81155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Verified script execution for <em>private</em> <em>locations</em>",
        "sections": "Verified script execution for <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " verified script execution, then save. From the <em>Synthetics</em> UI, select a <em>monitor</em> assigned to that location. Then select Settings &gt; General. From the list of <em>private</em> <em>locations</em>, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each <em>monitor</em> you want to assign to your location"
      },
      "id": "60452628e7b9d217695799ee"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.86859,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, <em>locations</em>, frequency, and advanced options. For Scripted browser and API test monitors, select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/monitor-private-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-09-02T14:42:08Z",
      "updated_at": "2021-08-21T13:16:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution Amazon ECS is not supported. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.02573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-09-02T14:42:07Z",
      "updated_at": "2021-08-09T07:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including activating the feature by contacting your account representative. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The Private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.9924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    },
    {
      "sections": [
        "Verified script execution for private locations",
        "Passphrase security",
        "Important",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)"
      ],
      "title": "Verified script execution for private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "84a4f617447ed6f360feafc8432540025546dde8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations/",
      "published_at": "2021-09-02T14:56:41Z",
      "updated_at": "2021-08-02T05:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. Important This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution Do the following to enable verified script execution for containerized private minions. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, and then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSPHRASE environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.81155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Verified script execution for <em>private</em> <em>locations</em>",
        "sections": "Verified script execution for <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " verified script execution, then save. From the <em>Synthetics</em> UI, select a <em>monitor</em> assigned to that location. Then select Settings &gt; General. From the list of <em>private</em> <em>locations</em>, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each <em>monitor</em> you want to assign to your location"
      },
      "id": "60452628e7b9d217695799ee"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-09-02T14:42:08Z",
      "updated_at": "2021-08-21T13:16:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution Amazon ECS is not supported. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.02568,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Verified script execution for private locations",
        "Passphrase security",
        "Important",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)"
      ],
      "title": "Verified script execution for private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "84a4f617447ed6f360feafc8432540025546dde8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations/",
      "published_at": "2021-09-02T14:56:41Z",
      "updated_at": "2021-08-02T05:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. Important This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution Do the following to enable verified script execution for containerized private minions. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, and then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSPHRASE environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.81154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Verified script execution for <em>private</em> <em>locations</em>",
        "sections": "Verified script execution for <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " verified script execution, then save. From the <em>Synthetics</em> UI, select a <em>monitor</em> assigned to that location. Then select Settings &gt; General. From the list of <em>private</em> <em>locations</em>, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each <em>monitor</em> you want to assign to your location"
      },
      "id": "60452628e7b9d217695799ee"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.86847,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, <em>locations</em>, frequency, and advanced options. For Scripted browser and API test monitors, select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/troubleshoot-private-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-09-02T14:42:08Z",
      "updated_at": "2021-08-21T13:16:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution Amazon ECS is not supported. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.02568,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-09-02T14:42:07Z",
      "updated_at": "2021-08-09T07:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including activating the feature by contacting your account representative. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The Private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.99237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    },
    {
      "sections": [
        "Verified script execution for private locations",
        "Passphrase security",
        "Important",
        "Enable verified script execution",
        "Change your passphrase",
        "Disable verified script execution",
        "Other (legacy)"
      ],
      "title": "Verified script execution for private locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "84a4f617447ed6f360feafc8432540025546dde8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations/",
      "published_at": "2021-09-02T14:56:41Z",
      "updated_at": "2021-08-02T05:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To prevent others from using your private minions to assign scripted browsers or API tests, add verified script execution. Then, any changes to your minions will require a passphrase that is known only to you. The private locations list in New Relic's UI includes a VSE column. A lock icon indicates that verified script execution has been set up for that location. Passphrase security Be sure to safeguard your private minion's passphrase. No other users on your account can view it, and it is never stored in New Relic's collector. Important This restriction includes New Relic support personnel. Because our collector never stores your passphrase, our support team cannot recover or reset your passphrase for you. If you forget your passphrase, you will need to change it in the minion Overview page, and then update each monitor assigned to that private location. Enable verified script execution Do the following to enable verified script execution for containerized private minions. Be sure to record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, and then save. Set the passphrase in your Docker or Kubernetes environment: Docker: Add the MINION_VSE_PASSPHRASE environment variable to the Docker run command used to start your private minion: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Set the synthetics.minionVsePassphrase value in the Helm install or upgrade command: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Be sure to record your passphrase in a secure place. Repeat steps 3 and 4 for each monitor you want to assign to your location. Change your passphrase To change your passphrase, do the following. Be sure to record your passphrase in a secure place. Update the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion. Then use the Docker run command to start a new minion with your updated MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e MINION_PRIVATE_LOCATION_KEY=\"YOUR_PRIVATE_LOCATION_KEY\" \\ -e MINION_VSE_PASSPHRASE=\"YOUR_PASSPHRASE\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command to set your updated synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY --set synthetics.minionVsePassphrase=YOUR_PASSPHRASE Copy Go to one.newrelic.com > Synthetics > (assigned monitor) > Settings > General. From the list of private locations, select your location, type your new passphrase, and save. Repeat steps 2 and 3 for each monitor assigned to your location. Disable verified script execution To disable verified script execution for containerized private minions: Remove the passphrase in your Docker or Kubernetes environment: Docker: Stop your current minion container. Then use the Docker run command to start a new minion without the MINION_VSE_PASSPHRASE environment variable: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Kubernetes: Use the Helm upgrade command without the --set synthetics.minionVsePassphrase value: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Clear the Enable verified script execution checkbox, then save. Other (legacy) If you are not using containerized private minions, do the following to enable verified script execution. Be sure to record your passphrase in a secure place. In your web browser, navigate to the minion Overview page at https://MINION_IP_ADDRESS (for example, https://1.2.3.4). Select the pencil icon, then select Advanced settings (optional). Select the Verified script execution checkbox. Type a passphrase, then save. Record your passphrase in a secure place. Go to one.newrelic.com > Synthetics > Private locations > (select a private location). Select the private location's ellipses icon, and click Edit. Enable verified script execution, then save. From the Synthetics UI, select a monitor assigned to that location. Then select Settings > General. From the list of private locations, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each monitor you want to assign to your location. To change your passphrase or disable verified script execution, follow the same basic process to go to your minion's IP address and update its Advanced settings. Then go to one.newrelic.com to complete the process.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.81154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Verified script execution for <em>private</em> <em>locations</em>",
        "sections": "Verified script execution for <em>private</em> <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " verified script execution, then save. From the <em>Synthetics</em> UI, select a <em>monitor</em> assigned to that location. Then select Settings &gt; General. From the list of <em>private</em> <em>locations</em>, select your location, type your passphrase, and save. Repeat steps 4 through 6 for each <em>monitor</em> you want to assign to your location"
      },
      "id": "60452628e7b9d217695799ee"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/private-locations/verified-script-execution-private-locations": [
    {
      "sections": [
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Caution",
        "Docker container system environment requirements",
        "Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher)",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Docker start procedure",
        "Kubernetes start procedure",
        "Stop or delete the CPM",
        "Docker stop procedure",
        "Kubernetes delete procedure",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Run as non-root user for Docker",
        "Docker image repository",
        "Additional considerations for CPM connection"
      ],
      "title": "Install containerized private minions (CPMs)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "c3d19e2e7c99b15e05add0810342d1464e68b2f1",
      "image": "https://docs.newrelic.com/static/img-integration-k8-f16fcb798b1f0f56aa1be798a28c2b0b.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms/",
      "published_at": "2021-09-02T14:42:08Z",
      "updated_at": "2021-08-21T13:16:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's containerized private minions (CPM). These are Docker container-based private minions that accept and execute synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Caution Do not modify any CPM files. New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GiB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Caution Amazon ECS is not supported. Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a simple browser or scripted browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Caution We have identified a compatibility issue with Kubernetes v1.21+. A workaround is available by disabling the BoundServiceAccountTokenVolume feature gate on the cluster. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Caution Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ -d \\ --restart unless-stopped \\ quay.io/newrelic/synthetics-minion:latest Copy Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ -d ^ --restart unless-stopped ^ quay.io/newrelic/synthetics-minion:latest Copy View the logs for your minion container: docker logs --follow YOUR_CONTAINER_NAME Copy When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com Copy If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Copy Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Copy Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Copy Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Copy Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Copy Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Copy Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Copy Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Copy Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Copy Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help Copy To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion Copy helm show values YOUR_REPO_NAME/synthetics-minion Copy Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Copy Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... Copy OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Copy Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.02563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install containerized <em>private</em> minions (CPMs)",
        "sections": "<em>Private</em> <em>location</em> key",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "You can use New Relic&#x27;s containerized <em>private</em> minions (CPM). These are Docker container-based <em>private</em> minions that accept and execute <em>synthetic</em> monitors against your <em>private</em> <em>locations</em>. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system"
      },
      "id": "603ea47f28ccbcf987eba775"
    },
    {
      "sections": [
        "Private locations overview: Monitor internal sites and add new locations",
        "What you need",
        "Create a private location",
        "Tip",
        "Ping monitor checks",
        "Add jobs to the location queue",
        "Manage private locations",
        "Set proxy configuration"
      ],
      "title": "Private locations overview: Monitor internal sites and add new locations",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Private locations"
      ],
      "external_id": "169a071fc32eb5229ebc4e32deac6eb53481e61d",
      "image": "https://docs.newrelic.com/static/e24392abbb29035544f7fc902cf3deea/8c557/screen-assign-to-private-location-synthetics-monitor_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/private-locations-overview-monitor-internal-sites-add-new-locations/",
      "published_at": "2021-09-02T14:42:07Z",
      "updated_at": "2021-08-09T07:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In synthetic monitoring, a private location is a collection of private minions. A minion is a containerized application that receives and manages jobs set up through the Synthetics UI. A private location can contain any number of private minions. Private locations allow you to extend your synthetic monitoring coverage to new geographical locations, and to monitor websites behind your firewall (like an intranet site). What you need To use private locations, first review these requirements and other factors: Compatibility for... Requirements Check budget Checks from a private location count against your budget. Synthetics horde endpoint For US-based accounts: https://synthetics-horde.nr-data.net/ For EU-based accounts: https://synthetics-horde.eu01.nr-data.net/ Outbound network access The minion needs to connect to the synthetic monitoring's horde endpoint to receive and process jobs. If your firewall rules don't permit direct access, you must configure proxy access. Test your connection to the horde endpoint with a successful response from the following command: curl -X GET https://synthetics-horde.nr-data.net/synthetics/api/v1/ping Copy Account access and permissions How access works depends on your user model: Original user model: If a private location is set up by an account with child accounts, it can be used by users with access to those child accounts. But if it's set up on a child account, it can only be used by users in that account. New Relic One user model: user access to an account depends on whether they've been granted access to that account. Create a private location one.newrelic.com > Synthetics > Private Locations: Use the Private Locations page to create, edit, and delete private locations. Before installing private minions, you need to create a private location. To create a new private location: Ensure you meet the requirements, including activating the feature by contacting your account representative. Go to one.newrelic.com > Synthetics > Private locations. Then select Create private location. Tip The Private locations sub menu becomes available after you create your first monitor. Type a location name. Optional: Configure these additional settings: Description: Describe your private location for other account users. Verified script execution: Require a passphrase when assigning scripts to this location, or when adding minions to the location. Select Create. After creating the location, Synthetics lists your Private location key so you can install a private minion. Ping monitor checks Each minion can run about 200 ping monitor checks per minute (about 8,640,000 checks per month). If the job queue for a particular location is growing, add additional minions. The exact capacity of the minions can vary, depending on: Your network performance The complexity of your scripts The hardware configuration for the private minion Add jobs to the location queue To add jobs to the queue for your location, follow standard procedures to add or edit a monitor, and select your location from the Private locations list. To assign an existing monitor, edit that monitor's settings. one.newrelic.com > Synthetics > Create monitor: To assign new jobs to your private location and its minions, select its name from the Create monitor page. Manage private locations Tip If you can't access this feature, check the Factors affecting access to features and data. Synthetic monitoring includes tools to manage locations and individual minions. You can also install new minions, and clear the job queue if it backs up. To access these tools, go to one.newrelic.com > Synthetics > Private locations. Then follow the steps: If you want to... Do this... Clear the job queue Click the icon, and select Clear queue. This is useful when the number of scheduled jobs has increased faster than the minions can process them, such as when the minion is offline. View the status of an individual minion Select the parent location's name from the list. The green health status indicator identifies active minions. You can also view the last reported time for each minion, and check whether the minion software is out of date. Change location or view the private location key Click the icon, and select Edit. Delete a location Click the icon for the location, and select Delete. This does not shut down any minions assigned to that location. The minions must be shut down manually or reassigned. Enable or disable verified script execution Legacy minions: Verified script execution requires that you set up a passphrase on the minion before assigning any scripts to the location. CPM: You need to pass the MINION_VSE_PASSPHRASE variable to the minion. Then, at the Private locations tab, click on Edit and, in the menu, enable the Verified script execution option. Set proxy configuration You can set proxy server configuration for synthetic scripted monitors that run from local private locations. For more information, see Synthetic's proxy settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.99236,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "sections": "<em>Private</em> <em>locations</em> overview: <em>Monitor</em> internal sites and add new <em>locations</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In <em>synthetic</em> <em>monitoring</em>, a <em>private</em> location is a collection of <em>private</em> minions. A minion is a containerized application that receives and manages jobs set up through the <em>Synthetics</em> UI. A <em>private</em> location can contain any number of <em>private</em> minions. <em>Private</em> <em>locations</em> allow you to extend your <em>synthetic</em>"
      },
      "id": "604525f1e7b9d2d88d579a1c"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.86838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, <em>locations</em>, frequency, and advanced options. For Scripted browser and API test monitors, select Settings &gt; Script to edit your <em>monitor</em> script. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/add-custom-attributes-synthetic-monitoring-data": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-09-02T14:58:17Z",
      "updated_at": "2021-08-27T01:16:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(amount)%20FROM%20SyntheticsEvent', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.75836,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the <em>script</em>. one.newrelic.com &gt; <em>Synthetics</em> &gt; Create <em>monitor</em>: The <em>script</em> editor suggests functions, selectors, and other elements to simplify <em>scripting</em> commands (available in GitHub"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "For more help"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-09-02T11:12:51Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition For more help Additional documentation resources include: Writing scripted browsers (how to build WebDriverJS scripts for multi-step monitoring) Scripted browser examples (example code for scripted browsers, including comments, with examples like searching a website and waiting for results to load)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82329,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/import-nodejs-modules": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-09-02T14:58:17Z",
      "updated_at": "2021-08-27T01:16:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(amount)%20FROM%20SyntheticsEvent', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.7583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the <em>script</em>. one.newrelic.com &gt; <em>Synthetics</em> &gt; Create <em>monitor</em>: The <em>script</em> editor suggests functions, selectors, and other elements to simplify <em>scripting</em> commands (available in GitHub"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "For more help"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-09-02T11:12:51Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition For more help Additional documentation resources include: Writing scripted browsers (how to build WebDriverJS scripts for multi-step monitoring) Scripted browser examples (example code for scripted browsers, including comments, with examples like searching a website and waiting for results to load)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/introduction-scripted-browser-monitors": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-09-02T14:58:17Z",
      "updated_at": "2021-08-27T01:16:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(amount)%20FROM%20SyntheticsEvent', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.7583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the <em>script</em>. one.newrelic.com &gt; <em>Synthetics</em> &gt; Create <em>monitor</em>: The <em>script</em> editor suggests functions, selectors, and other elements to simplify <em>scripting</em> commands (available in GitHub"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "For more help"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-09-02T11:12:51Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition For more help Additional documentation resources include: Writing scripted browsers (how to build WebDriverJS scripts for multi-step monitoring) Scripted browser examples (example code for scripted browsers, including comments, with examples like searching a website and waiting for results to load)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/scripted-browser-examples": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-09-02T14:58:17Z",
      "updated_at": "2021-08-27T01:16:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(amount)%20FROM%20SyntheticsEvent', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.7583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the <em>script</em>. one.newrelic.com &gt; <em>Synthetics</em> &gt; Create <em>monitor</em>: The <em>script</em> editor suggests functions, selectors, and other elements to simplify <em>scripting</em> commands (available in GitHub"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "For more help"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-09-02T11:12:51Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition For more help Additional documentation resources include: Writing scripted browsers (how to build WebDriverJS scripts for multi-step monitoring) Scripted browser examples (example code for scripted browsers, including comments, with examples like searching a website and waiting for results to load)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-09-02T14:58:17Z",
      "updated_at": "2021-08-27T01:16:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(amount)%20FROM%20SyntheticsEvent', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.75824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the <em>script</em>. one.newrelic.com &gt; <em>Synthetics</em> &gt; Create <em>monitor</em>: The <em>script</em> editor suggests functions, selectors, and other elements to simplify <em>scripting</em> commands (available in GitHub"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "For more help"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-09-02T11:12:51Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition For more help Additional documentation resources include: Writing scripted browsers (how to build WebDriverJS scripts for multi-step monitoring) Scripted browser examples (example code for scripted browsers, including comments, with examples like searching a website and waiting for results to load)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-09-02T14:58:17Z",
      "updated_at": "2021-08-27T01:16:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(amount)%20FROM%20SyntheticsEvent', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.75824,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the <em>script</em>. one.newrelic.com &gt; <em>Synthetics</em> &gt; Create <em>monitor</em>: The <em>script</em> editor suggests functions, selectors, and other elements to simplify <em>scripting</em> commands (available in GitHub"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties",
        "For more help"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-09-02T14:58:18Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples An example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script. For more help Additional documentation resources include: Write scripted browsers (how to write scripted browsers for synthetic monitoring) Write API tests (how to write API tests for synthetic monitoring) Add and edit monitors (how to create virtual browser monitors in New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetics-scripted-browser-reference-monitor-versions-050": [
    {
      "sections": [
        "Write synthetic API tests",
        "Tip",
        "Use API http-request module",
        "Important",
        "Configure request options",
        "Using optional metadata",
        "Using a SSL option or agentOptions",
        "Send a GET request",
        "Insights GET example",
        "Send a POST request",
        "Custom event POST example",
        "Validate results",
        "Event API validation example"
      ],
      "title": "Write synthetic API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "236593e91fbe7bb6af91ca5f10db1c01d2df0396",
      "image": "https://docs.newrelic.com/static/1f9113bc9e00a2a14593e27718f45c7c/baaa6/api-test-snap_0.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests/",
      "published_at": "2021-09-02T14:58:17Z",
      "updated_at": "2021-08-27T01:16:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use synthetic monitoring's API tests to monitor your API endpoint to ensure it is functioning correctly. New Relic uses the http-request module internally to make HTTP calls to your endpoint and validate the results. Here we present some example functions showing how to use the $http object to submit your request. For detailed documentation on the options available for this object, see the http-request readme. Tip To view and share other API test examples, visit the synthetics scripts section in Explorers Hub. Use API http-request module API tests are powered by the http-request module, which is available through the $http object. Once each frequency interval, New Relic queries your endpoint from each of your selected locations. For instructions on creating a monitor, see Adding monitors. Read on to learn how to define metadata for your request, make a GET request, make a POST request, and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the script. one.newrelic.com > Synthetics > Create monitor: The script editor suggests functions, selectors, and other elements to simplify scripting commands (available in GitHub). Configure request options To start your script: Declare a variable (such as options) to store your request options object. Define request options such as the URL endpoint, and custom headers. If you're setting SSL or agent options, see SSL and agentOptions requirements. Tip For a full list of supported request options, see request(options, callback) in the http-request documentation on GitHub. Here's an example of optional metadata in the options object: Using optional metadata //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } }; Copy For SSL and agentOptions: If you are setting SSL options or providing an agentOptions object, the agent property in the request options object will need to be set to $globalAgents.https or $globalAgents.http to ensure your HTTP requests use the instrumented global agent. Here's an example of using a SSL option or agentOptions: Using a SSL option or agentOptions This example uses agentOptions: //Declare optional metadata var options = { //Specify the endpoint URL url: 'https://api-endpoint.example.com', //Specify optional headers headers: { 'Endpoint-Key': 'uqNTC57Phe72pnnB8JuJmwAr7b09nKSKSz', 'Additional-Header': 'Additional-Header-Data' } //Specify global agent as the http agent agent: $globalAgents.https, //Set SSL option strictSSL: true, //Specify http agent options agentOptions: { ​maxVersion: 'TLSv1.1' }, }; Copy Send a GET request To make a GET request, use the $http.get method to submit your request. Define your request options, make your request using $http.get, then validate the response to ensure your endpoint is returning the correct results. Insights GET example This example queries the Insights API by using GET: //Define your authentication credentials var myAccountID = '{YOUR_ACCOUNT_ID}'; var myQueryKey = '{YOUR_QUERY_KEY}'; var options = { //Define endpoint URI uri: 'https://insights-api.newrelic.com/v1/accounts/'+myAccountID+'/query?nrql=SELECT%20average(amount)%20FROM%20SyntheticsEvent', //Define query key and expected data type. headers: { 'X-Query-Key': myQueryKey, 'Accept': 'application/json' } }; //Define expected results using callback function. function callback (err, response, body){ //Log JSON results from endpoint to Synthetics console. console.log(JSON.parse(body)); console.log('done with script'); } //Make GET request, passing in options and callback. $http.get(options,callback); Copy Send a POST request To make a POST request, use the $http.post method to submit your request. Define your request options, make your request using $http.post, then validate the response to ensure your endpoint is returning the correct results. Custom event POST example This example POSTs a custom event containing static integers to the Event API: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the 'assert' module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; //Define expected results using callback function. function callback(error, response, body) { //Log status code to Synthetics console. console.log(response.statusCode + \" status code\") //Verify endpoint returns 200 (OK) response code. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); //Parse JSON received from Insights into variable. var info = JSON.parse(body); //Verify that `info` contains element named `success` with a value of `true`. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); //Log end of script. console.log(\"End reached\"); } //Make POST request, passing in options and callback. $http.post(options, callback); Copy Validate results To validate your results, import the assert module to define your test case. Call an assert method to validate your endpoint's response. If any assert functions fail, the entire monitor will be considered a failed check. This may trigger alert notifications and affect your metrics. Important Synthetic monitoring does not allow thrown exceptions. Thrown exceptions result in script failure. Use the assert module to validate your results, and use console.log() to log results to the synthetic's console. Event API validation example This example POSTs to the Event API, then validates that the response is {\"success\":true}: //Define your authentication credentials. var myAccountID = '{YOUR_ACCOUNT_ID}'; var myLicenseKey = '{YOUR_LICENSE_KEY}'; //Import the `assert` module to validate results. var assert = require('assert'); var options = { //Define endpoint URL. url: \"https://insights-collector.newrelic.com/v1/accounts/\"+myAccountID+\"/events\", //Define body of POST request. body: '[{\"eventType\":\"SyntheticsEvent\",\"integer1\":1000,\"integer2\":2000}]', //Define New Relic license key and expected data type. headers: { 'Api-Key': myLicenseKey, 'Content-Type': 'application/json' } }; $http.post(options, function(error, response, body) { //Log status code to Synthetics console. The status code is logged before the `assert` function, //because a failed assert function ends the script. console.log(response.statusCode + \" status code\") //Call `assert` method, expecting a `200` response code. //If assertion fails, log `Expected 200 OK response` as error message to Synthetics console. assert.ok(response.statusCode == 200, 'Expected 200 OK response'); var info = JSON.parse(body); //Call `assert` method, expecting body to return `{\"success\":true}`. //If assertion fails, log `Expected True results in Response Body,` plus results as error message to Synthetics console. assert.ok(info.success == true, 'Expected True results in Response Body, result was ' + info.success); }); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.7582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Write <em>synthetic</em> API tests",
        "sections": "Write <em>synthetic</em> API tests",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", and how to validate the results. Important After a maximum run time of three minutes, New Relic manually stops the <em>script</em>. one.newrelic.com &gt; <em>Synthetics</em> &gt; Create <em>monitor</em>: The <em>script</em> editor suggests functions, selectors, and other elements to simplify <em>scripting</em> commands (available in GitHub"
      },
      "id": "603ecf4328ccbc9c48eba78f"
    },
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61249,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "For more help"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-09-02T11:12:51Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition For more help Additional documentation resources include: Writing scripted browsers (how to build WebDriverJS scripts for multi-step monitoring) Scripted browser examples (example code for scripted browsers, including comments, with examples like searching a website and waiting for results to load)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/scripting-monitors/write-synthetic-api-tests": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61249,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add a <em>scripted</em> browser or API test <em>monitor</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " to edit. In the side menu, select a link to change the following settings: Select Settings &gt; General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test <em>monitors</em>, select Settings &gt; <em>Script</em> to edit your <em>monitor</em> <em>script</em>. For <em>synthetic</em> <em>monitoring</em> alerts"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
        "Overview",
        "Top-level functions: Build your script",
        "Disallow list: Wildcard use",
        "Options: Manage the browser instance",
        "Locators: Find page elements",
        "WebElement: Interact with page elements",
        "ActionSequence: Link multiple actions",
        "Promises: Link actions into sequences",
        "Navigate: Move through browser history",
        "Conditions: Pause and wait for conditions",
        "For more help"
      ],
      "title": "Synthetic scripted browser reference (monitor versions 0.4.x or lower)",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "8a611db3cb5dbef143f77936e67a50e87a5c5809",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-04x-or-lower/",
      "published_at": "2021-09-02T11:12:51Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document is for synthetic monitor versions 0.4.x or lower. See also the documentation for Synthetic monitor versions 0.5 or higher. Overview Synthetic scripted browsers provide you access to the Selenium Webdriver APIs 2.47.0 via the variables $driver and $browser. In particular: $driver provides all the exports from the selenium-webdriver module (for example, ActionSequence, Button, By, WebElement, etc.). $browser is a synthetic-flavored instance of selenium-webdriver.WebDriver(): it exposes the main basic WebDriver APIs like get() and findElement(), as well as some synthetic custom APIs. This document describes the functions available for synthetic scripted browser monitors version 0.4.0 or lower. For the newest monitor documentation, see monitor version 0.5.0+ documentation. Other relevant documentation: For more on synthetic scripting, see Write scripted browsers. For example scripts, see Scripted browser examples. For more information about monitor versions and runtime differences, see Runtime environments. To view and share scripted browser examples, check out topics tagged synthetic-script in New Relic's Explorers Hub. Top-level functions: Build your script New Relic calls top-level functions directly from your $browser instance. These provide a wide range of functionality that covers many basic scriptable actions. Function Return value $browser.actions() Creates a new action sequence using this driver. For a list of available actions, see ActionSequence: Link multiple actions. void $browser.addHeader(headerKey: string, headerValue: string) Adds header headerKey with value headerValue to the runtime. void $browser.addHeaders(headers: ?) Adds a map of headers to the runtime. void $browser.deleteHeader(header: string) Deletes a specific header from the runtime. void $browser.deleteHeaders(header: [string]) Deletes all headers in argument from runtime. void $browser.addHostnameToBlacklist(hostname: string) Disallows a hostname. Allows use wildcards. void $browser.addHostnamesToBlacklist(hostnameArr: [string]) Disallows all hostnames in an array of arguments. Allows use wildcards. void $browser.addHostnameToWhitelist(hostname: string) Allows a hostname blocked by default in synthetic monitoring. void $browser.addHostnamesToWhitelist(hostnameArr: [string]) Allows all hostnames in argument. void $browser.deleteHostnameFromBlacklist(hostname: string) Removes a hostname from this browser instance's blacklist. void $browser.deleteHostnamesFromBlacklist(hostnameArr: [string]) Removes all hostnames in argument from the disallowed list. void $browser.deleteHostnameFromWhitelist(hostnameArr: [string]) Removes a hostname from this browser instance's allowed list. void $browser.deleteHostnamesFromWhitelist(hostnameArr: [string]) Removes all hostnames in argument from this browser instance's allowed list. void $browser.executeAsyncScript(script: ?, var_args: ?) Schedules a command to execute asynchronous JavaScript in the context of the currently selected frame or window. promise $browser.executeScript(script: ?, var_args: ?) Schedules a command to execute JavaScript in the context of the currently selected frame or window. promise $browser.findElement(locator: $driver.Locator) Schedule a command to find an element on the page. If not found, New Relic returns an error. WebElement $browser.findElements(locator: $driver.Locator) Schedule a command to search for multiple elements on the page. promise $browser.waitForAndFindElement(locator: $driver.Locator [, timeout: number) Schedule a command to wait for and find an element on the page, and another command to wait for it to be visible. If not found, New Relic returns an error. The timeout value is an optional one, and gets applied separately to both tasks of finding the element and waiting for its visibility. This means at worst case, this method can take up to twice the provided timeout value. The default timeout value is 1000 ms (1 second). promise $browser.get(url: string) Loads a webpage in a synthetic browser. promise $browser.getAllWindowHandles() Schedules a command to retrieve the current list of available window handles. promise $browser.getCapabilities() A promise that will resolve with the instance's capabilities. promise $browser.getCurrentUrl() Schedules a command to retrieve the URL of the current page. promise $browser.getHeaders() Returns a map of currently configured headers. map $browser.getPageSource() Schedules a command to retrieve the current page's source. The page source returned is a representation of the underlying DOM; do not expect it to be formatted or escaped in the same way as the response sent from the web server. promise $browser.getSession() A promise for this client's session. promise $browser.getTitle() Schedules a command to retrieve the current page's title. promise $browser.getWindowHandle() Schedules a command to retrieve the current window handle. promise $browser.isElementPresent(locatorOrElement: $driver.Locator) Schedules a command to test if an element is present on the page. If given a DOM element, this function will check if it belongs to the document the driver is currently focused on. Otherwise, the function will test if at least one element can be found with the given search criteria. promise $browser.manage() The options interface for this instance. You can manage cookies, timeouts, and other window options. void $browser.navigate() The navigation interface (history of browser functions) for this instance. void $browser.schedule(command: ?, description: string) Schedules a command to be executed by this driver's CommandExecutor. promise $browser.sleep() Schedules a command to make the driver sleep for the given amount of time. promise $browser.switchTo() The target locator interface for this instance. void $browser.takeScreenshot() Schedule a command to take a screenshot. promise $browser.wait(fn: $driver.until.Condition, timeout: number, opt_message: string) Schedules a command to wait for a condition to hold, as defined by some user supplied function. webElement $browser.waitForPendingRequests(timeout: number) Causes the script to wait for requests that have been initiated to return, up to the timeout. Useful for tracking non-blocking resources. promise Disallow list: Wildcard use Disallowing domains for your browser instance requires wildcards to match the URL syntax of the URL to be blocked. An overall .com disallowed list needs to contain these functions: Function Blocking action $browser.addHostnameToBlacklist('*.com'); a.com $browser.addHostnameToBlacklist('*.*.com'); a.b.com $browser.addHostnameToBlacklist('*.*.*.com'); a.b.c.com $browser.addHostnameToBlacklist('www.*.com'); www.a.com $browser.addHostnameToBlacklist('www.*.*.com'); www.a.b.com $browser.addHostnameToBlacklist('www.*.*.*.com'); www.a.b.c.com Options: Manage the browser instance These functions manage options for your browser instance such as cookies, timeouts and window size. Access these options through the $browser.manage() function. Function Return value $browser.manage().addCookie(name: string, value: string, opt_path: string, opt_domain: string, opt_isSecure: boolean, opt_expiry: number) Schedules a command to add a cookie. promise $browser.manage().deleteAllCookies() Schedules a command to delete all cookies visible to the current page. promise $browser.manage().deleteCookie(name: string) Schedules a command to delete the cookie with the given name. This command is a no-op if there is no cookie with the given name visible to the current page. promise $browser.manage().getCookie(name: string) Schedules a command to retrieve the cookie with the given name. Returns null if there is no such cookie. The cookie will be returned as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().getCookies() Schedules a command to retrieve all cookies visible to the current page. New Relic Syntheticcs returns each cookie as a JSON object as described by the WebDriver wire protocol. promise $browser.manage().timeouts().implicitlyWait(ms: number) Specifies the amount of time the driver should wait when searching for an element if it is not immediately present. Setting the wait timeout to 0 disables implicit waiting. Be careful increasing the wait timeout, as it will increase test run time, especially with slower location strategies like XPath. Default is 10 seconds. promise $browser.manage().timeouts().pageLoadTimeout(ms: number) Sets the amount of time to wait for a page load to complete before returning an error. If the timeout is negative, page loads may last up to 180 seconds. Default is 60 seconds. promise $browser.manage().timeouts().setScriptTimeout(ms: number) Sets the amount of time to wait, in milliseconds, for an asynchronous script to finish execution before returning an error. Default is 30 seconds. promise $browser.manage().window().getPosition() Retrieves the window's current position, relative to the top left corner of the screen. promise $browser.manage().window().getSize() Retrieves the window's current size. promise $browser.manage().window().maximize() Maximizes the current window. promise $browser.manage().window().setPosition(x: number, y: number) Repositions the current window. promise $browser.manage().window().setSize(width: number, height: number) Resizes the current window. promise Locators: Find page elements Locators are a collection of factory functions for creating locator instances. Locators find DOM elements, which can be passed to functions such as $browser.findElement or $browser.isElementPresent. Call them through $driver.By. Function Return value $driver.By.className(className: string) Locates an element that has a specific class name. The returned locator is equivalent to searching for elements with the CSS selector .clazz. locator $driver.By.css(cssName: string) Locates an element using a CSS selector. locator $driver.By.id(id: string) Locates an element by its ID. locator $driver.By.linkText(linkText: string) Locates link elements whose visible text matches the given string. locator $driver.By.js(js: string) Locates an element by evaluating a JavaScript expression. locator $driver.By.name(name: string) Locates elements whose name attribute has the given value. locator $driver.By.partialLinkText(partialLinkText: string) Locates link elements whose getText visible contains the given substring. locator $driver.By.tagName(tagName: string) Locates elements with a given tag name. The returned locator is equivalent to using the getElementsByTagName DOM function. locator $driver.By.xpath(xpath: string) Locates elements matching a XPath selector. locator WebElement: Interact with page elements When a function such as $browser.findElement or $browser.waitForAndFindElement returns a WebElement reference, these functions can be used to interact with that element. Using these, you can click on buttons, sent text to form inputs, and get attributes of elements to test. Function Return value click() Clicks on this element. void sendKeys(var_args: ?) Schedules a command to type a sequence on the DOM element represented by this instance. WebElement getTagName() Schedules a command to query for the tag/node name of this element. WebElement getCssValue(name: string) Schedules a command to query for the computed style of the element represented by this instance. If the element inherits the named style from its parent, the parent will be queried for its value. Where possible, color values will be converted to their hex representation (for example, #00ff00 instead of rgb(0, 255, 0)). promise getAttribute(name: string) Schedules a command to query for the value of the given attribute of the element. promise getText(name: string) Get the visible (not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing white space. promise getSize() Schedules a command to compute the size of this element's bounding box, in pixels. promise getLocation() Schedules a command to compute the location of this element, in page space. promise isEnabled() Schedules a command to query whether the DOM element represented by this instance is enabled, as dictated by the disabled attribute. promise isSelected() Schedules a command to query whether this element is selected. promise submit() Schedules a command to submit the form containing this element (or this element if it is a FORM element). This command is a no-op if the element is not contained in a form. promise clear() Schedules a command to clear the value of this element. promise isDisplayed() Schedules a command to test whether this element is currently displayed. promise getOuterHtml() Schedules a command to retrieve the outer HTML of this element. promise getInnerHtml() Schedules a command to retrieve the inner HTML of this element. promise ActionSequence: Link multiple actions Action sequences can create complex user interactions with your website. To create a new action sequence, use $browser.actions(). To link multiple actions together into a sequence, include perform() after each. This executes and then terminates individual sequences, including single-action sequences. The following table contains a list of available actions. For more information, see the WebDriver ActionSequence documentation. Function Return value click(opt_elementOrButton: ?, opt_button: ?) Clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. This is equivalent to WebElement.click(). actionsequence doubleClick(opt_elementOrButton: ?, opt_button: ?) Double-clicks a mouse button. If an element is provided, the mouse will first be moved to the center of that element. actionsequence dragAndDrop(element: ?, location: ?) Convenience function for performing a \"drag and drop\" maneuver. The target element may be moved to the location of another element, or by an offset (in pixels). The location is an object with two properties x and y: {x: x_offset, y: y_offset}. actionsequence keyDown(key: ?) Performs a modifier key press. Must be one of ALT, CONTROL, SHIFT, COMMAND, or META. The modifier key is not released until keyUp() or sendKeys() is called. The key press will be targeted at the currently focused element. actionsequence keyUp(key: ?) Performs a modifier key release. The release is targeted at the currently focused element. actionsequence mouseDown(opt_elementOrButton: ?, opt_button: ?) Presses a mouse button. The mouse button will not be released until mouseUp is called, regardless of whether that call is made in this sequence or another. The behavior for out-of-order events (such as calling mouseDown() or click() when the button is already held down) is undefined. actionsequence mouseUp(opt_elementOrButton: ?, opt_button: ?) Releases a mouse button. Behavior is undefined for calling this function without a previous call to mouseDown(). actionsequence mouseMove(location: ?, offset: ?) Moves the mouse. The location to move to may be specified in terms of the mouse's current location, an offset relative to the top-left corner of an element, or an element (in which case the middle of the element is used). actionsequence perform() Executes this action sequence. promise sendKeys(args: ?) Simulates typing multiple keys. Each modifier key encountered in the sequence will not be released until it is encountered again. All key events will be targeted at the currently focused element. For a full list of supported non-alphanumeric keys, see the WebDriver enum key documentation. actionsequence Promises: Link actions into sequences You can also execute functions directly on promises. Synthetic monitoring is a native Node.js environment and uses standard Node.js promises. These functions evaluate the status of promises, cancel them, and more. In particular, you can create sequences of actions with the then() function and its siblings, thenFinally() and thenCatch(). For more information, see Sequence actions. Function Return value cancel(string: reason) Cancels the computation of this promise's value, rejecting the promise in the process. This method is a no-op if the promise has already been resolved. void isPending() Whether this promise's value is still being computed. boolean then(opt_callback: fn(T: ?), opt_errback: fn()) Registers listeners for when this instance is resolved. This is the basic function used to link synchronous actions in your script. promise thenFinally(callback: fn()) Registers a listener to invoke when this promise is resolved, regardless of whether the promise's value was successfully computed. promise thenCatch(callback: fn()) Registers a listener for when this promise is rejected. promise Navigate: Move through browser history The $browser.navigate() function exposes a number of functions that allow you to move backwards and forwards through your browser history, refresh your page and navigate to new pages. Function Return value back() Move back by one step in the browser's history. void forward() Move forward by one step in the browser's history. void refresh() Refresh the current page. void to(string: url) Load a new webpage in the current browser window. $browser.navigate().to() is equivalent to $browser.get(). void Conditions: Pause and wait for conditions Used with $browser.wait, until pauses your script execution until the condition is matched. For more information on explicit and implicit waits, see the WebDriver documentation. For .wait and .until usage examples, see Webdriver.wait examples. The following are available functions for $driver.until.Condition: Function Return value ableToSwitchToFrame(frame: ?) Creates a condition that will wait until the input driver is able to switch to the designated frame. The target frame may be specified as: A numeric index into window.frames for the current frame A webdriver.WebElement, which must reference a FRAME or IFRAME element on the current page A locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it Upon successful resolution of this condition, the driver will be left focused on the new frame. condition alertIsPresent() Creates a condition that waits for an alert to be opened. Upon success, the returned promise will be fulfilled with the handle for the opened alert. condition elementIsDisabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be disabled. condition elementIsEnabled(element: $driver.WebElement) Creates a condition that will wait for the given element to be enabled. condition elementIsNotVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user. condition elementIsVisible(element: $driver.WebElement) Creates a condition that will wait for the given element to become visible. condition elementIsSelected(element: $driver.WebElement) Creates a condition that will wait for the given element to be selected. condition elementLocated(element: $driver.Locator) Creates a condition that will loop until an element is found with the given locator. condition elementsLocated(element: $driver.Locator) Creates a condition that will loop until at least one element is found with the given locator. condition elementTextContains(element: $driver.WebElement, substr: string) Creates a condition that will wait for the given element's visible text to contain the given substring. condition elementTextIs(element: $driver.WebElement, text: string) Case sensitive. Creates a condition that will wait for the given element's visible text to match the given text exactly. condition elementTextMatches(element: $driver.WebElement, regex: string) Creates a condition that will wait for the given element's visible text to match a regular expression. condition stalenessOf(element: $driver.WebElement) Creates a condition that will wait for the given element to become stale. An element is considered stale once it is removed from the DOM, or a new page has loaded. condition titleContains(substr: string) Creates a condition that will wait for the current page's title to contain the given substring. condition titleIs(title: string) Creates a condition that will wait for the current page's title to match the given value. condition titleMatches(regex: string) Creates a condition that will wait for the current page's title to match the given regular expression. condition For more help Additional documentation resources include: Writing scripted browsers (how to build WebDriverJS scripts for multi-step monitoring) Scripted browser examples (example code for scripted browsers, including comments, with examples like searching a website and waiting for results to load)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "sections": "<em>Synthetic</em> <em>scripted</em> browser reference (<em>monitor</em> versions 0.4.x or lower)",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " APIs. This document describes the functions available for <em>synthetic</em> scripted browser <em>monitors</em> version 0.4.0 or lower. For the newest <em>monitor</em> documentation, see <em>monitor</em> version 0.5.0+ documentation. Other relevant documentation: For more on <em>synthetic</em> <em>scripting</em>, see Write scripted browsers. For example"
      },
      "id": "6045266428ccbc04a2336a71"
    },
    {
      "sections": [
        "Set proxy settings and properties for scripted monitors",
        "Proxy settings API for scripted monitors",
        "Important",
        "$network.setProxy(string or object PROXY URL)",
        "Returns",
        "Parameters",
        "Examples",
        "$network.setProxyForHttp(string or object PROXY URL)",
        "Tip",
        "$network.setProxyForHttps(string or object PROXY URL)",
        "$network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT)",
        "$network.setProxyAdvanced(object PROXY RULES OBJECT)",
        "$network.clearProxy()",
        "$network.getProxy()",
        "Proxy properties",
        "For more help"
      ],
      "title": "Set proxy settings and properties for scripted monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Scripting monitors"
      ],
      "external_id": "f8a45f39f13ea831a481fc293531b95674c17844",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/scripting-monitors/set-proxy-settings-properties-scripted-monitors/",
      "published_at": "2021-09-02T14:58:18Z",
      "updated_at": "2021-07-10T02:09:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about synthetic monitoring's proxy settings and properties. Proxy settings API for scripted monitors Important You can set proxy server configuration for synthetic scripted monitors for monitor versions 0.4.0 or higher. The global object $network allows you to control the network configuration used by your synthetic scripted monitors. The following are applicable for both scripted browsers and API tests, unless otherwise stated. $network.setProxy(string or object PROXY URL) Sets a proxy server to be used for all per-URL requests (HTTP, HTTPS, and FTP). Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxy('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxy('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttp(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTP traffic. Sets a proxy server to be used for all HTTP requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the port would be 80. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTP protocol on port 1234 with no authentication: $network.setProxyForHttp('http://host.com:1234') Copy An example of setting a proxy server with HTTP protocol with authentication credentials. $network.setProxyForHttp('http://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyForHttps(string or object PROXY URL) Tip This call is exactly the same as the per-URL setProxy call, except that it applies to HTTPS traffic. Sets a proxy server to be used for all HTTPS requests. Additional notes: The port is optional. If not provided, it will be derived from the scheme. For example, for HTTP the default port would be 443. The username and password are assumed to be the result of a call to encodeURIComponent(). Special characters like @ and : in the username and/or the password must be escaped. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description proxyURL | proxyUrlParsed String or Object The URL to connect to the proxy server. A string containing a proxyURL (for example, http://proxy_host:8888) or a plain object in the same format as defined by Node's url.parse(urlString) method. Examples An example of setting a proxy server with HTTPS protocol on port 1234 with no authentication: $network.setProxyForHttps('https://host.com:1234') Copy An example of setting a proxy server with HTTPS protocol with authentication credentials. $network.setProxyForHttps('https://proxyUsername:proxyPassword@proxyHost:1234') Copy $network.setProxyPAC(string PAC SCRIPT URL, object AUTH OBJECT) Sets a proxy server via a proxy auto-config (PAC) script and returns a promise. This function is only available for scripted browser monitors. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description scriptURL String The URL of the PAC script. authCredentialsMap Object Map of authentication credentials to be provided to the proxy server(s), keyed by the hostnames of the proxy server. Values of this map must be defined in the format {username: 'authUsername', password: 'authPassword'} Examples An example of setting a proxy server via a proxy auto-config (PAC) script: var authCredentialsMap = { 'example.com': {username: 'authUsername', password: 'authPassword'}, } Copy $network.setProxyAdvanced(object PROXY RULES OBJECT) Tip This method is Chrome-specific: it only applies to scripted browser monitor types. It can be used to allow for a more flexible and complex proxy configuration. In most cases, this method will not be needed. Sets the proxy configuration using the format supported by Chrome Extension API for Proxying. The input is a ProxyRules object, as defined by the Chrome Extension API to configures proxies. You can add authCredentials for proxies that need it. See Parameters for more details. Returns This method returns a Promise that will resolve once the configuration has been applied. Parameters Parameter Data Type Description ProxyRules Object Object The proxyRulesObject is a plain object that follows the format ProxyRules as defined by the Chrome Extension API to configures proxies. This object is \"flavoured\" to fit our runtime: users can define an additional property, authCredentials, for the Proxy server objects to provide authentication credentials for a specific proxy server. authCredentials is an object in the format {username: 'authUsername', password: 'authPassword'}. Examples An example of creating a proxyRules with authCredentials: var proxyRules = { singleProxy: { host:\"example.com\", authCredentials: { username: 'authUsername', password: 'authPassword' } } }; Copy $network.clearProxy() Clears/removes the current proxy configuration. Returns This method returns a Promise that will resolve once the configuration has been applied. $network.getProxy() This method returns the current proxy configuration. It must be synchronized in a promise callback. Examples An example of synchronizing getProxy with $network.setProxy(); and $network.clearProxy();: var assert = require('assert'); $network.setProxy(\"http://user:password@myproxyurl.com\") .then(function () { console.log('Proxy configuration applied'); //Note: $network.getProxy() is not synchronized with the webdriver Control Flow. //To make sure we get the proxy configuration after the call to setProxy() above // succeeds we need to use a promise callback var proxyData = $network.getProxy(); console.log(proxyData); }) .then(function () { // Again: getProxy() is not synchronized with the Webdriver Control Flow: we //need this promise callback otherwise clearProxy() might be called before the call // to getProxy() above returns return $network.clearProxy(); }) .then(function () { console.log('Proxy configuration cleared'); // We need this promise callback for reasons explained above var proxyData = $network.getProxy(); assert.equal(proxyData.rules, null); }); Copy Proxy properties Important This proxy information applies only to these versions: API monitors: 0.4.0, 0.2.2, 0.2.1, 0.1.0 Scripted monitors: 0.1.0 In order to analyze and collect your HTTP traffic metrics, New Relic must ensure the traffic passes through a conceptual funnel. Our synthetic monitoring includes a software funnel component capable of analyzing the HTTP requests or responses and then recording the information. New Relic's scripted browser monitors (versions 0.4.x and lower) include a mechanism to do this analysis without needing an HTTP proxy, so you don't have to configure anything. New Relic's API test (versions 0.4.x and lower) provides an $http object that is pre-configured to make the requests pass through the internal HTTP proxy. This allows you to write your test without including any proxy settings. If you want to use some other way to generate HTTP traffic while still collecting the HTTP traffic metrics, you can use $env.PROXY_HOST and $env.PROXY_PORT. To record traffic metrics, be sure to include these properties in your script. For more help Additional documentation resources include: Write scripted browsers (how to write scripted browsers for synthetic monitoring) Write API tests (how to write API tests for synthetic monitoring) Add and edit monitors (how to create virtual browser monitors in New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.82327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "sections": "Set proxy settings and properties for <em>scripted</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Read on to learn about <em>synthetic</em> <em>monitoring</em>&#x27;s proxy settings and properties. Proxy settings API for scripted <em>monitors</em> Important You can set proxy server configuration for <em>synthetic</em> scripted <em>monitors</em> for <em>monitor</em> versions 0.4.0 or higher. The global object $network allows you to control the network"
      },
      "id": "6045269d64441fcdc1378ecf"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/monitor-produces-no-traffic": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61241,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.4956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary page. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary page and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/non-scripted-monitor-errors": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61241,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.4956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary page. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary page and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/private-location-hmac-errors": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61241,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.4956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary page. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49373,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary page and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/simple-scripted-or-scripted-api-non-ping-errors": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary page. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary page and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/troubleshooting/troubleshoot-isolated-monitor-failures": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.61234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> also collects custom response codes for more detail on your <em>monitor</em> runs. For a description of <em>synthetic</em> <em>monitor</em> types, see Types of <em>monitor</em>. Add a <em>monitor</em> There are several types of <em>synthetic</em> <em>monitor</em> to add. Ping monitors ensure your website is responding, while simple browser monitors send"
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " <em>monitoring</em> summary page. Click Show new view to access a new curated summary experience. <em>Synthetic</em> chart Description Load time chart This shows the load times for each <em>monitor</em> location. When you select a short time frame (such as 30 minutes), <em>Synthetics</em> displays the exact load time for each run"
      },
      "id": "604525b7196a67d21b960f6f"
    },
    {
      "sections": [
        "Index of synthetic monitors",
        "View the monitors index",
        "Understand monitor metrics",
        "Use index functions"
      ],
      "title": "Index of synthetic monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "31ee0cdc58c68b1783c782f5b1fd63a3b9b23823",
      "image": "https://docs.newrelic.com/static/d4e13d397c055e8164da62aadeda4f1f/c1b63/monitor-index.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitors-index/",
      "published_at": "2021-09-02T14:40:16Z",
      "updated_at": "2021-08-27T06:57:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In our synthetic monitoring tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each monitor's performance over the last 24 hours. Select an individual monitor to view a Summary page and get a deeper insight into its performance over time. Or, filter the list to quickly compare the performance of similar monitors. View the monitors index To access an index (or list) of your monitors, go to one.newrelic.com > Explorer > Synthetic monitors. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from synthetic monitors to applications, hosts, or custom groupings of any elements. Alternatively, you can go to one.newrelic.com > Synthetics. You can check the status and main metrics of your synthetic monitors at a glance thanks to the Monitors index. You can also use the explorer to view a list of all monitors associated with your New Relic account, along with a quick snapshot of each monitor's performance. To access an index (or list) of your monitors: Go to one.newrelic.com > Explorer > Synthetic monitors. one.newrelic.com > Explorer > Synthetic monitors: Use the monitors index to access any of your Synthetics monitors, and to view a quick snapshot of their performance. Understand monitor metrics Use the monitors index to access your monitors and view a quick snapshot of monitor performance. The index includes the following metrics: Alert status: Indicates the status of any alerts on the monitor: Green: No open violations Red: Critical violation in progress Grey: No alert conditions defined with New Relic Alerts Monitor status: Indicates a status has been applied to the monitor, such as Mute or Disabled. Success rate: The percentage of monitor checks that end in success. A multi-step monitor that does not complete all steps is considered a failure. Locations failing: The number of locations that have failed during the given timeframe. Period: How often the monitor checks run. Monitor type: The selected monitor type. Use index functions The monitors index supports the following features: If you want to... Do this... Sort the monitor list Select a column label to sort the list based on that metric. Select the label again to change the sort order from ascending to descending. Filter the monitor list Type your keyword in the search box to filter by name, tags, or entitiy type. Add to favorites To favorite a monitor, select the star star icon icon. Favorite monitors appear at the top of the monitor list. To remove a monitor from your favorites, select the star icon again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Index of <em>synthetic</em> <em>monitors</em>",
        "sections": "Index of <em>synthetic</em> <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "In our <em>synthetic</em> <em>monitoring</em> tool, the monitors index lists all monitors associated with your New Relic account, and gives you a quick snapshot of each <em>monitor</em>&#x27;s performance over the last 24 hours. Select an individual <em>monitor</em> to view a Summary page and get a deeper insight into its performance over"
      },
      "id": "60455a8464441f3f23378ebd"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors": [
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.48401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for the run to be considered a success. Above the selected <em>monitor</em>&#x27;s Availability chart, an ellipsis icon appears. <em>Use</em> New Relic&#x27;s comparative charting feature for a direct page load time comparison between real user (browser <em>monitoring</em>) interactions and the <em>Synthetics</em> <em>monitors</em>. Average load size"
      },
      "id": "604525b7196a67d21b960f6f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/alerts-synthetic-monitoring": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.65762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.48401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/collect-synthetic-transaction-traces": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.6575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.48401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/handle-sites-authentication": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.6575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.48401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/manage-monitor-runtimes": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.6575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.48401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.6574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.48401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49547,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for the run to be considered a success. Above the selected <em>monitor</em>&#x27;s Availability chart, an ellipsis icon appears. <em>Use</em> New Relic&#x27;s comparative charting feature for a direct page load time comparison between real user (browser <em>monitoring</em>) interactions and the <em>Synthetics</em> <em>monitors</em>. Average load size"
      },
      "id": "604525b7196a67d21b960f6f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/recheck-failed-monitors": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.6574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.48401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.65727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84023,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Synthetic monitoring: Summary page",
        "View the Summary page",
        "Understand the Summary page",
        "Use page functions",
        "Legacy charts",
        "Important",
        "For more help"
      ],
      "title": "Synthetic monitoring: Summary page",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Pages"
      ],
      "external_id": "342483d007728143c635a8ba0c2b5c76b9b18133",
      "image": "https://docs.newrelic.com/static/a390d7ca2a89356a923a9d457c9d6acf/8c557/summary-page.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/pages/synthetic-monitoring-summary/",
      "published_at": "2021-09-02T14:39:27Z",
      "updated_at": "2021-08-27T06:58:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Summary page of synthetic monitoring gives you an at-a-glance understanding of your website's performance. You can look for trends in request/response times, connection times, and errors. Use the filter to narrow data to attributes or values of interest, or recheck failed monitors. View the Summary page To access your monitor's Summary page: Go to one.newrelic.com > Explorer > Synthetic monitors > (select a monitor). You can also access it from one.newrelic.com > Synthetics > (select a monitor). The Summary page gives you a high-level view of your website's performance, and has shortcuts to location checks, alert violations, and your monitor's metadata. Understand the Summary page Use the Summary page to understand your website's performance: Synthetics Summary charts Description Success and failure rate This shows the monitor's overall success rate and total number of check failed during the given timeframe, the number of locations that are failing, and the error message for the last error detected. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Page load time and availability This shows the page load times and availability, the percentage of monitor runs that were successful, for each monitor location. The timeframe displayed will vary depending on the frequency of the monitor: 1 minutes = 30 minutes 5 minutes = 1.5 hours 15 minutes = 7.5 hours 30 minutes = 15 hours 1 hour = 30 hours 6 hours = 7.5 days 12 hours = 15 days 24 hours = 30 days Request/response times This shows the time that it took the ping monitor to send and receive a response, and is broken down into duration sent, duration wait, and duration received. Durations can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Connection times This shows the breakdown for the network connections to be established for this monitor, and is broken down into the DNS, SSL, and connection durations. Duration can be displayed as Average, Median, or 95th Percentile. For more information see, Percentiles: Ranking data. This is only available for ping monitor results. Non-200 response codes This shows any (non-200) error response code that were received as a result of running this monitor. This is only available for ping monitor results. Activity panel Displays any recent activity associated with the monitor, including: Monitor name Number of open violations Activity on the monitor, including recent open and closed violations and audit events. Metadata and tags. Monitored entities: This is any New Relic entity that is observed when this monitor runs and includes the entity alert status. Selecting an entity status will navigate to the monitored entity summary page. Use page functions The Summary page supports the following functions: If you want to... Do this... View a result in detail To view exact metrics, hover the mouse over the chart. Re-run a monitor check Click the Run check button to recheck any failed monitor. View detailed about an alert violation In the Activity panel, click on the displayed alert to go directly to the alert incident page. Quickly access another monitor At the top of the screen, click on the name of the current monitor to open the dropdown menu. Select from the list of recent monitors, or enter a name in the search field to search for a specific monitor. Change the time frame Use the time picker to adjust the number of results returned for the following charts: Request/response times Connection times Non-200 response codes This is only available for ping monitor results. Legacy charts Important The following table applies to the old view of the synthetic monitoring summary page. Click Show new view to access a new curated summary experience. Synthetic chart Description Load time chart This shows the load times for each monitor location. When you select a short time frame (such as 30 minutes), Synthetics displays the exact load time for each run of your monitor from each location. With longer time frames, Synthetics adjusts the resolution to show averages. To toggle the visibility of a location, select its label. Availability This shows the percentage of monitor runs that were successful. For a scripted monitor, the entire script must complete for the run to be considered a success. Above the selected monitor's Availability chart, an ellipsis icon appears. Use New Relic's comparative charting feature for a direct page load time comparison between real user (browser monitoring) interactions and the Synthetics monitors. Average load size This chart shows the amount of data (in kilobytes or megabytes) consumed in each run of the monitor. For scripted monitors, the entire script is included in the average load size graph. For example, a monitor that loads three pages will measure the size of all assets on all three pages. If your site is static, the average load size will be very consistent. For dynamic sites such as a news site, the average load size will vary as your page content changes. Slowest results This lists the five slowest results for the selected time frame. To view the performance breakdown, select a result. Monitor downtimes This lists the most recent monitor downtime incidents. To view additional details, select a downtime incident. For more help Additional documentation resources include: Results (full list of monitor results) Resources page (load times for each element on a monitored page) Failures (list of downtime incidents, and individual downtimes for in-depth analysis)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.49544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "sections": "<em>Synthetic</em> <em>monitoring</em>: Summary page",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " for the run to be considered a success. Above the selected <em>monitor</em>&#x27;s Availability chart, an ellipsis icon appears. <em>Use</em> New Relic&#x27;s comparative charting feature for a direct page load time comparison between real user (browser <em>monitoring</em>) interactions and the <em>Synthetics</em> <em>monitors</em>. Average load size"
      },
      "id": "604525b7196a67d21b960f6f"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/synthetic-monitoring-response-codes": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.65727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84023,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/view-ping-monitor-results": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.65717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/synthetics/synthetic-monitoring/using-monitors/view-simple-scripted-monitor-results": [
    {
      "sections": [
        "Add and edit monitors",
        "Add a monitor",
        "Add a ping or simple browser monitor",
        "Add a scripted browser or API test monitor",
        "Tip",
        "Add a step monitor",
        "Add a certificate check monitor",
        "Add a broken links monitor",
        "Edit a monitor",
        "Important",
        "Delete a monitor",
        "Monitor settings",
        "Type",
        "Monitor name",
        "Location",
        "Frequency",
        "Alerts",
        "Apdex T",
        "Response Validation (optional)",
        "See a history of monitor changes"
      ],
      "title": "Add and edit monitors",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "72465a40555ae7b882953091b08d3af1f9fd1102",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/add-edit-monitors/",
      "published_at": "2021-09-02T11:43:28Z",
      "updated_at": "2021-09-02T11:43:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitors are API checks or virtual browser instances that monitor your website, recording each check in detail. They can also capture aggregate numbers, including an overview, or summary for ping monitors, detailed statistics for each page resource, and downtime incidents. Synthetic monitoring also collects custom response codes for more detail on your monitor runs. For a description of synthetic monitor types, see Types of monitor. Add a monitor There are several types of synthetic monitor to add. Ping monitors ensure your website is responding, while simple browser monitors send real browsers to check your website. For more complex monitoring, scripted browser monitors verify that specific resources are present, while API tests verify your API endpoint. Add a ping or simple browser monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type, name, and URL. Optional: Add a validation string or Advanced options: A validation string is available for ping and simple browser. This option enables substring monitoring for response validation. Verify SSL is available for ping and simple browser. This option verifies the validity of the SSL certificate chain. It can be duplicated by running the following syntax: openssl s_client -servername {YOUR_HOSTNAME} -connect {YOUR_HOSTNAME}:443 -CApath /etc/ssl/certs -verify_hostname {YOUR_HOSTNAME} > /dev/null Copy If a non-zero exit code is returned, the monitor will fail. The Bypass HEAD request option is available for ping. This option skips the default HEAD request and instead uses the GET verb with a ping check. Redirect is Failure is available for ping. If a redirect result occurs when Redirect is Failure is enabled, New Relic Synthetics will categorize the result as a failure, rather than following the redirect and checking the resulting URL. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a scripted browser or API test monitor Go to one.newrelic.com > Synthetics > Create monitor. Specify a monitor type and name. Select the locations from which you want your monitor to run. Choose a frequency to determine how often each location will run your monitor. Optional: Set up alert notifications. Select Next: Write your script to create a script for your scripted browser or API test, then select Validate to verify your syntax. Tip For complex scripts, validation may take up to one minute. Select Create my monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a step monitor Go to one.newrelic.com > Synthetics > Create monitor. Select step monitor as the monitor type. Specify a name and choose a frequency to determine how often each location will run your monitor. Select the locations from which you want your monitor to run. Build your monitor by selecting from the preconfigured steps at the bottom of the UI: Navigate to a URL Type text Click an element Assert text Assert an element Secure a credential Use the instructions on the right side of the UI to help locate elements by CSS class, HTML ID, link text, or XPath. Select Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a certificate check monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the certificate check monitor type. Specify a name and enter the domain you'd like to monitor. Enter the number of days it takes for your certificate to expire. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Add a broken links monitor Go to one.newrelic.com > Synthetics > Create monitor. Select the broken links check monitor type. Specify a name and enter the URL you'd like to monitor. Select the period to determine your monitor's frequency. Optional: Add tags to help you find this monitor later. Select the locations from which you want your monitor to run, and then click Save monitor to confirm. Wait a few minutes, then check your monitor from the Monitors index. Tip You can also use the Synthetics REST API to add monitors. For example, you can create a GET request to the monitor you want to use as the source for configuration, then use those key values to use in a POST to \"copy\" and create a new monitor. Edit a monitor To edit an existing monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. In the side menu, select a link to change the following settings: Select Settings > General to edit name, Apdex T, URL, locations, frequency, and advanced options. For Scripted browser and API test monitors, select Settings > Script to edit your monitor script. For synthetic monitoring alerts, click Manage alerts. Select Save changes to confirm. Important You cannot change a monitor's type after the monitor is created. Delete a monitor To delete a monitor: From the Monitors tab in one.newrelic.com > Synthetics, select the monitor you want to edit. From the selected monitor, select Settings > General. Scroll to the bottom of the page and select the trash can icon. Tip You can also use the Synthetics REST API to delete a monitor. Monitor settings When configuring monitors, the following settings are available: Type Select the type of monitor you want to create. A monitor's type can't be changed after the monitor is created. Ping: Specify a single URL to monitor for availability. New Relic will check this URL via HEAD or GET requests. The non-configurable timeout for this monitor is 60 seconds. Simple browser: Specify a single URL to monitor via real browser. Once each frequency interval, New Relic will check this URL via a Selenium-powered Google Chrome browser. The non-configurable timeout for this monitor is 60 seconds. Scripted browser: Create a script to drive a Selenium-powered Google Chrome browser. The browser follows each step in the script to verify that complex behavior is working as expected (for example, searching a website, then clicking one of the search results). The non-configurable timeout for this monitor is 180 seconds. API test: Create an API script to ensure your API endpoint is working correctly. For more information, see Write API tests. The non-configurable timeout for this monitor is 180 seconds. Monitor name Defines a name for the monitor. Monitor names cannot contain unencoded angle brackets (< >). To include angle brackets in a monitor name, encode them as HTML bracket entities (&lt; &gt;) in the UI or API. Location Select the locations where you want your monitor to run. Select more locations to ensure that your application is available to users around the world. If you have any private locations, they will be listed here too. You can use the Synthetics API location endpoint to retrieve a list of valid locations for your account. Your monitor will run one check from each selected location during each frequency interval. For example, if you select three locations and define a frequency of 15 minutes, your monitor will run three checks in each 15 minute period (or 8,640 checks per month). Frequency Select how often the monitor runs, in increments of minutes, hours, or 1 day. This frequency applies to each location. For example, if you select three locations and a Frequency of 15 minutes, your monitor will run three checks, on average every 5 minutes, in each 15 minute period (or 8,640 checks per month). Alerts Specify an email address to receive alerts when a monitor fails. Or, attach a monitor to an existing alert policy for more notification options. For more information, see Alerting for synthetic monitoring. Apdex T Customize the Apdex T for this monitor. This setting is only available when editing the settings for an existing monitor, not when creating a new monitor. Change the Apdex T from the default 7 seconds for more accurate Apdex scores in your SLA reports. For example, if you have a very long scripted browser, you might adjust the Apdex T to 15 seconds to more closely reflect the usual completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When using simple browser or ping monitor types, there is a 1MB (10^6 bytes) limit on the page load. See a history of monitor changes You can use New Relic One to see a history of recent changes to synthetic monitors and what users changed them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 221.65717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add and edit <em>monitors</em>",
        "sections": "Add and edit <em>monitors</em>",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": " completion time. Similarly, a good Apdex T for a simple browser check might be only 2 seconds. Response Validation (optional) Specify text to search for on the page. When <em>using</em> simple browser or ping <em>monitor</em> types, there is a 1MB (10^6 bytes) limit on the page load. See a history of <em>monitor</em> changes You can <em>use</em> New Relic One to see a history of recent changes to <em>synthetic</em> <em>monitors</em> and what users changed them."
      },
      "id": "604526d064441f3ecc378f03"
    },
    {
      "sections": [
        "Monitor downtimes: Disable monitoring during scheduled maintenance times",
        "Important",
        "Tip",
        "Create recurring monitor downtimes",
        "Create a one-time monitor downtime",
        "View downtime monitors",
        "Delete a monitor downtime",
        "Edit a monitor downtime",
        "For more help"
      ],
      "title": "Monitor downtimes: Disable monitoring during scheduled maintenance times",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "2d8db7bdaef28ad7b523a9e5b1ea209c24aed51b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/monitor-downtimes-disable-monitoring-during-scheduled-maintenance-times/",
      "published_at": "2021-09-02T11:45:25Z",
      "updated_at": "2021-08-02T05:22:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Schedule monitor downtimes to specify times that your synthetic monitors cease alerting, while still preserving your SLA report metrics. Monitor downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During synthetic monitor downtimes, your selected monitors stop running until their scheduled end time. To temporarily disable alerts without pausing your monitors, mute them instead. Tip The ability to add, edit, or delete monitor downtimes depends on your access to features. Create recurring monitor downtimes Create recurring monitor downtimes for routine monitor maintenance or regularly scheduled outages. To create a recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the monitor downtime. Select a daily, weekly, or monthly frequency. Choose additional scheduling options, such as day of the week, time of day, and how long the window will last. Select the monitors that you would like to be included in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. Create a one-time monitor downtime For spontaneous maintenance or service interruptions, create one-time monitor downtimes that will not reoccur. To create a non-recurring monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Select Create monitor downtime. Specify a name for the new monitor downtime. Select once for the frequency, along with the date and start time for the monitor downtime. Select the monitors to include in the monitor downtime. There is no maximum for the amount of monitors that can be selected. Select Create. View downtime monitors Go to one.newrelic.com > Synthetics > (select your monitor) > Summary. When a monitor downtime occurs, it will be visible on your Summary page within the Load time chart as a yellow vertical line. To see which monitor downtime occurred within the chart, hover over the yellow line to view the monitor downtime name. You can view additional details in the Results and Resources sections. Tip If you are unable to delete a window, check your permissions. Delete a monitor downtime To delete an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be deleted in the index. Select the ellipsis icon, and then Delete. Edit a monitor downtime Tip If you are unable to edit a window, check your permissions. To edit an existing monitor downtime: Go to one.newrelic.com > Synthetics > Monitor downtime. Locate the monitor downtime to be edited in the monitor downtime index. Select the ellipsis icon for the downtime you want to edit. Edit the name or frequency of the monitor downtime. To remove a monitor from the list of targets, locate the monitor in the list of Selected targets and select the remove icon next to the monitor. Once you've finished editing, select Save. For more help Additional documentation resources include: Alerting for synthetic monitoring (receive notifications when a monitor fails) Private locations (extend synthetic monitoring coverage to new geographical locations)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.84021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "sections": "<em>Monitor</em> downtimes: Disable <em>monitoring</em> during scheduled maintenance times",
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": "Schedule <em>monitor</em> downtimes to specify times that your <em>synthetic</em> <em>monitors</em> cease alerting, while still preserving your SLA report metrics. <em>Monitor</em> downtimes are ideal for: Routine maintenance Planned outages Deployments Service interruptions Important During <em>synthetic</em> <em>monitor</em> downtimes, your selected"
      },
      "id": "603ed79b28ccbc8276eba76f"
    },
    {
      "sections": [
        "Store secure credentials for scripted browsers and API tests",
        "Requirements and limits",
        "Add or update secure credentials",
        "Update the script",
        "Security for secure credentials",
        "Redacted information"
      ],
      "title": "Store secure credentials for scripted browsers and API tests",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Using monitors"
      ],
      "external_id": "ee8bec412a7cb3223e6164d653ca9fc9307e672a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/using-monitors/store-secure-credentials-scripted-browsers-api-tests/",
      "published_at": "2021-09-02T11:46:35Z",
      "updated_at": "2021-07-21T06:16:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use secure credentials with synthetic monitoring to store critical information, such as passwords, API keys, usernames, etc. This prevents scripted monitor users from viewing, updating, or deleting these values unless they have explicit permissions in New Relic. The credentials are securely stored using AES-GCM 256-bit encryption at rest with keys managed by Amazon AWS Key Management Service (KMS). You can set secure credentials in New Relic One or with the API. Requirements and limits Before using secure credentials, review these requirements and guidelines: Secure credentials Comments Applicable monitors The secure credentials feature is available only for synthetic scripted browsers and API test monitors. Permissions Account administrators can control which users can create, view, or delete secure credentials by managing users' permissions. Limit You can have a maximum of 1,000 secure credentials. Add or update secure credentials You can add or update secure credentials using the UI or the Synthetics REST API. To add, view, edit, or delete a secure credential for a scripted browser or API test monitor from the UI: Go to one.newrelic.com > Synthetics > Secure credentials. Follow the UI instructions to add, edit, or delete a secure credential, then save any additions or changes you make. Tips for creating the Key: choose a username or other meaningful key name to identify the secure credential. Use alphanumeric or underscore _ characters. Key names must be UPPERCASE. Tips for creating the Value: Use any combination of alphanumeric or special characters. 10000 characters maximum. This field is not accessible via the API. Associate the secure credential with a scripted browser or API test by editing the script. After you add the secure credential to the script, the Secure credentials user interface shows how many scripted monitors use that credential. This number is approximate and only updates after a monitor with a secure credential has actually been run. Update the script When using the Synthetics UI editor to create scripted browsers or API test monitors, follow these guidelines: Script Guidelines Format Anywhere in the script where you reference the secure credential, it is accessed via the reserved New Relic $secure JavaScript object with dot notation. For example, $secure.MY_SECURE_CREDENTIAL. Properties on $secure are not accessible through bracket notation. Existing credentials To view or select from a list of available secure credentials: Type $secure. OR Select from the dropdown in the editor UI. Validation To validate the secure credential, follow standard procedures to test the script or write an API test. Any changes to the secure credential's value will automatically take effect across all monitors that use it. You do not need to also update the script. Exception: If you update the script and jobs are already processing, the secure credential change will not take effect until the next time the job begins. Security for secure credentials To ensure the security of your secure credentials, New Relic scrubs the secure value out of all data that goes to results in synthetic monitoring data and alerts. New Relic employees cannot access secure credential values and must be added to the account to be able to view secure credentials. Example A secure credential is named PASSWORD and the value is Pass123!. New Relic replaces Pass123! with _SECURECREDENTIAL_ For example, a script includes: $browser.get(\"https://example.com/\" + $secure.PASSWORD) Copy The script results will show that New Relic Synthetics went to https://example.com/_SECURECREDENTIAL_, even though it actually went to https://example.com/Pass123!. This ensures the value of the secure credential will not appear in the results. Redacted information We currently redact the following from the results of your monitor: The exact values of your secure credentials Any percent-encoded values of your secure credentials",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Synthetic</em> <em>monitoring</em>",
        "body": ", the Secure credentials user interface shows how many scripted <em>monitors</em> <em>use</em> that credential. This number is approximate and only updates after a <em>monitor</em> with a secure credential has actually been run. Update the script When <em>using</em> the <em>Synthetics</em> UI editor to create scripted browsers or API test"
      },
      "id": "60452772196a67195c960f3b"
    }
  ],
  "/docs/telemetry-data-platform/convert-to-metrics/analyze-monitor-data-trends-metrics": [
    {
      "sections": [
        "Creating metric rules: requirements and tips",
        "Metric aggregation",
        "Rule-creation limits",
        "Cardinality limits",
        "Multiple metrics from one rule",
        "Metric naming"
      ],
      "title": "Creating metric rules: requirements and tips",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "2a905f4fc51191fc432fcabfe2657934e052bb5b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/convert-to-metrics/creating-metric-rules-requirements-tips/",
      "published_at": "2021-09-01T22:03:58Z",
      "updated_at": "2021-08-09T00:27:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some limits, requirements, and recommendations when you create metrics from events, logs, or spans. Metric aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate metrics: Function Comments summary Creates a summary metric data point for each time window (currently 1 minute). Use this if your NRQL query uses aggregator functions supported by the summary metric type, such as average, sum, min, or max. Example rule-creation query: SELECT summary(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy uniqueCount Creates a uniqueCount metric data point for each 1-minute time window. Use this if your NRQL query uses the uniqueCount aggregator type. Example rule-creation query: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy distribution Creates a distribution metric data point for each 1-minute time window. Use this if your NRQL query uses aggregator functions such as percentile, histogram, min, max, average, sum, or count. Use only the attribute of interest as the argument, and discard the rest of the arguments from percentile or histogram. The generated metric supports any argument on percentile or histogram. Example of creating a distribution rule: SELECT distribution(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy Simple count: summary(1) and sum If you want a metric that's a simple count of the events, logs, or spans that match a particular WHERE clause, use the summary(1) metric. This metric type counts the number of specified events, logs, or spans per minute. When querying the created metric, use the sum method to see the result. Example: If you want to create a metric named foo.count that counts the transactions named foo, the NRQL would look like this: FROM Transaction SELECT summary(1) AS 'foo.count' WHERE name = 'foo' Copy Then, you would query it like this: FROM Metric SELECT sum(foo.count) SINCE 30 minutes ago Copy For more information about metrics, see our documentation about metric types. Rule-creation limits These limits affect metric rules creation: Limits Comments Account limits An account can have a maximum of 1,000 metric-creation rules. Metric rule limits A rule can: Create a maximum of 10 metrics. Use only one type of data (events, logs, or spans). Select a maximum of 20 attributes (facets) to include on a metric. Time window limits 50K limit on unique metric-name/attribute-value combinations for a single metric in a 24-hour time window. If this limit is exceeded, the rule is disabled and an NrIntegrationError event is created in that account that includes: The rule details A message about having too many facets A newRelicFeature attribute value of eventToMetric Limits on metric name and attribute value combinations The limit on total unique metric name/attribute value combinations in a 24-hour time window for an account is: Equal to three times the purchased monthly average data points per minute Up to a maximum of 10M Cardinality limits Rule-creation limits include limits on the number of unique combinations of metric name and attribute values. This limit exists because a large number of attributes and/or attribute values can lead to an exponential increase in the size of data reported. Example metric creation rule that attaches five attributes: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName, entityName, processId Copy If each of the five attributes reported ten unique values within a one-minute time window, the number of unique metric-name/attribute combinations would theoretically have a maximum of 10x10x10x10x10, or 100,000. Multiple attributes with multiple unique values can lead to a large number of unique metric entries. In practice, this isn't usually the case, because attributes are often related. For example, if one attribute is hostname and another is awsRegion, when you see hostname A, it will always be in AWS region B; you'd never see hostname A and other AWS region values. This is why it's important, during the NRQL creation process, to use the uniqueCount function to verify how many unique metric-name/attribute-value combinations your NRQL query is generating. Multiple metrics from one rule A rule can create up to ten metrics. There are no functional differences between metrics created one at a time and those created with a single rule. Reasons for creating multiple metrics with a single rule: Less likely to reach rules-per-account limit. Easier to add the same attributes to multiple metrics. Example creating multiple metrics with a single rule: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount', summary(duration) AS 'server.duration', summary(totalTime) AS 'server.totalTime' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy Metric naming A metric is given a name with the AS clause, as part of the NRQL rule-creation process. In the following NRQL example, the name of the metric is io.totalread.bytes: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName Copy If there is no name assigned with the AS clause, the metric name is the name of the queried attribute. In this example, if no name was assigned, the metric name would be ioTotalReadBytes. Metric names Requirements and recommendations Requirements Requirements for naming a metric: Less than or equal to 255 (UTF-16) 16-bit code units. One way to ensure you are under the limit is to keep each string under 127 of whatever is easiest to count. No spaces. Start with a letter. Examples of strong metric names: rubyvm.memory.heap_used redis.container.cpu.percent memcached.process_virtual_memory.bytes Length and structure Decide on a name and structure that makes it easy for others to find, understand, and use this metric. We recommend keeping your metric name under 40 characters for ideal readability. Longer names can get cut off or overlap with other names. Your metric naming scheme will depend on your business logic. You may want to use namespaces to prefix your metric name, or your names may need to be more general. Components within the name If you want to create components within your metric name (like the source of metrics and the thing you’re measuring), we recommend going from broad to specific (left to right): Use a dot to separate those components in order to be consistent with our New Relic metric names. Then, use an underscore to separate words within the dots. Example: application.page_view.duration Copy Attributes Avoid putting attributes in your metric name. Attributes are qualities of your metric that you can use to filter or facet your data, like cluster or availability zone. Example: If you included availability zone in your metric name, it would mean, for that metric, you wouldn’t be able to see results across all availability zones. Changing metric names If you change a metric name, historical data will not be updated to that new name. To query or chart that historical data, you will need to specify the older metric name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.31668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "sections": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Here are some limits, requirements, and recommendations when you create <em>metrics</em> from events, logs, or spans. <em>Metric</em> aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate <em>metrics</em>: Function Comments summary Creates a summary <em>metric</em> <em>data</em>"
      },
      "id": "603e9b8164441fbcac4e88a6"
    },
    {
      "sections": [
        "Create metrics from other data types",
        "Create a metrics rule",
        "Step 1. Create NRQL query rule",
        "Tip",
        "Step 2. Create API request",
        "Example NerdGraph API request",
        "Example NerdGraph API response",
        "Step 3. Create a metrics rule with API request",
        "Query and chart your metrics",
        "Summary metric example",
        "Count metric example",
        "Distribution metric example",
        "Troubleshooting"
      ],
      "title": "Create metrics from other data types",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "684976ba0b62b7510db8b856c3f04ea77f9cdcc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/convert-to-metrics/create-metrics-other-data-types/",
      "published_at": "2021-09-01T19:42:47Z",
      "updated_at": "2021-05-15T10:04:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use New Relic's metrics API service to define rules for creating metrics from your other types of data, such as events, logs, or spans. Recommendation: Before you begin, review our requirements and tips for creating rules. Create a metrics rule To create a rule for creating metrics from events, logs, or spans: Construct the metrics rule using NRQL. Construct a NerdGraph (GraphQL format) API request that contains your NRQL rule. Create the metric by making the API request. Once a metric is created, you can query and chart it using NRQL. Step 1. Create NRQL query rule The most important part of creating a metrics rule is constructing the NRQL query that defines the metric for your data from events, logs, or spans. You can create up to 10 metrics with a single NRQL query by following this procedure: Using New Relic's NRQL interface, construct a query for the metric you want to create. For example: FROM ProcessSample SELECT average(ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy Edit the query to use one of the three available metric types: summary: Use if the query's function is min, max, sum, count, or average. uniqueCount: Use if the query's function is uniqueCount. distribution: Use if the query's function is percentile or histogram. This example query uses average, so use summary: FROM ProcessSample SELECT summary (ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy This example query uses count on a non-numeric field: FROM ProcessSample SELECT count(hostname) WHERE hostname LIKE '%prod%' Copy For summary on a non-numeric field use summary(1): FROM ProcessSample SELECT summary(1) WHERE hostname LIKE '%prod%' Copy Tip For more detailed information on using these metric types in rules, see Creating metric rules: requirements and tips. Decide on the attributes you want to attach to the metric, following the limits on the cardinality of unique metric-name/attribute-value combinations. Recommendation: Run a separate query to ensure this count isn't over 50,000 for a 24-hour window. For example: FROM ProcessSample SELECT uniqueCount(awsRegion, awsAvailabilityZone, commandName) WHERE nr.entityType = 'HOST' SINCE 1 DAY AGO Copy To be able to aggregate and filter your metrics, add the attributes you want to attach to the metric using the FACET clause. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Set the name of the metric using the AS function. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Once your NRQL rule is complete, use it to create the API request. Step 2. Create API request After you build the NRQL rule to convert data from events, logs, or spans to metrics, continue with building the API request. You can use our NerdGraph API tool to explore the data structure and to construct and make your request. To check that the rule was created correctly, you can run a query to return that rule using its ID. For tips on querying the metrics you've created, see Query and chart your metrics. Example NerdGraph API request The following example NerdGraph API request uses the same NRQL rule from step 1. The IO Total Read Bytes Rule creates a metric named io.totalread.bytes. (The rule name can have spaces, which differs from the metric naming rules.) mutation { eventsToMetricsCreateRule(rules: { name: \"io.totalread.bytes for computeSample entities\", description:\"Created by Zach on March 27, 2019. Used by team Network.\", nrql:\"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\", accountId: 123456 }) { successes { id name nrql enabled } failures { submitted { name nrql accountId } errors { reason description } } } } Copy In this request: Request elements Description mutation One of the basic API operation types. eventsToMetricsCreateRule The method being called to create a rule. rules Takes four parameters: name: The name of the rule. description: Optional. The description of the rule. We recommend you include information about who created the metric data and who will be using the data. accountId: The New Relic account ID where the events, logs, or spans live and the metrics will be created. nrql: The NRQL query that creates the rule. For more on this, see Create NRQL query. successes and submitted blocks Here you define the data returned by a successful or failed response. Available parameters for these blocks include: id (ruleId for submitted) name description nrql enabled (enabled/disabled status) accountId ruleId and accountId If a failure occurs, then the submitted ruleId and accountId will be returned along with the error reason and error description. Example NerdGraph API response Here's an example of a returned response: { \"data\": { \"eventsToMetricsCreateRule\": { \"failures\": [], \"successes\": [ { \"enabled\": true, \"id\": \"46\", \"name\": \"io.totalread.bytes for computeSample entities\", \"nrql\": \"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\" } ] } } } Copy Step 3. Create a metrics rule with API request When your API request is ready, you can use the NerdGraph API to make the request, which will create the metrics. Query and chart your metrics After you create a metrics rule to convert data for your events, logs, or spans, you can view the new metric data in the New Relic UI. To view your data: Go to New Relic's NRQL query interface. Run the following query to see the name of all your metrics: SELECT uniques(metricName) FROM Metric Copy Pick the metric of interest, then run the following query to see the available attributes: SELECT * FROM Metric where metricName = 'yourMetric' Copy If you don't see expected data, follow the troubleshooting procedures. The available NRQL aggregator functions depend on the metric type you created. Here are some examples. Summary metric example If you created a summary metric type, you can use the count, sum, max, min, and average aggregator functions, as shown in the following query: SELECT count(appStartResponseTime), sum(appStartResponseTime), max(appStartResponseTime), min(appStartResponseTime), average(appStartResponseTime) FROM Metric Copy Count metric example If you created a uniqueCount metric type, you can only use the uniqueCount function, as shown in the following query: SELECT uniqueCount(playbackErrorStreamUniqueCount) * 100 / uniqueCount(streamUniqueCount) AS '% of Streams Impacted' FROM Metric Copy Distribution metric example If you created a distribution metric type, use the percentile or histogram functions, as shown in the following queries: SELECT percentile(service.responseTime, 95) FROM Metric Copy OR SELECT histogram(service.responseTime, 10, 20) FROM Metric Copy Troubleshooting If your NerdGraph call is not constructed correctly, you may receive a message like this: Cannot parse the unexpected character \"\\u201C” Copy Verify the quotes in the NerdGraph call are not smart quotes (curly quotes). Our NerdGraph API only accepts straight quotes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.04138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>metrics</em> from other <em>data</em> types",
        "sections": "Create <em>metrics</em> from other <em>data</em> types",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " the NerdGraph API to make the request, which will create the <em>metrics</em>. Query and chart your <em>metrics</em> After you create a <em>metrics</em> rule to <em>convert</em> <em>data</em> for your events, logs, or spans, you can view the new <em>metric</em> <em>data</em> in the New Relic UI. To view your <em>data</em>: Go to New Relic&#x27;s NRQL query interface. Run the following"
      },
      "id": "603ebfc8196a67cab0a83d96"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.39365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the <em>Metric</em> API",
        "sections": "Alert on <em>metric</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The <em>Metric</em> API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> APIs. The <em>Metric</em> API can be used to: Report <em>metric</em> <em>data</em> to New Relic without a New Relic agent. Integrate <em>metric</em> <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    }
  ],
  "/docs/telemetry-data-platform/convert-to-metrics/create-metrics-other-data-types": [
    {
      "sections": [
        "Creating metric rules: requirements and tips",
        "Metric aggregation",
        "Rule-creation limits",
        "Cardinality limits",
        "Multiple metrics from one rule",
        "Metric naming"
      ],
      "title": "Creating metric rules: requirements and tips",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "2a905f4fc51191fc432fcabfe2657934e052bb5b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/convert-to-metrics/creating-metric-rules-requirements-tips/",
      "published_at": "2021-09-01T22:03:58Z",
      "updated_at": "2021-08-09T00:27:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some limits, requirements, and recommendations when you create metrics from events, logs, or spans. Metric aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate metrics: Function Comments summary Creates a summary metric data point for each time window (currently 1 minute). Use this if your NRQL query uses aggregator functions supported by the summary metric type, such as average, sum, min, or max. Example rule-creation query: SELECT summary(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy uniqueCount Creates a uniqueCount metric data point for each 1-minute time window. Use this if your NRQL query uses the uniqueCount aggregator type. Example rule-creation query: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy distribution Creates a distribution metric data point for each 1-minute time window. Use this if your NRQL query uses aggregator functions such as percentile, histogram, min, max, average, sum, or count. Use only the attribute of interest as the argument, and discard the rest of the arguments from percentile or histogram. The generated metric supports any argument on percentile or histogram. Example of creating a distribution rule: SELECT distribution(duration) AS 'service.responseTime' FROM Transaction WHERE appName = 'Data Points Staging' FACET name, appName, host Copy Simple count: summary(1) and sum If you want a metric that's a simple count of the events, logs, or spans that match a particular WHERE clause, use the summary(1) metric. This metric type counts the number of specified events, logs, or spans per minute. When querying the created metric, use the sum method to see the result. Example: If you want to create a metric named foo.count that counts the transactions named foo, the NRQL would look like this: FROM Transaction SELECT summary(1) AS 'foo.count' WHERE name = 'foo' Copy Then, you would query it like this: FROM Metric SELECT sum(foo.count) SINCE 30 minutes ago Copy For more information about metrics, see our documentation about metric types. Rule-creation limits These limits affect metric rules creation: Limits Comments Account limits An account can have a maximum of 1,000 metric-creation rules. Metric rule limits A rule can: Create a maximum of 10 metrics. Use only one type of data (events, logs, or spans). Select a maximum of 20 attributes (facets) to include on a metric. Time window limits 50K limit on unique metric-name/attribute-value combinations for a single metric in a 24-hour time window. If this limit is exceeded, the rule is disabled and an NrIntegrationError event is created in that account that includes: The rule details A message about having too many facets A newRelicFeature attribute value of eventToMetric Limits on metric name and attribute value combinations The limit on total unique metric name/attribute value combinations in a 24-hour time window for an account is: Equal to three times the purchased monthly average data points per minute Up to a maximum of 10M Cardinality limits Rule-creation limits include limits on the number of unique combinations of metric name and attribute values. This limit exists because a large number of attributes and/or attribute values can lead to an exponential increase in the size of data reported. Example metric creation rule that attaches five attributes: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName, entityName, processId Copy If each of the five attributes reported ten unique values within a one-minute time window, the number of unique metric-name/attribute combinations would theoretically have a maximum of 10x10x10x10x10, or 100,000. Multiple attributes with multiple unique values can lead to a large number of unique metric entries. In practice, this isn't usually the case, because attributes are often related. For example, if one attribute is hostname and another is awsRegion, when you see hostname A, it will always be in AWS region B; you'd never see hostname A and other AWS region values. This is why it's important, during the NRQL creation process, to use the uniqueCount function to verify how many unique metric-name/attribute-value combinations your NRQL query is generating. Multiple metrics from one rule A rule can create up to ten metrics. There are no functional differences between metrics created one at a time and those created with a single rule. Reasons for creating multiple metrics with a single rule: Less likely to reach rules-per-account limit. Easier to add the same attributes to multiple metrics. Example creating multiple metrics with a single rule: FROM Transaction SELECT uniqueCount(request.headers.userAgent) AS 'server.request.header.userAgent.uniqueCount', summary(duration) AS 'server.duration', summary(totalTime) AS 'server.totalTime' WHERE appName = 'Browser Monitoring Router' FACET httpResponseCode, name, appName, host Copy Metric naming A metric is given a name with the AS clause, as part of the NRQL rule-creation process. In the following NRQL example, the name of the metric is io.totalread.bytes: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName Copy If there is no name assigned with the AS clause, the metric name is the name of the queried attribute. In this example, if no name was assigned, the metric name would be ioTotalReadBytes. Metric names Requirements and recommendations Requirements Requirements for naming a metric: Less than or equal to 255 (UTF-16) 16-bit code units. One way to ensure you are under the limit is to keep each string under 127 of whatever is easiest to count. No spaces. Start with a letter. Examples of strong metric names: rubyvm.memory.heap_used redis.container.cpu.percent memcached.process_virtual_memory.bytes Length and structure Decide on a name and structure that makes it easy for others to find, understand, and use this metric. We recommend keeping your metric name under 40 characters for ideal readability. Longer names can get cut off or overlap with other names. Your metric naming scheme will depend on your business logic. You may want to use namespaces to prefix your metric name, or your names may need to be more general. Components within the name If you want to create components within your metric name (like the source of metrics and the thing you’re measuring), we recommend going from broad to specific (left to right): Use a dot to separate those components in order to be consistent with our New Relic metric names. Then, use an underscore to separate words within the dots. Example: application.page_view.duration Copy Attributes Avoid putting attributes in your metric name. Attributes are qualities of your metric that you can use to filter or facet your data, like cluster or availability zone. Example: If you included availability zone in your metric name, it would mean, for that metric, you wouldn’t be able to see results across all availability zones. Changing metric names If you change a metric name, historical data will not be updated to that new name. To query or chart that historical data, you will need to specify the older metric name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.31668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "sections": "Creating <em>metric</em> rules: requirements <em>and</em> tips",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Here are some limits, requirements, and recommendations when you create <em>metrics</em> from events, logs, or spans. <em>Metric</em> aggregation Your NRQL query must use one of the following summary, uniqueCount, or distribution functions to aggregate <em>metrics</em>: Function Comments summary Creates a summary <em>metric</em> <em>data</em>"
      },
      "id": "603e9b8164441fbcac4e88a6"
    },
    {
      "sections": [
        "Analyze and monitor data trends with metrics",
        "Why create metrics from other data types?",
        "Available operations",
        "Mutations",
        "Create a rule",
        "Delete a rule",
        "Important",
        "Enable or disable a rule",
        "Queries",
        "List all rules for a New Relic account",
        "List rule by rule ID",
        "Use the NerdGraph GraphiQL API tool"
      ],
      "title": "Analyze and monitor data trends with metrics",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "e1cd71a03a83816741471dae4423128472e10fb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/convert-to-metrics/analyze-monitor-data-trends-metrics/",
      "published_at": "2021-09-01T22:03:58Z",
      "updated_at": "2021-05-15T10:06:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can generate metric-type data from other types of data in New Relic, including events, logs, and spans. Metrics are aggregates of your data and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How to use our NerdGraph API tool to perform operations Why create metrics from other data types? Using metrics allows for more efficient data storage. This in turn allows you to query your data and build charts more easily. The difference between metrics and other types of data in New Relic is based on time. For more information, see Understand data types. Events, logs, spans: These types of data represent a single record at a specific moment in time. For example, you may have an event for every request to the system. This data is ideal for in-depth troubleshooting and analysis. Metrics: These provide an aggregated view of your events, logs, or spans. Metrics are better for showing trends over longer time ranges. For example, you can aggregate the total number of requests per service to one metric and then examine this information month over month. Why use metrics? Comments Flexibility Metrics are dimensional. You can choose what metadata (like host name or app name) is attached to them. Common metric measurements, like average, sum, minimum, and maximum, are already calculated. Data aggregation and retention The data has already been pre-aggregated into longer-period time buckets. Data retention is 13 months. Query capabilities You can query using the Metric data type. When you create metrics, this does not delete your events or other types of data. However, metrics are better for longer-range querying and charting. To get started converting your data to metrics, create a rule. Available operations To show, create, and delete rules for generating metrics from events, logs, or spans, use NerdGraph, our GraphQL-format API. Before performing any operation, we recommend reading Intro to NerdGraph and exploring your data with the GraphiQL API tool. These operations fall under two basic request types: Mutations, which are operations that make changes to existing rules or settings (for example, creating a new metrics rule). Queries, for fetching existing data (for example, fetching existing metrics rules). All operations are role-based in NerdGraph as the currently logged-in New Relic user. Mutations Mutation operations for events to metrics, logs to metrics, or spans to metrics include: Create a rule See Create metrics. Delete a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To delete a rule, you need the rule ID and the New Relic account ID. Example request: mutation { eventsToMetricsDeleteRule(deletes: {ruleId: \"12\", accountId: 123456}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsDeleteRule The method being called to delete a rule. deletes This takes two parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Example response for the request: { \"data\": { \"eventsToMetricsDeleteRule\": { \"failures\": [], \"successes\": [ { \"id\": \"12\", \"name\": \"Test Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } Copy Enable or disable a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To enable or disable an existing rule for events to metrics, logs to metrics, or spans to metrics, use the same eventsToMetricsUpdateRule operation. The only difference is whether enabled is set to true or false. Example request to enable an existing metrics rule: mutation { eventsToMetricsUpdateRule(updates: {ruleId: \"12\", accountId: 123456, enabled: true}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsUpdateRule The method being called to update an existing rule and either enable it or disable it. updates This takes three required parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. enabled: To enable a disabled rule, set this to true. To disable a rule, set this to false. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Queries Query operations include: List all rules for a New Relic account You can list all rules in a New Relic account or return a specific rule. Example listing all rules for account 123456: query { actor { account(id:123456) { eventsToMetrics{ allRules{ rules{ id name enabled nrql description } } } } } } Copy In this request: Element Description query One of the basic API operation types. Used to query but not make changes. actor This specifies the current New Relic user. account(id: 123456) Specify the ID for the New Relic account where to retrieve data. eventsToMetrics Scope the data only for events-to-metrics, logs-to-metrics, or spans-to-metrics rules. allRules Returns all rules for that account. rules In the rules block, you can define what data you want returned. Available fields include: id name description nrql accountId enabled Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"allRules\": { \"rules\": [ { \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"1\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" }, { \"description\": \"Metric for duration\", \"enabled\": true, \"id\": \"2\", \"name\": \"Duration Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy List rule by rule ID If you know the exact ID for a rule, then you can query for a specific rule. For example, you may have just created a rule and now you want to list its contents so you can review it. Example listing rule 36 for New Relic account 123456: query { actor { account(id: 123456) { eventsToMetrics { rulesById(ruleIds: \"36\") { rules { id name enabled nrql description accountId } } } } } } Copy For more details about the elements in this query, see List all rules. Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"rulesById\": { \"rules\": [ { \"accountId\": 123456, \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"36\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy Use the NerdGraph GraphiQL API tool You can use our GraphiQL tool to explore the data structure. You can also use it to build and run the operations to convert events, logs, and spans to metrics. To use this tool: Create the metrics operation's request with the required parameters. Go to api.newrelic.com/graphiql, and paste your query into the box. To execute the operation, press Play. Or, to get the cURL format, select Copy as cURL.) Validate the response in the response box. Optional: To verify that your rule-creation operation was performed successfully, run a list query for that rule ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.04156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "sections": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "You can generate <em>metric</em>-type <em>data</em> from other types of <em>data</em> in New Relic, including events, logs, and spans. <em>Metrics</em> are aggregates of your <em>data</em> and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How"
      },
      "id": "603eb239e7b9d2b99d2a07bb"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.39365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the <em>Metric</em> API",
        "sections": "Alert on <em>metric</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The <em>Metric</em> API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> APIs. The <em>Metric</em> API can be used to: Report <em>metric</em> <em>data</em> to New Relic without a New Relic agent. Integrate <em>metric</em> <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    }
  ],
  "/docs/telemetry-data-platform/convert-to-metrics/creating-metric-rules-requirements-tips": [
    {
      "sections": [
        "Analyze and monitor data trends with metrics",
        "Why create metrics from other data types?",
        "Available operations",
        "Mutations",
        "Create a rule",
        "Delete a rule",
        "Important",
        "Enable or disable a rule",
        "Queries",
        "List all rules for a New Relic account",
        "List rule by rule ID",
        "Use the NerdGraph GraphiQL API tool"
      ],
      "title": "Analyze and monitor data trends with metrics",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "e1cd71a03a83816741471dae4423128472e10fb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/convert-to-metrics/analyze-monitor-data-trends-metrics/",
      "published_at": "2021-09-01T22:03:58Z",
      "updated_at": "2021-05-15T10:06:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can generate metric-type data from other types of data in New Relic, including events, logs, and spans. Metrics are aggregates of your data and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How to use our NerdGraph API tool to perform operations Why create metrics from other data types? Using metrics allows for more efficient data storage. This in turn allows you to query your data and build charts more easily. The difference between metrics and other types of data in New Relic is based on time. For more information, see Understand data types. Events, logs, spans: These types of data represent a single record at a specific moment in time. For example, you may have an event for every request to the system. This data is ideal for in-depth troubleshooting and analysis. Metrics: These provide an aggregated view of your events, logs, or spans. Metrics are better for showing trends over longer time ranges. For example, you can aggregate the total number of requests per service to one metric and then examine this information month over month. Why use metrics? Comments Flexibility Metrics are dimensional. You can choose what metadata (like host name or app name) is attached to them. Common metric measurements, like average, sum, minimum, and maximum, are already calculated. Data aggregation and retention The data has already been pre-aggregated into longer-period time buckets. Data retention is 13 months. Query capabilities You can query using the Metric data type. When you create metrics, this does not delete your events or other types of data. However, metrics are better for longer-range querying and charting. To get started converting your data to metrics, create a rule. Available operations To show, create, and delete rules for generating metrics from events, logs, or spans, use NerdGraph, our GraphQL-format API. Before performing any operation, we recommend reading Intro to NerdGraph and exploring your data with the GraphiQL API tool. These operations fall under two basic request types: Mutations, which are operations that make changes to existing rules or settings (for example, creating a new metrics rule). Queries, for fetching existing data (for example, fetching existing metrics rules). All operations are role-based in NerdGraph as the currently logged-in New Relic user. Mutations Mutation operations for events to metrics, logs to metrics, or spans to metrics include: Create a rule See Create metrics. Delete a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To delete a rule, you need the rule ID and the New Relic account ID. Example request: mutation { eventsToMetricsDeleteRule(deletes: {ruleId: \"12\", accountId: 123456}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsDeleteRule The method being called to delete a rule. deletes This takes two parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Example response for the request: { \"data\": { \"eventsToMetricsDeleteRule\": { \"failures\": [], \"successes\": [ { \"id\": \"12\", \"name\": \"Test Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } Copy Enable or disable a rule Important This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To enable or disable an existing rule for events to metrics, logs to metrics, or spans to metrics, use the same eventsToMetricsUpdateRule operation. The only difference is whether enabled is set to true or false. Example request to enable an existing metrics rule: mutation { eventsToMetricsUpdateRule(updates: {ruleId: \"12\", accountId: 123456, enabled: true}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Copy In this request: Element Description mutation One of the basic API operation types. eventsToMetricsUpdateRule The method being called to update an existing rule and either enable it or disable it. updates This takes three required parameters: ruleId: The ID of the rule for events to metrics, logs to metrics, or spans to metrics. accountId: The New Relic account ID. enabled: To enable a disabled rule, set this to true. To disable a rule, set this to false. successes and submitted blocks Here you define the data returned by a success or failure. Available parameters for these blocks: id (or ruleId for submitted) name description nrql enabled accountId Queries Query operations include: List all rules for a New Relic account You can list all rules in a New Relic account or return a specific rule. Example listing all rules for account 123456: query { actor { account(id:123456) { eventsToMetrics{ allRules{ rules{ id name enabled nrql description } } } } } } Copy In this request: Element Description query One of the basic API operation types. Used to query but not make changes. actor This specifies the current New Relic user. account(id: 123456) Specify the ID for the New Relic account where to retrieve data. eventsToMetrics Scope the data only for events-to-metrics, logs-to-metrics, or spans-to-metrics rules. allRules Returns all rules for that account. rules In the rules block, you can define what data you want returned. Available fields include: id name description nrql accountId enabled Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"allRules\": { \"rules\": [ { \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"1\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" }, { \"description\": \"Metric for duration\", \"enabled\": true, \"id\": \"2\", \"name\": \"Duration Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy List rule by rule ID If you know the exact ID for a rule, then you can query for a specific rule. For example, you may have just created a rule and now you want to list its contents so you can review it. Example listing rule 36 for New Relic account 123456: query { actor { account(id: 123456) { eventsToMetrics { rulesById(ruleIds: \"36\") { rules { id name enabled nrql description accountId } } } } } } Copy For more details about the elements in this query, see List all rules. Example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"rulesById\": { \"rules\": [ { \"accountId\": 123456, \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"36\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Copy Use the NerdGraph GraphiQL API tool You can use our GraphiQL tool to explore the data structure. You can also use it to build and run the operations to convert events, logs, and spans to metrics. To use this tool: Create the metrics operation's request with the required parameters. Go to api.newrelic.com/graphiql, and paste your query into the box. To execute the operation, press Play. Or, to get the cURL format, select Copy as cURL.) Validate the response in the response box. Optional: To verify that your rule-creation operation was performed successfully, run a list query for that rule ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.04156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "sections": "Analyze <em>and</em> monitor <em>data</em> trends with <em>metrics</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "You can generate <em>metric</em>-type <em>data</em> from other types of <em>data</em> in New Relic, including events, logs, and spans. <em>Metrics</em> are aggregates of your <em>data</em> and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How"
      },
      "id": "603eb239e7b9d2b99d2a07bb"
    },
    {
      "sections": [
        "Create metrics from other data types",
        "Create a metrics rule",
        "Step 1. Create NRQL query rule",
        "Tip",
        "Step 2. Create API request",
        "Example NerdGraph API request",
        "Example NerdGraph API response",
        "Step 3. Create a metrics rule with API request",
        "Query and chart your metrics",
        "Summary metric example",
        "Count metric example",
        "Distribution metric example",
        "Troubleshooting"
      ],
      "title": "Create metrics from other data types",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Convert data to metrics"
      ],
      "external_id": "684976ba0b62b7510db8b856c3f04ea77f9cdcc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/convert-to-metrics/create-metrics-other-data-types/",
      "published_at": "2021-09-01T19:42:47Z",
      "updated_at": "2021-05-15T10:04:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use New Relic's metrics API service to define rules for creating metrics from your other types of data, such as events, logs, or spans. Recommendation: Before you begin, review our requirements and tips for creating rules. Create a metrics rule To create a rule for creating metrics from events, logs, or spans: Construct the metrics rule using NRQL. Construct a NerdGraph (GraphQL format) API request that contains your NRQL rule. Create the metric by making the API request. Once a metric is created, you can query and chart it using NRQL. Step 1. Create NRQL query rule The most important part of creating a metrics rule is constructing the NRQL query that defines the metric for your data from events, logs, or spans. You can create up to 10 metrics with a single NRQL query by following this procedure: Using New Relic's NRQL interface, construct a query for the metric you want to create. For example: FROM ProcessSample SELECT average(ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy Edit the query to use one of the three available metric types: summary: Use if the query's function is min, max, sum, count, or average. uniqueCount: Use if the query's function is uniqueCount. distribution: Use if the query's function is percentile or histogram. This example query uses average, so use summary: FROM ProcessSample SELECT summary (ioTotalReadBytes) WHERE nr.entityType = 'HOST' Copy This example query uses count on a non-numeric field: FROM ProcessSample SELECT count(hostname) WHERE hostname LIKE '%prod%' Copy For summary on a non-numeric field use summary(1): FROM ProcessSample SELECT summary(1) WHERE hostname LIKE '%prod%' Copy Tip For more detailed information on using these metric types in rules, see Creating metric rules: requirements and tips. Decide on the attributes you want to attach to the metric, following the limits on the cardinality of unique metric-name/attribute-value combinations. Recommendation: Run a separate query to ensure this count isn't over 50,000 for a 24-hour window. For example: FROM ProcessSample SELECT uniqueCount(awsRegion, awsAvailabilityZone, commandName) WHERE nr.entityType = 'HOST' SINCE 1 DAY AGO Copy To be able to aggregate and filter your metrics, add the attributes you want to attach to the metric using the FACET clause. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Set the name of the metric using the AS function. For example: FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'HOST' FACET awsRegion, awsAvailabilityZone, commandName Copy Once your NRQL rule is complete, use it to create the API request. Step 2. Create API request After you build the NRQL rule to convert data from events, logs, or spans to metrics, continue with building the API request. You can use our NerdGraph API tool to explore the data structure and to construct and make your request. To check that the rule was created correctly, you can run a query to return that rule using its ID. For tips on querying the metrics you've created, see Query and chart your metrics. Example NerdGraph API request The following example NerdGraph API request uses the same NRQL rule from step 1. The IO Total Read Bytes Rule creates a metric named io.totalread.bytes. (The rule name can have spaces, which differs from the metric naming rules.) mutation { eventsToMetricsCreateRule(rules: { name: \"io.totalread.bytes for computeSample entities\", description:\"Created by Zach on March 27, 2019. Used by team Network.\", nrql:\"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\", accountId: 123456 }) { successes { id name nrql enabled } failures { submitted { name nrql accountId } errors { reason description } } } } Copy In this request: Request elements Description mutation One of the basic API operation types. eventsToMetricsCreateRule The method being called to create a rule. rules Takes four parameters: name: The name of the rule. description: Optional. The description of the rule. We recommend you include information about who created the metric data and who will be using the data. accountId: The New Relic account ID where the events, logs, or spans live and the metrics will be created. nrql: The NRQL query that creates the rule. For more on this, see Create NRQL query. successes and submitted blocks Here you define the data returned by a successful or failed response. Available parameters for these blocks include: id (ruleId for submitted) name description nrql enabled (enabled/disabled status) accountId ruleId and accountId If a failure occurs, then the submitted ruleId and accountId will be returned along with the error reason and error description. Example NerdGraph API response Here's an example of a returned response: { \"data\": { \"eventsToMetricsCreateRule\": { \"failures\": [], \"successes\": [ { \"enabled\": true, \"id\": \"46\", \"name\": \"io.totalread.bytes for computeSample entities\", \"nrql\": \"FROM ProcessSample SELECT summary(ioTotalReadBytes) AS 'io.totalread.bytes' WHERE nr.entityType = 'ComputeSample' FACET awsRegion, awsAvailabilityZone, commandName\" } ] } } } Copy Step 3. Create a metrics rule with API request When your API request is ready, you can use the NerdGraph API to make the request, which will create the metrics. Query and chart your metrics After you create a metrics rule to convert data for your events, logs, or spans, you can view the new metric data in the New Relic UI. To view your data: Go to New Relic's NRQL query interface. Run the following query to see the name of all your metrics: SELECT uniques(metricName) FROM Metric Copy Pick the metric of interest, then run the following query to see the available attributes: SELECT * FROM Metric where metricName = 'yourMetric' Copy If you don't see expected data, follow the troubleshooting procedures. The available NRQL aggregator functions depend on the metric type you created. Here are some examples. Summary metric example If you created a summary metric type, you can use the count, sum, max, min, and average aggregator functions, as shown in the following query: SELECT count(appStartResponseTime), sum(appStartResponseTime), max(appStartResponseTime), min(appStartResponseTime), average(appStartResponseTime) FROM Metric Copy Count metric example If you created a uniqueCount metric type, you can only use the uniqueCount function, as shown in the following query: SELECT uniqueCount(playbackErrorStreamUniqueCount) * 100 / uniqueCount(streamUniqueCount) AS '% of Streams Impacted' FROM Metric Copy Distribution metric example If you created a distribution metric type, use the percentile or histogram functions, as shown in the following queries: SELECT percentile(service.responseTime, 95) FROM Metric Copy OR SELECT histogram(service.responseTime, 10, 20) FROM Metric Copy Troubleshooting If your NerdGraph call is not constructed correctly, you may receive a message like this: Cannot parse the unexpected character \"\\u201C” Copy Verify the quotes in the NerdGraph call are not smart quotes (curly quotes). Our NerdGraph API only accepts straight quotes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.04138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>metrics</em> from other <em>data</em> types",
        "sections": "Create <em>metrics</em> from other <em>data</em> types",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " the NerdGraph API to make the request, which will create the <em>metrics</em>. Query and chart your <em>metrics</em> After you create a <em>metrics</em> rule to <em>convert</em> <em>data</em> for your events, logs, or spans, you can view the new <em>metric</em> <em>data</em> in the New Relic UI. To view your <em>data</em>: Go to New Relic&#x27;s NRQL query interface. Run the following"
      },
      "id": "603ebfc8196a67cab0a83d96"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.39365,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the <em>Metric</em> API",
        "sections": "Alert on <em>metric</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The <em>Metric</em> API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> APIs. The <em>Metric</em> API can be used to: Report <em>metric</em> <em>data</em> to New Relic without a New Relic agent. Integrate <em>metric</em> <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    }
  ],
  "/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "46f2be93b0c4daf40da9b93cfe0fbf5f235eecb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-07-16T03:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.31334,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ", timeseries, until, week, weeks, where, with <em>Event</em> type limits The current limit for total number of <em>event</em>Type values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: Default <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from <em>Insights</em> <em>custom</em> <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.14124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser API&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "30a7ec0f78ddde237cb20265ab9702582f5bc2ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:48:22Z",
      "updated_at": "2021-07-09T22:19:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.11409,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Mobile monitoring in New Relic sends some default <em>event</em> <em>data</em> from your mobile app to New Relic, such as <em>data</em> about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> attributes and <em>events</em> for more detailed querying and analysis. Create <em>custom</em> attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    }
  ],
  "/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data": [
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.14124,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser API&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "30a7ec0f78ddde237cb20265ab9702582f5bc2ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:48:22Z",
      "updated_at": "2021-07-09T22:19:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.11409,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Mobile monitoring in New Relic sends some default <em>event</em> <em>data</em> from your mobile app to New Relic, such as <em>data</em> about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> attributes and <em>events</em> for more detailed querying and analysis. Create <em>custom</em> attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.1113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ". Record <em>custom</em> <em>events</em> and attributes You can add your own <em>custom</em> APM <em>events</em> and attributes, which you can then use for querying and charting. This is one of several ways to report <em>custom</em> <em>data</em>. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> attributes"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "46f2be93b0c4daf40da9b93cfe0fbf5f235eecb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-07-16T03:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.31332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ", timeseries, until, week, weeks, where, with <em>Event</em> type limits The current limit for total number of <em>event</em>Type values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: Default <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from <em>Insights</em> <em>custom</em> <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "30a7ec0f78ddde237cb20265ab9702582f5bc2ba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:48:22Z",
      "updated_at": "2021-07-09T22:19:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.11409,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report mobile monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Mobile monitoring in New Relic sends some default <em>event</em> <em>data</em> from your mobile app to New Relic, such as <em>data</em> about interactions, sessions, crashes, and request errors. You can also create your own <em>custom</em> attributes and <em>events</em> for more detailed querying and analysis. Create <em>custom</em> attributes"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.1113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ". Record <em>custom</em> <em>events</em> and attributes You can add your own <em>custom</em> APM <em>events</em> and attributes, which you can then use for querying and charting. This is one of several ways to report <em>custom</em> <em>data</em>. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> attributes"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/telemetry-data-platform/custom-data/custom-events/report-custom-event-data": [
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 778.6836,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: <em>Report</em> <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "sections": "APM: <em>Report</em> <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": ". Record <em>custom</em> <em>events</em> and <em>attributes</em> You can add your own <em>custom</em> APM <em>events</em> and <em>attributes</em>, which you can then use for querying and charting. This is one of several ways to <em>report</em> <em>custom</em> data. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> <em>attributes</em>"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    },
    {
      "sections": [
        "iOS SDK API guide",
        "Caution",
        "Install the SDK",
        "Automatically instrumented classes and methods",
        "Instrument your Objective-C code",
        "Important",
        "Create and complete interactions",
        "Rename a default interaction",
        "Set a custom application version",
        "Set a custom build identifier",
        "Create custom metrics",
        "Objective-C: Report custom attributes and events",
        "Objective-C: Track custom network requests",
        "Instrument your Swift code",
        "Create and complete Swift interactions",
        "Rename a default Swift interaction",
        "Set a custom application version with Swift",
        "Set a custom build identifier with Swift",
        "Create custom metrics with Swift",
        "Swift: Report custom attributes and events",
        "Swift: Track custom network requests"
      ],
      "title": "iOS SDK API guide",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "API guides"
      ],
      "external_id": "fe6ba3196a927fb8dee72f8bf777461c95f7505c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/api-guides/ios-sdk-api-guide/",
      "published_at": "2021-09-01T17:29:38Z",
      "updated_at": "2021-07-09T15:39:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the iOS SDK API to add custom data. For example: Instrument your own code. Start and stop interaction traces from events in your mobile app. Record custom metrics. Send custom attributes and events to Insights. Track networking from libraries not supported automatically. Set a custom identifier value with Objective-C or Swift to associate user sessions with analysis events and attributes (iOS SDK version 5.9.0 or higher). Caution Tracing is heavily optimized, but it does impose a performance overhead. Avoid instrumenting methods that are expected to be called hundreds of times. Install the SDK Ensure you have your app instrumented with the latest iOS SDK by going to one.newrelic.com > Add more data and following the instructions for iOS. This document contains the iOS SDK instrumentation requirements for: Objective C Swift For details about the available methods for custom attributes and events you can send to to New Relic Insights, see the iOS SDK API reference. You can also configure feature flags for: Objective-C Swift Automatically instrumented classes and methods The following methods (for the listed classes and their sub-classes) are already instrumented by New Relic. You do not need to add custom instrumentation to trace them. Classes Methods automatically instrumented by New Relic UIViewController viewDidLoad: viewWillAppear: viewDidAppear: viewWillDisappear: viewDidDisappear: viewWillLayoutSubviews: viewDidLayoutSubviews: UIImage imageNamed: imageWithContentsOfFile: imageWithData: imageWithData:scale: initWithContentsOfFile: initWithData: initWithData:scale: NSJSONSerialization JSONObjectWithData:options:error: JSONObjectWithStream:options:error: dataWithJSONObject:options:error: writeJSONObject:toStream:options:error: NSManagedObjectContext executeFetchRequest:error: processPendingChanges The agent aggregates performance for various methods into summary metrics that appear in the Interactions page. Summary categories include: View loading UI layout Database Images JSON Network Instrument your Objective-C code To have your own Objective-C code appear in interaction code breakdowns and timelines, add a _START call to the beginning of your method and a _STOP call to the end of it. Important Always include a _STOP for each _START, and only include one set of these commands in a given method. The trace system will automatically pick up the class and method name, and report performance metrics for your method to New Relic. - (void)myMethod { NR_TRACE_METHOD_START(0); // … existing code NR_TRACE_METHOD_STOP; } Copy If you are not using ARC, use this version of the _STOP macro to avoid memory leaks: NR_NONARC_TRACE_METHOD_STOP; Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the _START macro; for example: NR_TRACE_METHOD_START(NRTraceTypeDatabase); Copy Create and complete interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction with Objective-C, use these API calls: NSString* uniqueIdentifier = NR_START_NAMED_INTERACTION(@\"name\"); Copy This macro will automatically begin tracking the name interaction trace from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NR_INTERACTION_STOP(uniqueIdentifier); Copy This macro will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names with Objective-C, implement the - (NSString*) customNewRelicInteractionName instance method in your view controller, where the string returned becomes the interaction's name. Set a custom application version The New Relic iOS SDK allows you to set a custom application version string with Objective-C. Instead of using the string defined in CFBundleShortVersionString, call the +[NewRelic setApplicationVersion:] method and pass along the custom application version before calling +[NewRelic startWithApplicationToken:]; [NewRelic setApplicationVersion:(NSString*) appVersion]; Copy Set a custom build identifier As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode with Objective-C, call the +[NewRelic setApplicationBuild:] method, and pass along the custom build identifier. [NewRelic setApplicationBuild:(NSString*) buildNumber]; Copy Create custom metrics Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Objective-C: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Objective-C, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Objective-C: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: [NewRelic noticeNetworkRequestForURL:(NSURL*)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer responseHeaders:(NSDictionary *)headers statusCode:(NSInteger)httpStatusCode bytesSent:(NSUInteger)bytesSent bytesReceived:(NSUInteger)bytesReceived responseData:(NSData *)responseData andParams:(NSDictionary *)params]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: [NewRelic noticeNetworkFailureForURL:(NSURL *)url httpMethod:(NSString*)httpMethod withTimer:(NRTimer *)timer andFailureCode:(NSInteger)iOSFailureCode]; Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h. Instrument your Swift code To have your own Swift code appear in interaction code breakdowns and timelines: Add a startTracingMethod() call to the beginning of your method. Add a endTracingMethodWithTimer() call to the end of it. Always include an endTracingMethodWithTimer() call for each startTracingMethod() reference. Include only one set of these commands in a given method. func myMethod(){ let timer = NRTimer(); NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeNone) // … existing code NewRelic.endTracingMethodWithTimer(timer) } Copy If you want your method’s performance to be included in the summary data on the APM Overview page, pass one of the NRTraceType enum values into the startTracingMethod() macro; for example: NewRelic.startTracingMethod(#selector(MyClass.myMethod), object: self, timer: timer, category: NRTraceTypeDatabase) Copy Create and complete Swift interactions By default, an interaction starts when a view controller is pushed. To manually start an interaction, use these API calls: let uniqueIdentifier = NewRelic.startInteraction(withName: \"My Interaction\") Copy This call will automatically begin tracking an interaction trace named My Interaction from the current line. It will also complete any previously running interaction. It returns a unique identifier that can be used to complete that interaction by using this API call: NewRelic.stopCurrentInteraction(uniqueIdentifier) Copy This method will complete the interaction associated with the uniqueIdentifier if that interaction has not already completed automatically. You do not need to call this method. Rename a default Swift interaction By default, the iOS agent will start an interaction trace when a new view controller is displayed. The interactions are named using the format Display <ViewController>. To change these default names, implement the @objc func customNewRelicInteractionName() -> String method in your view controller, where the string returned becomes the interaction's name. Set a custom application version with Swift The New Relic iOS SDK allows you to set a custom application version string. Instead of using the string defined in CFBundleShortVersionString, call the NewRelic.setApplicationVersion() method, and pass along the custom application version before calling NewRelic.startWithApplicationToken();. NewRelic.setApplicationVersion(String appVersion) Copy Set a custom build identifier with Swift As of version 5.1.0 of the New Relic iOS SDK, an API method allows you to set a custom build identifier that is displayed next to the application version in the Crash details page. Instead of using the CFBundleVersion string defined in Xcode, call the NewRelic.setApplicationBuild() method, and pass along the custom build identifier. NewRelic.setApplicationBuild(buildNumber) Copy Create custom metrics with Swift Custom metrics can help track high level events specific to your application. With the recordMetric API, you can record arbitrary numerical data and named events with Objective-C and Swift. You can also use several API calls to record custom metrics that provide different levels of detail. Swift: Report custom attributes and events Use methods in the NewRelic object to report custom attributes and events. For details about the available methods for custom attributes and events with Swift, see the iOS SDK API reference. Methods that return BOOL results return YES if they succeed, or NO if the operation did not complete. These methods are available in versions 5.0.0 or higher of the New Relic iOS SDK. The SDK can store up to 128 user-defined custom attributes at a time. If you attempt to store more than 128 attributes, the SDK returns NO. Custom attributes names should use the simplest format needed, and New Relic recommends single word attributes, containing no spaces. Attribute phrases can be formatted in camel case, so My Custom Attribute is better specified as myCustomAttribute. As with custom metrics: Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. Swift: Track custom network requests If you can express a transactional network request in terms similar to an HTTP request, you can track it. Use URLs that are well-formed and do not include highly variable paths or hostnames. For requests that complete, use this method: NewRelic.noticeNetworkRequestForURL(url: NSURL!, httpMethod: String!, withTimer: NRTimer!, responseHeaders:[NSObject : AnyObject]!, statusCode: Int, bytesSent: UInt, bytesReceived: UInt, responseData: NSData!, andParams: [NSObject : AnyObject]!) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request headers A dictionary containing the HTTP response headers, if available httpStatusCode The response status code If the httpStatusCode is greater than or equal to 400, the agent will record a server error and may capture the responseData body if provided. bytesSent The size of the request body bytesReceived The size of the responseBody responseData The response body data, captured if the agent records Server error params params Additional parameters included in an HTTP error metric if the HTTP transaction is an error For requests that fail due to a socket or operating system error, use this method: NewRelic.noticeNetworkFailureForURL(url: NSURL!, httpMethod: NSString!, withTimer: NRTimer!, andFailureCode: Int) Copy Parameters include: Parameter Description url The URL of the request httpMethod The method type of the request; for example, POST, GET, etc. timer An NRTimer that timed the network request iOSFailureCode The failure code Failure codes are interpreted as NSURLError* code. To view a complete list of supported codes, see NRConstants.h.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 334.5037,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Objective-C: <em>Report</em> <em>custom</em> <em>attributes</em> <em>and</em> <em>events</em>",
        "body": ". You can also use several API calls to record <em>custom</em> metrics that provide different levels of detail. Objective-C: <em>Report</em> <em>custom</em> <em>attributes</em> and <em>events</em> Use methods in the NewRelic object to <em>report</em> <em>custom</em> <em>attributes</em> and <em>events</em>. For details about the available methods for <em>custom</em> <em>attributes</em> and <em>events</em>"
      },
      "id": "603eb3a2e7b9d264f02a07a8"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 278.12628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Report</em> browser monitoring <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "sections": "<em>Report</em> browser monitoring <em>custom</em> <em>events</em> <em>and</em> <em>attributes</em>",
        "tags": "<em>Custom</em> <em>events</em>",
        "body": " to run and <em>report</em> relevant PageAction <em>events</em>. Run a NRQL query of the PageAction <em>event</em> that includes the actionName attribute you used to capture the <em>event</em> (and any associated <em>attributes</em> you sent along with the action). Add <em>custom</em> <em>attributes</em> to PageView <em>event</em> The PageView <em>event</em> is a default browser"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/telemetry-data-platform/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes": [
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "46f2be93b0c4daf40da9b93cfe0fbf5f235eecb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-07-16T03:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.31332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for <em>custom</em> <em>event</em> <em>data</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ", timeseries, until, week, weeks, where, with <em>Event</em> type limits The current limit for total number of <em>event</em>Type values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop <em>data</em>. <em>Event</em> types include: Default <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from New Relic agents <em>Custom</em> <em>events</em> from <em>Insights</em> <em>custom</em> <em>event</em> inserter"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.14122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "sections": "Report browser monitoring <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add <em>custom</em> <em>events</em> and attributes. Page actions and views Use the browser API&#x27;s addPageAction call to capture <em>events</em>, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.1113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "sections": "APM: Report <em>custom</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": ". Record <em>custom</em> <em>events</em> and attributes You can add your own <em>custom</em> APM <em>events</em> and attributes, which you can then use for querying and charting. This is one of several ways to report <em>custom</em> <em>data</em>. To record a <em>custom</em> <em>event</em>, follow the procedures for your New Relic language agent. To add <em>custom</em> attributes"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/telemetry-data-platform/custom-data/intro-custom-data": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-custom-event-data/",
      "sections": [
        "Report custom events and attributes",
        "Requirements",
        "Avoid rate limits",
        "Example use cases",
        "Using custom attributes",
        "Using custom events",
        "Send custom events and attributes",
        "Extend data retention"
      ],
      "published_at": "2021-09-02T11:24:48Z",
      "title": "Report custom events and attributes",
      "updated_at": "2021-07-09T20:06:23Z",
      "type": "docs",
      "external_id": "e50a9be8b3df5859c6307c8642942006f537578d",
      "document_type": "page",
      "popularity": 1,
      "body": "One of the ways to report custom data to New Relic is with custom events and attributes. Have questions about why you'd use custom data? See Introduction to custom data. Requirements For event and attribute formatting requirements and best practices, see Limits and requirements. Avoid rate limits Reporting a large number of custom events and/or attributes can cause degraded query performance. It may also result in approaching or passing data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Example use cases Two popular custom data solutions are custom events and custom attributes. There are several ways to accomplish this (more on that later in this doc), depending on your New Relic implementation and tools. Here are some common use cases for implementing custom events and attributes. Using custom attributes Custom attributes are often used to add important business and operational context to existing events. Business context might include: Customer token Customer market segment Customer value classification Workflow control values not obvious in the URIStem User/product/account privilege context Operational context might include: Which feature flags were used What datastore was accessed What cache was accessed What errors were detected and ignored (fault partitioning) Using custom events Event data is one of New Relic's four core data types. We recommend reading that definition to understand what we mean by \"event\" and why that data type is most used for reporting specific types of activity. The use cases for custom events varies widely: basically they are used for any type of activity that an organization deems important and that is not already being monitored. A couple examples: An event might represent an activity involving multiple actions, like a customer purchasing a certain combination of products. An event might record backup activity. For example, they might set up reporting of events that represent production backups of their SOLR instances into an event table, with a timestamp of when it occurred, which cluster, and the duration. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser monitoring agent Add custom attributes to the PageView event via the browser API call addCustomAttribute. Send PageAction event and attributes via browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure monitoring agent Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile monitoring agent Use the mobile agent API to send custom events and attributes. Synthetic monitoring Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn how to extend how long events are retained in your account, see our documentation about event data retention.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 545.09015,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> events and attributes",
        "sections": "Report <em>custom</em> events and attributes",
        "body": "One of the ways to report <em>custom</em> <em>data</em> to New Relic is with <em>custom</em> events and attributes. Have questions about why you&#x27;d use <em>custom</em> <em>data</em>? See <em>Introduction</em> to <em>custom</em> <em>data</em>. Requirements For event and attribute formatting requirements and best practices, see Limits and requirements. Avoid rate limits"
      },
      "id": "609fa5fb64441f9ebfd2a1db"
    },
    {
      "sections": [
        "Data requirements and limits for custom event data",
        "General requirements",
        "Important",
        "Reserved words",
        "Event type limits"
      ],
      "title": "Data requirements and limits for custom event data",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "46f2be93b0c4daf40da9b93cfe0fbf5f235eecb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/",
      "published_at": "2021-09-02T11:48:21Z",
      "updated_at": "2021-07-16T03:18:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. You can report custom events to New Relic in several ways, including: APM agent APIs Event API (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the custom PageAction event.) Mobile monitoring SDK General requirements When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1MB (10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Important Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. Important This is not a complete list. In general, avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, log, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Event type limits The current limit for total number of eventType values is 250 per child account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.583755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> requirements and limits for <em>custom</em> event <em>data</em>",
        "sections": "<em>Data</em> requirements and limits for <em>custom</em> event <em>data</em>",
        "tags": "Event <em>data</em> sources",
        "body": " (There are additional requirements when using the Event API.) Browser monitoring agent APIs (There are additional requirements with the <em>custom</em> PageAction event.) Mobile monitoring SDK General requirements When reporting <em>custom</em> events and attributes, follow these general requirements for supported <em>data</em> types, naming"
      },
      "id": "609fa5cfe7b9d2bf16c3eb69"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-07-09T23:43:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.44076,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring <em>custom</em> events and attributes",
        "sections": "Forward <em>custom</em> attributes from APM <em>data</em>",
        "tags": "Event <em>data</em> sources",
        "body": " that contains the action name and any <em>custom</em> attribute names and values you capture along with it. The PageAction event also contains any <em>custom</em> attributes you added to the PageView event. Add <em>custom</em> attributes to the PageView event so you can query or filter your <em>data</em> to answer more questions about your"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/telemetry-data-platform/get-started/get-know-telemetry-data-platform": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 259.20844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " on limits and restricted attributes, see Metric API requirements and limits. <em>Get</em> <em>started</em> If we don&#x27;t have an existing integration that meets your metric-reporting needs, you have two options: Use our <em>Telemetry</em> SDKs, which are language-specific tools that help you send us metrics and other <em>data</em>. Use"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.66125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick <em>start</em>: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick <em>start</em> to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick <em>start</em>: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.42336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> the license key",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: <em>Get</em> a license key for the account you want to report <em>data</em> to. Before creating custom events or attributes, review New Relic&#x27;s list of reserved terms used by NRQL. Generate JSON"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/get-started/introduction-new-relic-data-ingest-apis-sdks": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 259.20844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " on limits and restricted attributes, see Metric API requirements and limits. <em>Get</em> <em>started</em> If we don&#x27;t have an existing integration that meets your metric-reporting needs, you have two options: Use our <em>Telemetry</em> SDKs, which are language-specific tools that help you send us metrics and other <em>data</em>. Use"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.66125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick <em>start</em>: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick <em>start</em> to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick <em>start</em>: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.42336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> the license key",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: <em>Get</em> a license key for the account you want to report <em>data</em> to. Before creating custom events or attributes, review New Relic&#x27;s list of reserved terms used by NRQL. Generate JSON"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/get-started/nrdb-horsepower-under-hood": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 259.20844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " on limits and restricted attributes, see Metric API requirements and limits. <em>Get</em> <em>started</em> If we don&#x27;t have an existing integration that meets your metric-reporting needs, you have two options: Use our <em>Telemetry</em> SDKs, which are language-specific tools that help you send us metrics and other <em>data</em>. Use"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.66125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick <em>start</em>: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick <em>start</em> to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick <em>start</em>: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.42336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> the license key",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: <em>Get</em> a license key for the account you want to report <em>data</em> to. Before creating custom events or attributes, review New Relic&#x27;s list of reserved terms used by NRQL. Generate JSON"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/index": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 987.48004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find and use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-ingest APIs. The Metric API can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 987.48004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick start: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 982.3148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric <em>data</em> point may cause undefined behavior such as missing entities in the UI or <em>telemetry</em> not associating with the expected entities. For more"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/ingest-apis/introduction-event-api": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-09-01T19:44:23Z",
      "updated_at": "2021-08-26T14:51:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.88586,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "sections": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic <em>platform</em>. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.3459,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 298.9754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report metrics via the Metric <em>API</em>",
        "sections": "Report metrics via the Metric <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric <em>API</em> to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    }
  ],
  "/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-09-01T19:44:23Z",
      "updated_at": "2021-08-26T14:51:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.88577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "sections": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic <em>platform</em>. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 298.97534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report metrics via the Metric <em>API</em>",
        "sections": "Report metrics via the Metric <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric <em>API</em> to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 297.4115,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/ingest-apis/metric-api/metric-api-limits-restricted-attributes": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-09-01T19:44:23Z",
      "updated_at": "2021-08-26T14:51:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.88577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "sections": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic <em>platform</em>. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.34583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 298.97534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report metrics via the Metric <em>API</em>",
        "sections": "Report metrics via the Metric <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric <em>API</em> to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    }
  ],
  "/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-09-01T19:44:23Z",
      "updated_at": "2021-08-26T14:51:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.88568,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "sections": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic <em>platform</em>. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.34573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 297.4114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/ingest-apis/metric-api/troubleshoot-nrintegrationerror-events": [
    {
      "sections": [
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Tip",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "759fd7fa58ab2e074d0ba50b30be8c1096698304",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data/",
      "published_at": "2021-09-01T19:44:23Z",
      "updated_at": "2021-08-26T14:51:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send data to the New Relic platform. Under the hood, these SDKs rely on our core data ingest APIs: the Metric API, Trace API, Log API, and Event API. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility The Telemetry SDKs use our Metric API, Event API, Log API, and Trace API, which all require a license key, so you'll need a license key for the account you wish to send data to. Tip New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported New Relic data types Java Java library on GitHub Metrics Events Logs Traces Node/TypeScript NodeJS library on GitHub Metrics Traces Python Python library on GitHub Metrics Events Logs Traces Go Go library on Github Metrics Traces .NET .NET library on GitHub .NET package in NuGet Metrics Traces C C library on Github Traces Rust Rust library on Github Traces Ruby Ruby library on Github Gem on Rubygems Traces For more on the supported data types, see: An overview of New Relic data types Metrics: see the Metric API Logs: see the Log API Traces: see the Trace API Events: see the Event API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 306.88568,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "sections": "<em>Telemetry</em> SDKs: Report custom <em>telemetry</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Our <em>Telemetry</em> SDKs are an open source set of <em>API</em> client libraries that send <em>data</em> to the New Relic <em>platform</em>. Under the hood, these SDKs rely on our core <em>data</em> <em>ingest</em> <em>APIs</em>: the Metric <em>API</em>, Trace <em>API</em>, Log <em>API</em>, and Event <em>API</em>. We offer open-source integrations for <em>telemetry</em> tools like Prometheus, Istio"
      },
      "id": "603ea196196a670192a83d83"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.34573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 298.97525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report metrics via the Metric <em>API</em>",
        "sections": "Report metrics via the Metric <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric <em>API</em> to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    }
  ],
  "/docs/telemetry-data-platform/ingest-apis/telemetry-sdks-report-custom-telemetry-data": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.34564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Metric <em>API</em>",
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric <em>API</em> is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> <em>APIs</em>. The Metric <em>API</em> can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 298.97516,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report metrics via the Metric <em>API</em>",
        "sections": "Report metrics via the Metric <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric <em>API</em> to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 297.41132,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the Event <em>API</em>",
        "sections": "Introduction to the Event <em>API</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "The New Relic Event <em>API</em> is one way to report custom events to New Relic. The Event <em>API</em> lets you send custom event <em>data</em> to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event <em>API</em>? Create a New Relic account for free"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/manage-data/drop-data-using-nerdgraph": [
    {
      "sections": [
        "Drop data using Prometheus remote write",
        "Tip",
        "Drop entire metric data points from remote write integration",
        "Example",
        "Drop specific labels or attributes from data points",
        "Prometheus or NerdGraph?",
        "Considerations for the Prometheus config file method",
        "Considerations the NerdGraph method",
        "Learn more"
      ],
      "title": "Drop data using Prometheus remote write",
      "type": "docs",
      "tags": [
        "Integrations",
        "Prometheus integrations",
        "Install and configure remote write"
      ],
      "external_id": "f3e07dd4f6bbdb65881f13035af5af172c5409e7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/prometheus-integrations/install-configure/remote-write-drop-data/",
      "published_at": "2021-09-01T23:51:47Z",
      "updated_at": "2021-07-09T08:33:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can drop data you don't want to keep by changing the remote_write section of the YAML config file. Tip You can also drop remote write data using NerdGraph. For more information, see Drop data using NerdGraph. Drop entire metric data points from remote write integration If a target is sending a noisy metric that you don't want sent to New Relic, you can specify that New Relic should drop that data. Example Let's say you don't want to receive data for the metric node_memory_active_bytes from an instance running at localhost:9100. Using the write_relabel_config entry shown below, you can target the metric name using the __name__ label in combination with the instance name. remote_write: - url: https://metric-api.newrelic.com/prometheus/v1/write?prometheus_server=macbook-server-cluster bearer_token: <redacted> write_relabel_configs: - source_labels: ['__name__', 'instance'] regex: 'node_memory_active_bytes;localhost:9100' action: 'drop' Copy This tells Prometheus that you want to do some action against metrics with these labels. To limit which metrics with these labels are affected, you must include some value for regex. By default this value is set to .* and it will include all metrics. In this case, it will drop all metric data points coming out of Prometheus via remote write. Drop specific labels or attributes from data points If a target is sending specific labels or attributes you're not interested in receiving, you can drop these from the metrics you receive. Example Let's say one of your targets is sending a bunch of extra attributes you're not interested in receiving. These might include things like high cardinality attributes such as unique machine identifiers, JVM IDs, or similar. In this case, you need to change both the remote_write and the scrape_configs section of the YAML file. The result will look something like this: remote_write: - url: https://metric-api.newrelic.com/prometheus/v1/write?prometheus_server=macbook-server-cluster bearer_token: <redacted> write_relabel_configs: - regex: 'extraLabelToRemove.*' action: 'labeldrop' ... scrape_configs: # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config. - job_name: 'node' # Override the global default and scrape targets from this job every 5 seconds. scrape_interval: 5s static_configs: - targets: ['localhost:9100'] labels: group: 'production' keepLabelName1: 'please-keep-me' extraLabelToRemove: 'please-remove-me' extraLabelToRemove1: 'please-remove-me' extraLabelToRemove2: 'please-remove-me' extraLabelToRemove4: 'please-remove-me' extraLabelToRemove3: 'please-remove-me' extraLabelToRemove5: 'please-remove-me' Copy Prometheus or NerdGraph? There are advantages to both dropping data using the method described on this page and using NerdGraph. This section is intended to help you figure out which method is better for your specific needs and preferences. Considerations for the Prometheus config file method With this method, your dropped data never leaves the associated Prometheus instance. This is a valuable feature if bytes transferred is a cost consideration on the app hosting side. However, this method may be less appealing than the NerdGraph option due to the following considerations: Maintained via config yaml files that need to be loaded onto each Prometheus instance (or via a shared storage mechanism) Requires access to Prometheus server, meaning that either: The server needs to be restarted Served must be be accessed at port with path /-/reload (assuming the server has lifecycle management enabled as described here in the Prometheus configuration docs. Considerations the NerdGraph method NerdGraph is a great option if you want to manage all your data dropping in a single place. It can also be updated easily via the API and requires no restart or interaction with Prometheus. However, this method applies rules to all incoming data points. This means that you should set up your rules with careful consideration using WHERE filtering. For more information, see Drop data using NerdGraph. Learn more Send Prometheus metric data to New Relic Prometheus High Availability (HA)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1846.4464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Drop</em> <em>data</em> <em>using</em> Prometheus remote write",
        "sections": "<em>Drop</em> <em>data</em> <em>using</em> Prometheus remote write",
        "body": "You can <em>drop</em> <em>data</em> you don&#x27;t want to keep by changing the remote_write section of the YAML config file. Tip You can also <em>drop</em> remote write <em>data</em> <em>using</em> <em>NerdGraph</em>. For more information, see <em>Drop</em> <em>data</em> <em>using</em> <em>NerdGraph</em>. <em>Drop</em> entire metric <em>data</em> points from remote write integration If a target is sending"
      },
      "id": "60e809e4e7b9d298bafc1035"
    },
    {
      "sections": [
        "Manage your data",
        "Important",
        "Where to find the Data management hub",
        "Better cost, performance, and compliance",
        "Cost management",
        "Performance management",
        "Ingest and retention strategies"
      ],
      "title": "Manage your data",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "1938512af1fd477b8cd587cc85a4a1522cd62e9e",
      "image": "https://docs.newrelic.com/static/8a553ce9643c8513be3200af5d924250/c1b63/datamanagement_overview.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/manage-your-data/",
      "published_at": "2021-09-01T19:45:24Z",
      "updated_at": "2021-07-09T03:38:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At New Relic, we're super proud of NRDB, the New Relic database where we store your data. It gathers all your telemetry data in one place, gives you a connected view of all your data, and scales as your business grows. We invite you to send all your metrics, events, logs, and traces to NRDB, including those from third-party sources. We also recognize that some data might not be necessary for your business goals. You shouldn’t have to wade through data you don’t need to get to the data you do. And you definitely shouldn’t have to pay for it. That’s where our data management tools come in: they let you decide what data you send to New Relic and how long it should be stored. Data management hub: from the user profile drop down, select Manage your data. Coupled with user management tools, data management helps you get maximum value from your investment in New Relic, all while safeguarding your data. Important Not yet a New Relic customer? Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Where to find the Data management hub To locate the data management UI: From one.newrelic.com select the account dropdown, and select Manage your data. If you're on the New Relic One user model, you can also find the Data management hub by selecting Administration > Manage data. Better cost, performance, and compliance Collecting and storing data in New Relic allows you to analyze, visualize, and alert on all your metrics, events, logs, and traces from across all of your sources. However, it’s important to manage that data for cost, performance, and in some cases, compliance reasons. The data management hub provides the tools you need to understand and control where your data is coming from, and adjust what’s stored and for how long. Important If you're on our original product-based pricing plan, you'll see your data ingest, retention, and limits in the Data management hub. The primary difference is that you're not billed on ingest, as with our New Relic One pricing plan. Not sure which plan you're on? See Overview of pricing and account/user structure. Cost management The cost of data storage continually decreases, but storage is still an expense. The amount of data you process and store is closely related to the value you receive from New Relic, because it’s a key component of how you’re charged. Our ingest process helps you hone your data. For example, data might arrive at our processing front door compressed and of varying quality. Through ingest, that data is uncompressed, decorated with queryable attributes, and evaluated. Elements are dropped or trimmed, all before we write it to NRDB. That way, the data you store is only the data you want most. Performance management While NRDB is a phenomenally scalable database, it’s also a reality that queries across huge datasets might not return results in a timely enough fashion for your needs. You get better performance if you limit the data we store, or convert it into a format that keeps it easily queryable. Drop data to improve performance by reducing the amount of data that’s stored. Ingest and retention strategies Depending on your goals, whether to reduce costs, increase specific retention rates, or pare down your data to what’s most essential, we have a strategy for you. Learn about reducing the amount of data that comes into NRDB in Manage data coming into New Relic. Learn about customizing storage so you only store the data you want, for the period you want in Manage data stored in New Relic. Learn about dropping data in Drop data using NerdGraph. And for dropping log data, see Drop data with drop filter rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1206.6093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage your <em>data</em>",
        "sections": "Manage your <em>data</em>",
        "tags": "Telemetry <em>Data</em> Platform",
        "body": " essential, we have a strategy for you. Learn about reducing the amount of <em>data</em> that comes into NRDB in Manage <em>data</em> coming into New Relic. Learn about customizing storage so you only store the <em>data</em> you want, for the period you want in Manage <em>data</em> stored in New Relic. Learn about dropping <em>data</em> in <em>Drop</em> <em>data</em> <em>using</em> <em>NerdGraph</em>. And for dropping log <em>data</em>, see <em>Drop</em> <em>data</em> with <em>drop</em> filter rules."
      },
      "id": "603e96ff28ccbcf8bceba796"
    },
    {
      "sections": [
        "Data privacy with New Relic",
        "Tip",
        "Personal data transfer (Privacy Shield and SCC)",
        "Compliance with legal requirements",
        "Privacy by design and by default",
        "Personal data requests (GDPR, CCPA, etc.)",
        "Events and attributes",
        "Dropping data at ingest",
        "Technical security controls",
        "Organizational security controls",
        "Account security",
        "Retention of your data",
        "New Relic account emails",
        "Account changes (NrAuditEvent)",
        "Account usage",
        "Security for products and services",
        "Alerts and Applied Intelligence",
        "APIs",
        "APM",
        "Browser monitoring",
        "Diagnostics",
        "Infrastructure monitoring",
        "Integrations and serverless monitoring",
        "Logs management",
        "Mobile monitoring",
        "Synthetic monitoring"
      ],
      "title": "Data privacy with New Relic",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Data privacy"
      ],
      "external_id": "d46953520476285467540433180d483815efecc6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/",
      "published_at": "2021-09-02T16:38:13Z",
      "updated_at": "2021-08-09T10:25:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. We understand your concerns when you entrust us with your data, and we always strive to embrace your expectations and preferences. This document provides links to detailed information about the privacy and security measures we take to protect you and your customers' data privacy. Our monitoring tools are data-agnostic; they don't require sensitive materials, and many of them don't require any personal data. You are responsible for ensuring that your systems are appropriately set up and configured so that they don't send inappropriate personal data or sensitive materials to New Relic monitoring tools. For additional information about policies, credentials, audits, and other resources, see our New Relic security website. Tip New Relic now offers the option of HIPPA-enabled accounts for customers meeting certain requirements. To learn more, see HIPAA readiness at New Relic. Personal data transfer (Privacy Shield and SCC) The Schrems case ruling invalidates Privacy Shield. However, it explicitly reaffirms the validity of Standard Contractual Clauses (SCC) as an appropriate legal mechanism to transfer personal data outside of the European Union. You can find more information in How the Demise of Privacy Shield Affects Your New Relic Account. If you want to send personal data from the EU, we offer an appropriate data processing agreement (DPA) with SCC to govern the transfer of that data in accordance with the Schrems decision. For more information, consult our Data Processing Addendum FAQ, or download our pre-signed DPA (PDF|697 KB). Compliance with legal requirements We always strive to comply with all applicable laws as they take effect. This includes the European Union's General Data Protection Regulation (GDPR) and all relevant US State laws, such as the California Consumer Privacy Act (CCPA). Our disk-based encryption provides additional security while your data is at rest (FIPS 140-2 compliant). In addition, we are authorized for Moderate Impact SaaS Services (FedRAMP Authorized Moderate) for accounts that meet specific criteria. For privacy-related details about New Relic's contractual and regulatory commitments for services, see: Terms of Service or Master Subscription Agreement Data Protection Agreement Services Privacy Notice For more information about annual audits, see Regulatory audits for New Relic services. Privacy by design and by default New Relic follows \"privacy by design\" principles as part of our overarching security program. For example, when New Relic agents capture a webpage or referrer URL, all query parameters are stripped by default. Here are examples of how we incorporate privacy considerations into our data and security practices. Personal data requests (GDPR, CCPA, etc.) New Relic strives to comply with all applicable laws as they take effect. This includes the European Union's GDPR and ePrivacy Directive and all applicable privacy laws, such as the California Consumer Privacy Act (CCPA) in the US. For more information about our process when responding to requests to access or delete personal data, see New Relic personal data requests. Events and attributes You can query events and attributes, as well as create charts and alert conditions about this data. For a complete list of all events and attributes tracked by New Relic agents, see our data dictionary. Events and attributes example: If you use the Infrastructure ProcessSample event's commandLine attribute, by default we strip options and arguments from the full command line to prevent accidental leakage of sensitive information. Dropping data at ingest Dropping data gives you control over the data that you send to New Relic, including any personal data that you configured to be collected. By dropping specific events or attributes from events, you determine what data New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see Drop data using NerdGraph. When our agents refer to data obfuscation, the agent actually removes the data before sending it to New Relic. The data cannot be recovered. For example, with APM queries, the Record SQL? value defaults to obfuscated. This strips the string literals and numeric sequences and then replaces them with the ? character. You can mask sensitive information in HTTP or HTTPS requests. For example, queries about distributed traces and transaction traces are obfuscated by default, in which case they cannot be recovered. For more information, see the documentation for specific New Relic services, including: APM transaction traces Distributed tracing Technical security controls We use a comprehensive set of technical controls to support general security needs as well as security for data we receive. For more information, see our documentation about data security, data encryption, and high security mode for APM agents. Organizational security controls New Relic maintains a number of internal policies and procedures to guide employees in privacy-related subjects such as data classification and handling, data retention, handling of personal data, fulfilling personal data requests, incident response, etc. All employees must complete the security and privacy training upon hiring and renew this training annually. Account security Our role-based account structure gives you direct control over who can access or change your account settings. For more information, see Users and roles. Retention of your data Our Telemetry Data Platform is the single source of truth for all your operational data, empowering you to ask and answer any question in milliseconds. This platform stores different types of data for different periods of time. The Data retention page in our UI provides information on how long your data will be stored in the New Relic database (NRDB). For more information, see Manage data retention. New Relic account emails By default, we communicate with you for a variety of purposes related to your status as New Relic subscribers. This includes product engagement, support, alert notifications, updates, billings, etc. Individual users can unsubscribe from certain communications. General email preferences are managed through the account user interface. For more information, see Account email settings. Alert notification emails are managed through the alerting UI. Account changes (NrAuditEvent) To view changes made to your account's users or to record configuration changes, query NrAuditEvent events. To be notified about account changes, create NRQL alert conditions. For more about available NrAuditEvent attributes, see our data dictionary. Account usage For more about usage, see Manage data. Security for products and services We publish security bulletins with detailed information about vulnerabilities, remediation strategies, and applicable updates for affected software. To receive notifications for future advisories, use either of these options: Subscribe to our security bulletins RSS feed. Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. The following summarizes how individual New Relic products and components ensure security, with links to additional details. Alerts and Applied Intelligence By default, our alerting services do not record any personal data. In addition, they automatically set default permissions for individual account users and access levels within account structures. For more information, see our documentation about Applied Intelligence, as well as our rules and limits for alerts. APIs APIs simply are interfaces for data exchange automation. APIs have no knowledge of the content being transferred. We require authorized users to provide their API keys to monitor subscription usage, manage account user permissions, query data, and perform other automated tasks. For more information, see Introduction to New Relic APIs. APM APM agents monitor your applications' performance. By default, APM agents do not record any personal data. For more information, see our APM security documentation. Browser monitoring Our browser monitoring agent allows you to monitor the performance of their websites. For more information, see: Browser security documentation Visitor's IP address New Relic cookies used by browser Enabling or disabling cookie collection for session tracking Diagnostics The New Relic Diagnostics service inspects relevant system information and any other necessary information (such as logs and config files) to perform diagnostic checks that assess configuration and operability. By default, this data is not transmitted to New Relic. You do have the option to upload this information to a support ticket over HTTPS. For more information, see the Diagnostics security documentation. Infrastructure monitoring The Infrastructure agent allows you to monitor the performance of components in your ecosystem, such as servers, platforms, operating systems, databases, etc. Infrastructure may record the userID and username of users connecting to Infrastructure resources. For more information, see the security documentation for infrastructure monitoring. Integrations and serverless monitoring Our integrations services allow you to retrieve and load data into the New Relic database from a variety of sources, including: Cloud-based integrations On-host integrations in containerized environments, such as Kubernetes On-host integrations built by New Relic On-host integrations built by the open-source community On-host integrations built by you Depending on the integration, different types of data may be recorded so that you can monitor the integrations in New Relic. The integration services are data agnostic. They will have no knowledge of whether the imported data contains any personal information. For more information, see the documentation for the specific integration, including: Amazon Web Services (AWS) Google Cloud Platform (GCP) Kubernetes Microsoft Azure On-host integrations Open source on-host integrations Serverless function monitoring Logs management Due to the nature of our logs management service, you have direct control over what data is reported to New Relic. To ensure data privacy and to limit the types of information New Relic receives, no customer data is captured except what you supply in your API calls or log forwarder configuration. All data for the logs service is then reported to New Relic over HTTPS. The logs service does mask number patterns that appear to be for items such as credit cards or Social Security numbers. For more information, see the Logs security documentation. Mobile monitoring By default, our mobile monitoring service collects two pieces of personal data: The IP address is used to derive high-level geographical data, and then is discarded. A device ID is generated by New Relic and is used for billing purposes. For more information, see our security documentation for mobile monitoring. Synthetic monitoring The synthetic monitoring service uses monitors distributed throughout data centers around the world. It captures what is essentially performance data of simulated traffic. By default, it does not capture any personal data. For more information, see the data privacy and security documentation for synthetic monitoring. If you configure the synthetic service to monitor areas of websites that are located behind a login page, take care to create a non-personal login dedicated to this purpose. This will reduce the risk of unintended personal data exposure. For example, to securely store sensitive information, such as passwords, API keys, and user names, you can use secured credentials for scripted browsers and API tests. The synthetic monitoring service also supports a variety of authentication mechanisms. Depending on the type of monitor you choose, this includes Basic, Digest, NTLM, and NTLMv2. You can also control which of your users can access your monitors and private locations. For more information, see our documentation about user role-based permissions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 733.9046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> privacy with New Relic",
        "sections": "<em>Dropping</em> <em>data</em> at ingest",
        "tags": "<em>Data</em> privacy",
        "body": " or attributes from events, you determine what <em>data</em> New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see <em>Drop</em> <em>data</em> <em>using</em> <em>NerdGraph</em>. When our agents refer to <em>data</em> obfuscation, the agent actually removes the <em>data</em> before sending it to New Relic. The <em>data</em>"
      },
      "id": "603ec2d4e7b9d22fba2a07c6"
    }
  ],
  "/docs/telemetry-data-platform/manage-data/manage-data-coming-new-relic": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.02277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> APIs. The Metric API can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.02277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick start: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.52667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric <em>data</em> point may cause undefined behavior such as missing entities in the UI or <em>telemetry</em> not associating with the expected entities. For more"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/manage-data/manage-data-retention": [
    {
      "sections": [
        "Event data retention (original pricing plan)",
        "Important",
        "Data retention UI",
        "Overview of event data retention",
        "Extend your event retention",
        "Insights Pro",
        "How number of events stored is calculated",
        "Insights Pro event overage example",
        "Disable/enable Transaction and Pageview event reporting",
        "Tip",
        "Flexible data retention",
        "How it works",
        "Manage retention via UI",
        "Glossary",
        "For more help"
      ],
      "title": "Event data retention (original pricing plan)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original data retention"
      ],
      "external_id": "76d1289aad7de08b355bb8c313f9e7a42a5779d8",
      "image": "https://docs.newrelic.com/static/e53a1e416eb6116545627d3ec880d08e/e9c9b/flex-2.png",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-data-retention/event-data-retention-original-pricing-plan/",
      "published_at": "2021-09-01T19:33:00Z",
      "updated_at": "2021-08-27T08:49:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This doc is for accounts on our original pricing plan, not our New Relic One pricing plan. Not sure which you're on? See Overview of pricing plans. For organizations on New Relic One pricing, our various New Relic products report a wide range of event data. Different products have different data retention periods, and different ways to extend event data retention. You can customize the length of your event data retention through flexible event retention. Data retention UI For how to find the data retention UI, see Manage data. Overview of event data retention All New Relic product subscriptions come with a certain level of data retention that governs how long different types of data are retained. One type of data governed by data retention rules is event data. Event data is available in some UI charts and tables, and also available for querying via NRQL, our querying language. There are events reported from products by default, and there are custom events: each have their own retention rules, depending on the product and subscription level. Here are some examples of how different product subscriptions can affect event data retention: Free/Lite APM subscription: default-reported events available for 1 day. No custom events available. Pro APM subscription: default-reported events available for 8 days. Custom events available for 1 day (and able to be extended with Insight Pro). To see your subscriptions, go to the Account summary page. Extend your event retention Product Method APM, Browser, and Mobile Event data retention can be extended with a paid subscription to these products (see product data retention). To extend retention of both default-reported events and custom events further, you need an Insights Pro subscription. Infrastructure Event data retention can be extended with a paid Infrastructure subscription. See Infrastructure data retention rules. Synthetics Event data retention can be extended with a paid Synthetics subscription. See Synthetics data retention rules. Custom events Custom events reported by agent APIs or the Event API: Extension requires an Insights Pro subscription. Insights Pro Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. A paid Insights subscription is what governs the extension of event data retention for: Our APM, Browser, Mobile, and Serverless products Custom events that come from an agent API or from the Event API Important Note that having an Insights Pro subscription doesn't require use of the Insights UI (insights.newrelic.com) to query your data: there are other querying options available. To see the data retention governed by your Insights subscription: go to the usage UI and select Insights usage. With an Insights Pro subscription, you can use flexible retention to customize how your event data is retained. This lets you keep only the data you need, for as long as you need it. How number of events stored is calculated This is an explanation of how the number of stored events are calculated by default for an Insights Pro subscription. (Note that with flexible retention, you have more fine-grained control over the retention period.) The events stored is calculated based on 1) total events stored over time (calculated based on the events generated per week) and 2) the weeks of data retention available. This equation can be represented like this: events stored = (events generated per week) * (weeks of retention) Copy An Insights Pro subscription provides a given number of weeks of data retention as well as a given number of events over that retention period. For example: (200M transactions per week) * (4 weeks of retention) = 800M events stored in Insights (16M transactions per week) * (50 weeks of retention) = 800M events stored in Insights For Insights Pro subscriptions, data is purged based on retention window, not volume. It is deleted from the system once it's past the retention window. For example: If your Insights license is for 800 million events with a 4 week retention period, your data would start being purged after it is older than four weeks. Temporary spikes in data exceeding your subscription level will still be recorded, but consistent overage should be solved by upgrading your subscription level or decreasing data collected. For customers without an Insights Pro subscription, New Relic may throttle or downsample events to a limit of not more than than 4,000 events per host per minute. Insights Pro event overage example In this example, you have an Insights Pro subscription with a license for 800 million events over 4 weeks, a rate of 200 million events per week. You have APM Pro, Browser Pro, and Mobile Enterprise. A fifth week of data is added via your subscriptions, bumping you to a total of 1 billion events stored within your plan: If you are using 975 million events, you are not over your retention. If you are using 1.25 billion events, you are over your retention. Disable/enable Transaction and Pageview event reporting Tip Owners or Admins The Insights Data summary UI page is used to see the types of events being reported. You can also use this page to enable and disable the reporting of PageView and Transaction events. To view Data summary: Go to insights.newrelic.com > Manage data. Select the Summary tab. Note: if you disable PageView or Transaction event reporting, this can affect some New Relic UI elements. You may see some empty charts on some UI pages that rely on this data. Go to insights.newrelic.com > Manage data > Summary. From the Summary tab, select Configure data sources. Toggle the appropriate switch on or off, then save. Toggling Transaction on or off will cause reporting agents to restart themselves. For more about configuring event reporting, see Event data retention. Flexible data retention With an Insights Pro subscription, you get access to flexible retention, which lets you define how some types of event data are retained. This lets you keep only the event data you need, for as long as you need it. You can manage your flexible retention through the UI or through our GraphQL API. Requirements to use this feature: An Insights Pro subscription or equivalent trial. Applies only for events governed by an Insights Pro subscription. To use this feature, you must be an account Owner or data retention add-on manager for your account. How it works To understand how standard event data retention works, first read Event data retention. With flexible retention, you specify the data retention for applicable event namespaces across your accounts. This gives you per-event namespace control of your data. The retention that you specify for an event namespace will be shared by all the event types under that namespace. If some namespaces are not relevant to you, you can avoid collecting their event data entirely. Your retention value can’t be lower than the included retention or higher than the default retention. You can control data retention either in our UI or by API. Manage retention via UI You can control data retention either using our GraphQL API or in the UI. To do this with the UI, go to the data retention UI. Your retention changes take effect within 24 hours after updating. Glossary To understand the terms used with flexible retention, see the following: Term Description Event namespace An event's namespace corresponds to one or more event types that share a single data retention value. For more information, see Event namespaces (types). You can also use NerdGraph to get the list of customizable event namespaces. Retention value The number (in days) that specifies how long your event data is stored. Retention rule The event namespace and retention value pair that you specify to override the current retention. Licensed retention Retention period that’s determined in weeks by your Insights Pro subscription contract. Included retention Retention period for which your data is stored but not charged under the Insights Pro subscription. For details, see the data retention details for a specific product. Paid retention Retention period for which your data is stored and is charged under the Insights Pro subscription. By default, your licensed retention determines this value but Flexible retention lets you override it. Default retention Retention period that comes out of the box. This is based on the total of included retention plus licensed retention. For information on managing retention settings with APIs, see the Manage data retention documentation. For more help For details about the data retention of other products or integrations, see that specific documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 616.38367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Event <em>data</em> <em>retention</em> (original pricing plan)",
        "sections": "<em>Manage</em> <em>retention</em> via UI",
        "tags": "Original <em>data</em> <em>retention</em>",
        "body": " different <em>data</em> <em>retention</em> periods, and different ways to extend event <em>data</em> <em>retention</em>. You can customize the length of your event <em>data</em> <em>retention</em> through flexible event <em>retention</em>. <em>Data</em> <em>retention</em> UI For how to find the <em>data</em> <em>retention</em> UI, see <em>Manage</em> <em>data</em>. Overview of event <em>data</em> <em>retention</em> All New Relic product"
      },
      "id": "6043f713e7b9d2ccee579a1d"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-09-02T03:48:08Z",
      "updated_at": "2021-08-27T08:50:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 615.1841,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " cloud integrations Partners and resellers <em>Manage</em> subscriptions (only for partners using original pricing plan) <em>Data</em> partitions <em>Manage</em> <em>data</em> partitions Date <em>retention</em> <em>Manage</em> <em>data</em> <em>retention</em> NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Data privacy with New Relic",
        "Tip",
        "Personal data transfer (Privacy Shield and SCC)",
        "Compliance with legal requirements",
        "Privacy by design and by default",
        "Personal data requests (GDPR, CCPA, etc.)",
        "Events and attributes",
        "Dropping data at ingest",
        "Technical security controls",
        "Organizational security controls",
        "Account security",
        "Retention of your data",
        "New Relic account emails",
        "Account changes (NrAuditEvent)",
        "Account usage",
        "Security for products and services",
        "Alerts and Applied Intelligence",
        "APIs",
        "APM",
        "Browser monitoring",
        "Diagnostics",
        "Infrastructure monitoring",
        "Integrations and serverless monitoring",
        "Logs management",
        "Mobile monitoring",
        "Synthetic monitoring"
      ],
      "title": "Data privacy with New Relic",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Data privacy"
      ],
      "external_id": "d46953520476285467540433180d483815efecc6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/data-privacy/data-privacy-new-relic/",
      "published_at": "2021-09-02T16:38:13Z",
      "updated_at": "2021-08-09T10:25:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. We understand your concerns when you entrust us with your data, and we always strive to embrace your expectations and preferences. This document provides links to detailed information about the privacy and security measures we take to protect you and your customers' data privacy. Our monitoring tools are data-agnostic; they don't require sensitive materials, and many of them don't require any personal data. You are responsible for ensuring that your systems are appropriately set up and configured so that they don't send inappropriate personal data or sensitive materials to New Relic monitoring tools. For additional information about policies, credentials, audits, and other resources, see our New Relic security website. Tip New Relic now offers the option of HIPPA-enabled accounts for customers meeting certain requirements. To learn more, see HIPAA readiness at New Relic. Personal data transfer (Privacy Shield and SCC) The Schrems case ruling invalidates Privacy Shield. However, it explicitly reaffirms the validity of Standard Contractual Clauses (SCC) as an appropriate legal mechanism to transfer personal data outside of the European Union. You can find more information in How the Demise of Privacy Shield Affects Your New Relic Account. If you want to send personal data from the EU, we offer an appropriate data processing agreement (DPA) with SCC to govern the transfer of that data in accordance with the Schrems decision. For more information, consult our Data Processing Addendum FAQ, or download our pre-signed DPA (PDF|697 KB). Compliance with legal requirements We always strive to comply with all applicable laws as they take effect. This includes the European Union's General Data Protection Regulation (GDPR) and all relevant US State laws, such as the California Consumer Privacy Act (CCPA). Our disk-based encryption provides additional security while your data is at rest (FIPS 140-2 compliant). In addition, we are authorized for Moderate Impact SaaS Services (FedRAMP Authorized Moderate) for accounts that meet specific criteria. For privacy-related details about New Relic's contractual and regulatory commitments for services, see: Terms of Service or Master Subscription Agreement Data Protection Agreement Services Privacy Notice For more information about annual audits, see Regulatory audits for New Relic services. Privacy by design and by default New Relic follows \"privacy by design\" principles as part of our overarching security program. For example, when New Relic agents capture a webpage or referrer URL, all query parameters are stripped by default. Here are examples of how we incorporate privacy considerations into our data and security practices. Personal data requests (GDPR, CCPA, etc.) New Relic strives to comply with all applicable laws as they take effect. This includes the European Union's GDPR and ePrivacy Directive and all applicable privacy laws, such as the California Consumer Privacy Act (CCPA) in the US. For more information about our process when responding to requests to access or delete personal data, see New Relic personal data requests. Events and attributes You can query events and attributes, as well as create charts and alert conditions about this data. For a complete list of all events and attributes tracked by New Relic agents, see our data dictionary. Events and attributes example: If you use the Infrastructure ProcessSample event's commandLine attribute, by default we strip options and arguments from the full command line to prevent accidental leakage of sensitive information. Dropping data at ingest Dropping data gives you control over the data that you send to New Relic, including any personal data that you configured to be collected. By dropping specific events or attributes from events, you determine what data New Relic ultimately stores so that you can query, alert on, and analyze it. For more information, see Drop data using NerdGraph. When our agents refer to data obfuscation, the agent actually removes the data before sending it to New Relic. The data cannot be recovered. For example, with APM queries, the Record SQL? value defaults to obfuscated. This strips the string literals and numeric sequences and then replaces them with the ? character. You can mask sensitive information in HTTP or HTTPS requests. For example, queries about distributed traces and transaction traces are obfuscated by default, in which case they cannot be recovered. For more information, see the documentation for specific New Relic services, including: APM transaction traces Distributed tracing Technical security controls We use a comprehensive set of technical controls to support general security needs as well as security for data we receive. For more information, see our documentation about data security, data encryption, and high security mode for APM agents. Organizational security controls New Relic maintains a number of internal policies and procedures to guide employees in privacy-related subjects such as data classification and handling, data retention, handling of personal data, fulfilling personal data requests, incident response, etc. All employees must complete the security and privacy training upon hiring and renew this training annually. Account security Our role-based account structure gives you direct control over who can access or change your account settings. For more information, see Users and roles. Retention of your data Our Telemetry Data Platform is the single source of truth for all your operational data, empowering you to ask and answer any question in milliseconds. This platform stores different types of data for different periods of time. The Data retention page in our UI provides information on how long your data will be stored in the New Relic database (NRDB). For more information, see Manage data retention. New Relic account emails By default, we communicate with you for a variety of purposes related to your status as New Relic subscribers. This includes product engagement, support, alert notifications, updates, billings, etc. Individual users can unsubscribe from certain communications. General email preferences are managed through the account user interface. For more information, see Account email settings. Alert notification emails are managed through the alerting UI. Account changes (NrAuditEvent) To view changes made to your account's users or to record configuration changes, query NrAuditEvent events. To be notified about account changes, create NRQL alert conditions. For more about available NrAuditEvent attributes, see our data dictionary. Account usage For more about usage, see Manage data. Security for products and services We publish security bulletins with detailed information about vulnerabilities, remediation strategies, and applicable updates for affected software. To receive notifications for future advisories, use either of these options: Subscribe to our security bulletins RSS feed. Select the Watching option in our Explorers Hub's Security notifications community channel to receive email alerts. The following summarizes how individual New Relic products and components ensure security, with links to additional details. Alerts and Applied Intelligence By default, our alerting services do not record any personal data. In addition, they automatically set default permissions for individual account users and access levels within account structures. For more information, see our documentation about Applied Intelligence, as well as our rules and limits for alerts. APIs APIs simply are interfaces for data exchange automation. APIs have no knowledge of the content being transferred. We require authorized users to provide their API keys to monitor subscription usage, manage account user permissions, query data, and perform other automated tasks. For more information, see Introduction to New Relic APIs. APM APM agents monitor your applications' performance. By default, APM agents do not record any personal data. For more information, see our APM security documentation. Browser monitoring Our browser monitoring agent allows you to monitor the performance of their websites. For more information, see: Browser security documentation Visitor's IP address New Relic cookies used by browser Enabling or disabling cookie collection for session tracking Diagnostics The New Relic Diagnostics service inspects relevant system information and any other necessary information (such as logs and config files) to perform diagnostic checks that assess configuration and operability. By default, this data is not transmitted to New Relic. You do have the option to upload this information to a support ticket over HTTPS. For more information, see the Diagnostics security documentation. Infrastructure monitoring The Infrastructure agent allows you to monitor the performance of components in your ecosystem, such as servers, platforms, operating systems, databases, etc. Infrastructure may record the userID and username of users connecting to Infrastructure resources. For more information, see the security documentation for infrastructure monitoring. Integrations and serverless monitoring Our integrations services allow you to retrieve and load data into the New Relic database from a variety of sources, including: Cloud-based integrations On-host integrations in containerized environments, such as Kubernetes On-host integrations built by New Relic On-host integrations built by the open-source community On-host integrations built by you Depending on the integration, different types of data may be recorded so that you can monitor the integrations in New Relic. The integration services are data agnostic. They will have no knowledge of whether the imported data contains any personal information. For more information, see the documentation for the specific integration, including: Amazon Web Services (AWS) Google Cloud Platform (GCP) Kubernetes Microsoft Azure On-host integrations Open source on-host integrations Serverless function monitoring Logs management Due to the nature of our logs management service, you have direct control over what data is reported to New Relic. To ensure data privacy and to limit the types of information New Relic receives, no customer data is captured except what you supply in your API calls or log forwarder configuration. All data for the logs service is then reported to New Relic over HTTPS. The logs service does mask number patterns that appear to be for items such as credit cards or Social Security numbers. For more information, see the Logs security documentation. Mobile monitoring By default, our mobile monitoring service collects two pieces of personal data: The IP address is used to derive high-level geographical data, and then is discarded. A device ID is generated by New Relic and is used for billing purposes. For more information, see our security documentation for mobile monitoring. Synthetic monitoring The synthetic monitoring service uses monitors distributed throughout data centers around the world. It captures what is essentially performance data of simulated traffic. By default, it does not capture any personal data. For more information, see the data privacy and security documentation for synthetic monitoring. If you configure the synthetic service to monitor areas of websites that are located behind a login page, take care to create a non-personal login dedicated to this purpose. This will reduce the risk of unintended personal data exposure. For example, to securely store sensitive information, such as passwords, API keys, and user names, you can use secured credentials for scripted browsers and API tests. The synthetic monitoring service also supports a variety of authentication mechanisms. Depending on the type of monitor you choose, this includes Basic, Digest, NTLM, and NTLMv2. You can also control which of your users can access your monitors and private locations. For more information, see our documentation about user role-based permissions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 280.64453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Data</em> privacy with New Relic",
        "sections": "<em>Retention</em> of your <em>data</em>",
        "tags": "<em>Data</em> privacy",
        "body": " and answer any question in milliseconds. This platform stores different types of <em>data</em> for different periods of time. The <em>Data</em> <em>retention</em> page in our UI provides information on how long your <em>data</em> will be stored in the New Relic database (NRDB). For more information, see <em>Manage</em> <em>data</em> <em>retention</em>. New Relic"
      },
      "id": "603ec2d4e7b9d22fba2a07c6"
    }
  ],
  "/docs/telemetry-data-platform/manage-data/manage-your-data": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.02277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> APIs. The Metric API can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.02277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick start: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.52667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric <em>data</em> point may cause undefined behavior such as missing entities in the UI or <em>telemetry</em> not associating with the expected entities. For more"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/manage-data/nrintegrationerror": [
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 374.4748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction <em>to</em> the <em>Event</em> API",
        "sections": "Introduction <em>to</em> the <em>Event</em> API",
        "tags": "<em>Ingest</em> and manage <em>data</em>",
        "body": " <em>event</em>. <em>Error</em> parsing JSON payload There was an <em>error</em> parsing the request JSON because of formatting <em>problems</em> or corrupted <em>data</em>. Query and alert with <em>NrIntegrationError</em> The <em>NrIntegrationError</em> <em>event</em> allows you to query and set alerts on custom <em>data</em> being sent to your New Relic account. Recommendation"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    },
    {
      "sections": [
        "Trace API general requirements and limits",
        "Endpoints",
        "Data formats",
        "Restricted attributes",
        "Request metadata (headers and query parameters)",
        "Important",
        "Response validation",
        "See HTTP status codes",
        "Data limits"
      ],
      "title": "Trace API general requirements and limits ",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Trace API"
      ],
      "external_id": "f77504082dae8374e0c7009a31abebbd4c0123f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/trace-api/trace-api-general-requirements-limits/",
      "published_at": "2021-09-01T19:28:35Z",
      "updated_at": "2021-08-27T14:05:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Information about Trace API data requirements, including: Data specifications and max limits Required metadata (headers, query parameters) Response validation details This document applies to the Trace API overall. For rules regarding specific data formats, see: New Relic-format trace data Zipkin-format trace data Endpoints All trace data is sent via HTTPS POST to a Trace API endpoint. We have a few endpoints, depending on your setup: Default Trace API endpoint: https://trace-api.newrelic.com/trace/v1 EU data centers: https://trace-api.eu.newrelic.com/trace/v1 (see other EU endpoints). Infinite Tracing: when you complete the Trace observer setup, you get a custom YOUR_TRACE_OBSERVER_URL value to use as an endpoint. If you're using an integration that uses the Trace API (for example, these integrations), you must configure that integration with that endpoint. You will also want to adjust the sampling of your tracing service to send us 100% of spans. For FedRAMP, see FedRAMP endpoints. Data formats Currently, the Trace API accepts two types of data formats: zipkin: For reporting Zipkin trace data. Zipkin data must be Zipkin JSON v2. newrelic: For reporting all other trace data. Restricted attributes The attributes in the table below are restricted in the newrelic-format JSON (in the attributes block) and in the zipkin-format JSON (in the tags block). Any values with these keys will be omitted: Restricted attribute Description entityGuid string Unique identifier for the entity that created this span. Generated from service.name, if available. guid string Used for backwards compatibility with data from APM agents. The attributes in the table below are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis: Restricted attribute description entity.guid string Unique identifier for the entity associated with this span. entity.name string Human-readable name of an entity, often used to identify an entity in the UI. entity.type string Used to differentiate between different types of entities, like hosts, applications, etc. Request metadata (headers and query parameters) The following table shows the required request metadata for all trace data formats. This metadata can be sent as HTTP headers on an ingest request or, in some cases, provided as query parameters, which may be required for tracing frameworks that don't allow header modification. Important Security note: We suggest using headers because query parameters are present in the URL and may be logged before being encrypted and received by New Relic. All data sent as query parameters must be URL-safe. Header Query param? Details Content-Type No Required. Must be application/json. Content-Length No Required. The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes (case-sensitive) Required. The Trace API requires a license key. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if compressed payload. The value must be gzip. Data-Format Yes Required for zipkin. Optional for newrelic. If present, Data-Format-Version must also be present. Data-Format-Version Yes Required for zipkin. If present, Data-Format must also be present. There are only two possible pairings for these values: If Data-Format is zipkin, Data-Format-Version must be 2. If Data-Format is newrelic, Data-Format-Version must be 1. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. Response validation A response for successfully sending trace data will include a requestId. For example: {\"requestId\":\"c1bb62fc-001a-b000-0000-016bb152e1bb\"} Copy There are two ways success/errors are signaled: HTTP status code (synchronous). Authentication and request errors will be signaled via HTTP status code. See HTTP status codes Code Meaning 202 Data accepted. This means that you've passed preliminary checks, but is not a guarantee that the data has been successfully parsed and indexed as part of a distributed trace. 400 The structure of the request was invalid. Errors with query parameters, etc. 403 Authentication error. May occur with an invalid license key or if you lack necessary entitlement to use the Trace API. 404 The request path is incorrect. 405 For any request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry). NrIntegrationError events (asynchronous). Errors with the JSON payload or other semantic errors are asynchronously signaled via NrIntegrationError events that are stored in the account whose license key is associated with the request. For all errors of this type, the attribute newRelicFeature will be Distributed Tracing and requestId will be the requestId from the endpoint response. If you receive a 202 response and don't see an NrIntegrationError event, your data should be visible in New Relic One's global distributed tracing UI in about a minute. You should be able to find the trace using a standard trace search like: traceId = TRACE_ID_SENT Copy Data limits Distributed tracing rate limits are set per account and data type. For details about data limits, see New Relic data usage limits and policies. When you exceed your span rate limit, an NrIntegrationError event is generated. You can query rate limit messages with this NRQL: SELECT * FROM NrIntegrationError WHERE newRelicFeature = 'Distributed Tracing' AND category = 'RateLimit' AND rateLimitType = 'SpansPerMinute' Copy To get a notification when you exceed the limit, you can set up a NRQL alert. We calculate a rolling 10-minute average based on your span rate limit. This allows for temporary rate bursts, and lets us prioritize keeping and dropping complete traces instead of indiscriminately dropping spans on a per minute limit basis. In the example below of exceeding the rate, the rate limit is the default 100,000 spans per minute. New Relic allows a burst above 100K for a couple of minutes without downsampling, because the remaining minutes in the 10-minute window averaged under 100K spans/minute. For the previous 10 minutes (8:50 - 9:00) the service received 60,000 spans/minute. Minute Spans sent to API Total for past 10 minutes 8:59 60,000 600,000 9:00 40,000 580,000 9:01 50,000 570,000 9:02 250,000 760,000 9:03 220,000 920,000 9:04 125,000 985,000 9:05 70,000 995,000 9:06 50,000 985,000 9:07 40,000 965,000 9:08 40,000 945,000 9:09 40,000 925,000",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 344.66397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Data</em> formats",
        "tags": "<em>Understand</em> dependencies",
        "body": " newRelicFeature will be Distributed Tracing and requestId will be the requestId from the endpoint response. If you receive a 202 response and don&#x27;t see an <em>NrIntegrationError</em> <em>event</em>, your <em>data</em> should be visible in New Relic One&#x27;s global distributed tracing UI in about a minute. You should be able to find"
      },
      "id": "6071cf7628ccbcf8b851c158"
    },
    {
      "sections": [
        "Troubleshoot Metric API with NRIntegrationError events",
        "Problem",
        "Solution",
        "View error details",
        "Match errors to ingested payloads",
        "Programmatically retrieve NrIntegrationError events",
        "Tip"
      ],
      "title": "Troubleshoot Metric API with NRIntegrationError events",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "ccf8273cce7691e5789b0c0a5c409f02efa87da3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/troubleshoot-nrintegrationerror-events/",
      "published_at": "2021-09-02T11:25:50Z",
      "updated_at": "2021-08-08T00:45:50Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You sent metric data points to the Metric API, and are not seeing what you expect when querying the data. Use the following checklist to determine the root cause: Make sure you are querying the data correctly. Check the HTTP status codes returned by the API. Issues like authorization failures can be diagnosed with HTTP status codes. If you are sending data from a Prometheus server via New Relic's remote_write endpoint, check your Prometheus server logs for errors or non-2xx HTTP responses from the New Relic endpoint. Query your account for NrIntegrationError events. New Relic's ingestion endpoints are asynchronous, meaning the endpoint verifies the payload after it returns the HTTP response. If any issues occur while verifying your payload, then an NrIntegrationError event will be created in your account. New Relic also uses NrIntegrationError events to notify customers when various rate limits have been reached. Solution View error details For an introduction to using the NrIntegrationError event, see NrIntegrationError. Here's an example NRQL for examining issues with Metric API ingest: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' facet category, message limit 100 since 24 hours ago Copy The category indicates the type of error and the message provides more detailed information about the error. If the category is rateLimit, then you should also examine the rateLimitType field for more information on the type of rate limiting. Category rateLimitType Description and solution BadRequest (not set) There is an issue with the JSON payload. These include JSON syntax errors, attribute names, or values that are too long. Check the message field to determine the exact issue. Then review the JSON payload, and update it to ensure it meets the proper semantic guidelines. RateLimit DatapointsPerMinute You are sending too many datapoints per minute. If you get this error, you can either send data less frequently, or request changes to your metric rate limits by contacting your New Relic account representative, or visiting our Support portal. RateLimit UniqueTimeseriesPerDay You have an attribute with a high number of unique values, like containerId or URI. To resolve this error, review any attributes that may be causing the issue and remove them. If desired, you can use a data dropping rule to remove attributes at ingest time. RateLimit UniquePrometheusTimeseries You have Prometheus servers reporting too many unique timeseries via New Relic's remote_write endpoint. Reduce the number of unique timeseries reported by modifying your Prometheus server configuration to reduce the number of targets being scraped, or by using relabel rules in the remote_write section of your server configuration to drop timeseries or highly unique labels. RateLimit RequestsPerMinute Too many requests per minute are being sent. To resolve this, put more datapoints in each request, and send them less frequently. RateLimit ErrorGroupsPerDay You have exceeded your daily error group limit. Incoming error groups will be dropped for the remainder of the day and will continue as normal after UTC midnight. To resolve this, reduce the amount of unique error messages collected by New Relic. Match errors to ingested payloads When an NrIntegrationError event is created as a result of a syntax issue with the HTTP request payload, then the event contains the attributes apiKeyPrefix and requestId. The apiKeyPrefix matches the first 6 characters of the API key used to send the data. The requestId matches the requestId sent in the HTTP response. To view these fields, run this NRQL query: SELECT message, apiKeyPrefix, requestId FROM NrIntegrationError limit 100 Copy To verify a specific requestId, run this NRQL query: SELECT * FROM NrIntegrationError where requestId ='REQUEST_ID' Copy Programmatically retrieve NrIntegrationError events To programmatically retrieve these errors: Ensure you have an Insights query API key (go to insights.newrelic.com > Manage data > API keys). Create an HTTP request as shown below: Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. curl -H \"Accept: application/json\" -H \"X-Query-Key:YOUR_API_KEY_HERE\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_HERE/query?nrql=SELECT%20*%20FROM%20NrIntegrationError%20where%20newRelicFeature='Metrics'\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 329.1955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot Metric API with <em>NRIntegrationError</em> <em>events</em>",
        "sections": "Troubleshoot Metric API with <em>NRIntegrationError</em> <em>events</em>",
        "tags": "<em>Ingest</em> and manage <em>data</em>",
        "body": " various rate limits have been reached. Solution View <em>error</em> details For an introduction to using the <em>NrIntegrationError</em> <em>event</em>, see <em>NrIntegrationError</em>. Here&#x27;s an example NRQL for examining issues with Metric API <em>ingest</em>: SELECT count(*) FROM <em>NrIntegrationError</em> WHERE newRelicFeature = &#x27;Metrics&#x27; facet"
      },
      "id": "610f2900196a678a5d38ad82"
    }
  ],
  "/docs/telemetry-data-platform/manage-data/query-limits": [
    {
      "sections": [
        "View system limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting limits"
      ],
      "title": "View system limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "d6ff940e92c5d1a3ae34f391e9fa3be5dfa21c2f",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/view-system-limits/",
      "published_at": "2021-09-01T19:46:21Z",
      "updated_at": "2021-08-09T00:31:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per child account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit that’s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of queries per minute and the number of records inspected (see query limits). When the number of queries per minute limit is reached, New Relic will begin rejecting queries until the number of queries is below the limit. When the records inspected limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which has these limit-related attributes: Attribute Description category RateLimit or ApiLimit. The RateLimit category is used for limits based on a unit of time such as the number of requests ingested per minute. The ApiLimit is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 206.00562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View <em>system</em> <em>limits</em>",
        "sections": "View <em>system</em> <em>limits</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ". <em>limit</em>Value The <em>limit</em> reached. <em>System</em> <em>limits</em> UI The <em>system</em> <em>Limits</em> page (from the account dropdown, click <em>Manage</em> your <em>data</em> and click <em>Limits</em> on the left) displays when your account has encountered a rate <em>limit</em> in the specified time period. The page displays a default period of 24 hours; you can set"
      },
      "id": "60446a7c64441f48d7378f2b"
    },
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.80554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the <em>Metric</em> API",
        "sections": "Alert on <em>metric</em> <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": " on <em>limits</em> and restricted attributes, see <em>Metric</em> API requirements and <em>limits</em>. Get started If we don&#x27;t have an existing integration that meets your <em>metric</em>-reporting needs, you have two options: Use our <em>Telemetry</em> SDKs, which are language-specific tools that help you send us <em>metrics</em> and other <em>data</em>. Use"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.80554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>metrics</em> via the <em>Metric</em> API",
        "sections": "Report <em>metrics</em> via the <em>Metric</em> API",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the <em>Metric</em> API to send custom <em>metrics</em> to the New Relic <em>platform</em>. This document includes a quick start to send your first custom <em>metric</em>, plus detailed information on how to format and send your <em>metric</em> <em>data</em>. Quick start: Send <em>metric</em> <em>data</em> We report the <em>metric</em> types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    }
  ],
  "/docs/telemetry-data-platform/manage-data/view-system-limits": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.0226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> APIs. The Metric API can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 286.0226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick start: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.52652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric <em>data</em> point may cause undefined behavior such as missing entities in the UI or <em>telemetry</em> not associating with the expected entities. For more"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/customized-security-settings-insights": [
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "217bc4ed58acefe9175df8be18fdf81baba7cf81",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-09-02T11:26:54Z",
      "updated_at": "2021-05-15T09:09:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.78183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Default</em> <em>events</em> reported by New Relic products",
        "sections": "<em>Default</em> <em>events</em> reported by New Relic products",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "New Relic products report different types of <em>data</em>. One type of <em>data</em> reported is <em>event</em> <em>data</em>. <em>Events</em> are displayed in UI charts and tables, and also made available for querying. To understand the types of <em>data</em> available, see <em>Data</em> available via NRQL. Learn more about the <em>events</em> reported by New Relic"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "sections": [
        "Events reported by synthetic monitoring"
      ],
      "title": "Events reported by synthetic monitoring",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "b6122126a390d40ee68c246abdb66fc2c0211a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/events-reported-synthetic-monitoring/",
      "published_at": "2021-09-02T11:52:24Z",
      "updated_at": "2021-05-15T09:09:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring in New Relic reports event data that is displayed in some UI displays and is also available for querying and charting. Select an event name in the following table to see its attributes. Event Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific monitor. These metrics include duration information for the monitor, location of the monitor check, size of the request and response headers, the type of monitor, and a timestamp. Each time a synthetic monitor runs a check, details about the check are captured in theSyntheticCheck event type. SyntheticCheck events contain details specific to the check to provide visibility such as the status, type of monitor, and size of request and response headers. SyntheticRequest SyntheticRequest returns results from individual HTTP requests made during a check. The data gathered include job information, location, type of content for request, duration information, request size, and page load information. With each simple or scripted monitor check, we capture each individual HTTP request made during the check. The HTTP details are captured at a more granular level than the SyntheticCheck event type. SyntheticPrivateLocationStatus Every monitor check running on a private location triggers capacity details for that private location. These details are captured in a SyntheticPrivateLocationStatus event. This provides visibility into the capacity of a private location and whether additional minions are required to support the workload. SyntheticPrivateMinion If you have private locations, such as those inside your firewall, you can view information regarding those locations with the SyntheticPrivateMinion event. Each private minion running sends health details to SyntheticPrivateMinion every 30 seconds. This allows you to understand the health of the private minion running at the location. Related documentation: Report custom events Extend data retention See example NRQL queries",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.78183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Events</em> reported by synthetic monitoring",
        "sections": "<em>Events</em> reported by synthetic monitoring",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Synthetic monitoring in New Relic reports <em>event</em> <em>data</em> that is displayed in some UI displays and is also available for querying and charting. Select an <em>event</em> name in the following table to see its attributes. <em>Event</em> Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific"
      },
      "id": "609f8faf64441f8e99d2a1d5"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-09-01T21:23:26Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.73724,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Insights</em> Dashboard API",
        "sections": "<em>Insights</em> Dashboard API",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " and DELETE endpoints are not available. To make the transition from the <em>Insights</em> Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts <em>data</em> in the EU <em>data</em> center"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/default-events-reported-new-relic-products": [
    {
      "sections": [
        "Security for New Relic-reported events and attributes",
        "Default events and attributes",
        "Adjust the data reported"
      ],
      "title": "Security for New Relic-reported events and attributes ",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "af971d2b95ff397b57bf125f6801f57007ea5e77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/customized-security-settings-insights/",
      "published_at": "2021-09-02T11:25:51Z",
      "updated_at": "2021-05-15T09:10:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, New Relic products report a variety of data used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. Default events and attributes Our products report a set of default events and attributes. We will never send request parameters or any other attributes that are not in the default set, unless someone has explicitly enabled this via configuration. Adjust the data reported When evaluating security settings for a New Relic product, review the default events and attributes. The default attributes don't contain sensitive data. In general, it's simply the data needed for effective performance monitoring. Our products don't send other data unless you change the default security settings. Depending on your requirements, either or both of these situations may apply: If the default list contains data you're concerned about, you can disable those attributes from being collected. For how to edit that, see the documentation for the product you're using. If you need to send attributes not reported by default, you can enable those attributes to be reported. In that case, do not use high security mode: this will disable the ability to collect custom attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.78192,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for New Relic-reported <em>events</em> and attributes ",
        "sections": "<em>Default</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "By <em>default</em>, New Relic products report a variety of <em>data</em> used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. <em>Default</em> <em>events</em> and attributes Our products report a set of <em>default</em> <em>events</em>"
      },
      "id": "60a8ea67e7b9d25ec7aeabfe"
    },
    {
      "sections": [
        "Events reported by synthetic monitoring"
      ],
      "title": "Events reported by synthetic monitoring",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "b6122126a390d40ee68c246abdb66fc2c0211a91",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/events-reported-synthetic-monitoring/",
      "published_at": "2021-09-02T11:52:24Z",
      "updated_at": "2021-05-15T09:09:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Synthetic monitoring in New Relic reports event data that is displayed in some UI displays and is also available for querying and charting. Select an event name in the following table to see its attributes. Event Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific monitor. These metrics include duration information for the monitor, location of the monitor check, size of the request and response headers, the type of monitor, and a timestamp. Each time a synthetic monitor runs a check, details about the check are captured in theSyntheticCheck event type. SyntheticCheck events contain details specific to the check to provide visibility such as the status, type of monitor, and size of request and response headers. SyntheticRequest SyntheticRequest returns results from individual HTTP requests made during a check. The data gathered include job information, location, type of content for request, duration information, request size, and page load information. With each simple or scripted monitor check, we capture each individual HTTP request made during the check. The HTTP details are captured at a more granular level than the SyntheticCheck event type. SyntheticPrivateLocationStatus Every monitor check running on a private location triggers capacity details for that private location. These details are captured in a SyntheticPrivateLocationStatus event. This provides visibility into the capacity of a private location and whether additional minions are required to support the workload. SyntheticPrivateMinion If you have private locations, such as those inside your firewall, you can view information regarding those locations with the SyntheticPrivateMinion event. Each private minion running sends health details to SyntheticPrivateMinion every 30 seconds. This allows you to understand the health of the private minion running at the location. Related documentation: Report custom events Extend data retention See example NRQL queries",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.78181,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Events</em> reported by synthetic monitoring",
        "sections": "<em>Events</em> reported by synthetic monitoring",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "Synthetic monitoring in New Relic reports <em>event</em> <em>data</em> that is displayed in some UI displays and is also available for querying and charting. Select an <em>event</em> name in the following table to see its attributes. <em>Event</em> Description SyntheticCheck SyntheticCheck returns metrics from one run of a specific"
      },
      "id": "609f8faf64441f8e99d2a1d5"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-09-01T21:23:26Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.73723,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Insights</em> Dashboard API",
        "sections": "<em>Insights</em> Dashboard API",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " and DELETE endpoints are not available. To make the transition from the <em>Insights</em> Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts <em>data</em> in the EU <em>data</em> center"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/events-reported-apm": [
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "217bc4ed58acefe9175df8be18fdf81baba7cf81",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-09-02T11:26:54Z",
      "updated_at": "2021-05-15T09:09:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 303.32697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Default <em>events</em> <em>reported</em> <em>by</em> New Relic products",
        "sections": "Default <em>events</em> <em>reported</em> <em>by</em> New Relic products",
        "tags": "Default <em>events</em>",
        "body": "New Relic products <em>report</em> different types of data. One type of data <em>reported</em> is <em>event</em> data. <em>Events</em> are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the <em>events</em> <em>reported</em> by New Relic"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "sections": [
        "Manage error data",
        "Error data types: events and trace details",
        "Events",
        "Trace details",
        "Caps on error reporting",
        "Charting error rates and counts",
        "Report custom errors",
        "Ignore errors",
        "Reduce noise with expected errors",
        "Disable error traces",
        "Delete error traces",
        "Caution"
      ],
      "title": "Manage error data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "29a2ebdc7b91029a1fada50791b90e9dc548f17e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/manage-error-data/",
      "published_at": "2021-09-02T03:10:50Z",
      "updated_at": "2021-03-13T03:03:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM Errors page helps you identify, triage, and fix errors in your services. The Errors page uses data collected by the APM agent to display stack traces, transaction attributes such as HTTP header values, and any other custom attributes, so you can understand the context of the error and fix it. Error data types: events and trace details By default, our APM agents collect two type of error data: Events Trace details Events The error event data type includes default attributes, as well as any custom attributes instrumented in your service. It doesn't include a stack trace. Find your events data in the Errors UI as follows: The Errors column in the Error traces table. The Top 5 errors chart. When you’ve drilled into a grouping of errors, those errors not displaying a stack trace are based on this type of data. You can disable Show only errors with stack trace to show errors that have this type of data collected, but no associated trace details. Events are subject to sampling (see Caps on error reporting and Charting error rates and counts). For more on error event data, see Events reported by APM. Trace details The trace details error data type includes stack traces and attributes, and supplements events with more data. It's expected that more events will be reported than trace details--see Caps on error reporting. Find your trace details data in the Errors UI as follows: The “Stack traces” column of the Error traces table. When you’ve drilled into a grouping of errors, those errors with a stack trace use this type of data: Show only errors with stack trace is enabled by default, to constrain the errors shown to just those that have this type of data collected. This data is governed by specific retention rules for Error details. Caps on error reporting New Relic caps error reporting at: 100 events per minute per agent instance 20 trace details per minute per agent instance These caps prevent error reporting from negatively impacting application performance. Examples: App running across five EC2 instances, one JVM each. New Relic caps error reporting at: 100 events per minute x 5 instances = 500 events per minute 20 trace details per minute x 5 instances = 100 trace details per minute App running on one host with ten instances. New Relic caps error reporting at: 100 events per minute x 10 instances = 1000 events per minute 20 trace details per minute x 10 instances = 200 events per minute Charting error rates and counts The Error rate chart is driven by a query on metric timeslice data, which is an unsampled aggregate data type that is accurate but has very limited dimensionality. This data can't be faceted or filtered as flexibly as error event data. You can reproduce this chart in a dashboard, or explore the metric timeslice data further by clicking the ... menu on the Error rate chart, and then using the View query or Add to dashboard options. To chart faceted error counts using event data, as in the Top 5 errors chart, use an NRQL event query. Click the ... menu on the Top 5 errors chart and choose View query for a starting point in creating your chart. Since event data can be sampled (see Caps on error reporting), you can use the EXTRAPOLATE keyword to get an accurate error count, even if sampling is occurring. Report custom errors You can report errors not collected by default with our agents using our agent APIs. For more, see the documentation on the API. Ignore errors You can prevent certain errors that would normally be reported to New Relic from being collected using our agent APIs or the server-side configuration UI. For more details, see Manage errors in APM. Reduce noise with expected errors Sometimes you want to collect error data, but not have those errors wake you up through alerts. Using the agent API, you can mark such errors as “expected”. They’ll still be visible in the Errors page, but won’t affect your service’s error rate or Apdex metrics. Disable error traces To prevent certain errors from being reported to New Relic, disable them in your agent's configuration file. For most agents, you can ignore certain error codes or disable errors completely. For more information, see your specific agent's configuration documentation: C SDK Go (not applicable; the agent only reports errors when configured to do so) Java .NET Node.js PHP Python Ruby Delete error traces Caution You cannot recover error traces after you delete them. Deleting errors is currently only available in the legacy Errors Classic UI. If you want to... Do this... Delete all error traces for your app If you have permissions to delete all error traces for an app: Go to one.newrelic.com > APM > (select an app) > More views > Errors (classic). Select Delete all errors. Delete all error traces for your account To delete all error traces for your New Relic account, get support at support.newrelic.com. Delete individual error traces To delete individual error traces, use New Relic APM's Errors (classic) page. Drill into an error from the table of errors, then click Delete this error. In addition to deleting error traces, you may also want to delete transaction traces or database/slow SQL traces. This will remove potentially sensitive data while retaining your other application data (such as Apdex, deployment information, etc.).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.44609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Error data types: <em>events</em> and trace details",
        "tags": "<em>APM</em>",
        "body": " that have this type of data collected, but no associated trace details. <em>Events</em> are subject to sampling (see Caps on error reporting and Charting error rates and counts). For more on error <em>event</em> data, see <em>Events</em> <em>reported</em> by <em>APM</em>. Trace details The trace details error data type includes stack traces"
      },
      "id": "6044077e28ccbcab752c60d1"
    },
    {
      "sections": [
        "Event data retention (original pricing plan)",
        "Important",
        "Data retention UI",
        "Overview of event data retention",
        "Extend your event retention",
        "Insights Pro",
        "How number of events stored is calculated",
        "Insights Pro event overage example",
        "Disable/enable Transaction and Pageview event reporting",
        "Tip",
        "Flexible data retention",
        "How it works",
        "Manage retention via UI",
        "Glossary",
        "For more help"
      ],
      "title": "Event data retention (original pricing plan)",
      "type": "docs",
      "tags": [
        "Accounts",
        "Original accounts and billing",
        "Original data retention"
      ],
      "external_id": "76d1289aad7de08b355bb8c313f9e7a42a5779d8",
      "image": "https://docs.newrelic.com/static/e53a1e416eb6116545627d3ec880d08e/e9c9b/flex-2.png",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-data-retention/event-data-retention-original-pricing-plan/",
      "published_at": "2021-09-01T19:33:00Z",
      "updated_at": "2021-08-27T08:49:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important This doc is for accounts on our original pricing plan, not our New Relic One pricing plan. Not sure which you're on? See Overview of pricing plans. For organizations on New Relic One pricing, our various New Relic products report a wide range of event data. Different products have different data retention periods, and different ways to extend event data retention. You can customize the length of your event data retention through flexible event retention. Data retention UI For how to find the data retention UI, see Manage data. Overview of event data retention All New Relic product subscriptions come with a certain level of data retention that governs how long different types of data are retained. One type of data governed by data retention rules is event data. Event data is available in some UI charts and tables, and also available for querying via NRQL, our querying language. There are events reported from products by default, and there are custom events: each have their own retention rules, depending on the product and subscription level. Here are some examples of how different product subscriptions can affect event data retention: Free/Lite APM subscription: default-reported events available for 1 day. No custom events available. Pro APM subscription: default-reported events available for 8 days. Custom events available for 1 day (and able to be extended with Insight Pro). To see your subscriptions, go to the Account summary page. Extend your event retention Product Method APM, Browser, and Mobile Event data retention can be extended with a paid subscription to these products (see product data retention). To extend retention of both default-reported events and custom events further, you need an Insights Pro subscription. Infrastructure Event data retention can be extended with a paid Infrastructure subscription. See Infrastructure data retention rules. Synthetics Event data retention can be extended with a paid Synthetics subscription. See Synthetics data retention rules. Custom events Custom events reported by agent APIs or the Event API: Extension requires an Insights Pro subscription. Insights Pro Important As of April 12, 2021, we are upgrading Insights to an improved web and mobile experience! All of your Insights URLs will be redirected automatically to the corresponding dashboards in New Relic One. For more details about this migration and how you can easily plan for this transition, see our Explorers Hub post. A paid Insights subscription is what governs the extension of event data retention for: Our APM, Browser, Mobile, and Serverless products Custom events that come from an agent API or from the Event API Important Note that having an Insights Pro subscription doesn't require use of the Insights UI (insights.newrelic.com) to query your data: there are other querying options available. To see the data retention governed by your Insights subscription: go to the usage UI and select Insights usage. With an Insights Pro subscription, you can use flexible retention to customize how your event data is retained. This lets you keep only the data you need, for as long as you need it. How number of events stored is calculated This is an explanation of how the number of stored events are calculated by default for an Insights Pro subscription. (Note that with flexible retention, you have more fine-grained control over the retention period.) The events stored is calculated based on 1) total events stored over time (calculated based on the events generated per week) and 2) the weeks of data retention available. This equation can be represented like this: events stored = (events generated per week) * (weeks of retention) Copy An Insights Pro subscription provides a given number of weeks of data retention as well as a given number of events over that retention period. For example: (200M transactions per week) * (4 weeks of retention) = 800M events stored in Insights (16M transactions per week) * (50 weeks of retention) = 800M events stored in Insights For Insights Pro subscriptions, data is purged based on retention window, not volume. It is deleted from the system once it's past the retention window. For example: If your Insights license is for 800 million events with a 4 week retention period, your data would start being purged after it is older than four weeks. Temporary spikes in data exceeding your subscription level will still be recorded, but consistent overage should be solved by upgrading your subscription level or decreasing data collected. For customers without an Insights Pro subscription, New Relic may throttle or downsample events to a limit of not more than than 4,000 events per host per minute. Insights Pro event overage example In this example, you have an Insights Pro subscription with a license for 800 million events over 4 weeks, a rate of 200 million events per week. You have APM Pro, Browser Pro, and Mobile Enterprise. A fifth week of data is added via your subscriptions, bumping you to a total of 1 billion events stored within your plan: If you are using 975 million events, you are not over your retention. If you are using 1.25 billion events, you are over your retention. Disable/enable Transaction and Pageview event reporting Tip Owners or Admins The Insights Data summary UI page is used to see the types of events being reported. You can also use this page to enable and disable the reporting of PageView and Transaction events. To view Data summary: Go to insights.newrelic.com > Manage data. Select the Summary tab. Note: if you disable PageView or Transaction event reporting, this can affect some New Relic UI elements. You may see some empty charts on some UI pages that rely on this data. Go to insights.newrelic.com > Manage data > Summary. From the Summary tab, select Configure data sources. Toggle the appropriate switch on or off, then save. Toggling Transaction on or off will cause reporting agents to restart themselves. For more about configuring event reporting, see Event data retention. Flexible data retention With an Insights Pro subscription, you get access to flexible retention, which lets you define how some types of event data are retained. This lets you keep only the event data you need, for as long as you need it. You can manage your flexible retention through the UI or through our GraphQL API. Requirements to use this feature: An Insights Pro subscription or equivalent trial. Applies only for events governed by an Insights Pro subscription. To use this feature, you must be an account Owner or data retention add-on manager for your account. How it works To understand how standard event data retention works, first read Event data retention. With flexible retention, you specify the data retention for applicable event namespaces across your accounts. This gives you per-event namespace control of your data. The retention that you specify for an event namespace will be shared by all the event types under that namespace. If some namespaces are not relevant to you, you can avoid collecting their event data entirely. Your retention value can’t be lower than the included retention or higher than the default retention. You can control data retention either in our UI or by API. Manage retention via UI You can control data retention either using our GraphQL API or in the UI. To do this with the UI, go to the data retention UI. Your retention changes take effect within 24 hours after updating. Glossary To understand the terms used with flexible retention, see the following: Term Description Event namespace An event's namespace corresponds to one or more event types that share a single data retention value. For more information, see Event namespaces (types). You can also use NerdGraph to get the list of customizable event namespaces. Retention value The number (in days) that specifies how long your event data is stored. Retention rule The event namespace and retention value pair that you specify to override the current retention. Licensed retention Retention period that’s determined in weeks by your Insights Pro subscription contract. Included retention Retention period for which your data is stored but not charged under the Insights Pro subscription. For details, see the data retention details for a specific product. Paid retention Retention period for which your data is stored and is charged under the Insights Pro subscription. By default, your licensed retention determines this value but Flexible retention lets you override it. Default retention Retention period that comes out of the box. This is based on the total of included retention plus licensed retention. For information on managing retention settings with APIs, see the Manage data retention documentation. For more help For details about the data retention of other products or integrations, see that specific documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.512764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Event</em> data retention (original pricing plan)",
        "sections": "Disable&#x2F;enable Transaction and Pageview <em>event</em> <em>reporting</em>",
        "body": ". There are <em>events</em> <em>reported</em> from products by default, and there are custom <em>events</em>: each have their own retention rules, depending on the product and subscription level. Here are some examples of how different product subscriptions can affect <em>event</em> data retention: Free&#x2F;Lite <em>APM</em> subscription: default"
      },
      "id": "6043f713e7b9d2ccee579a1d"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/events-reported-browser-monitoring": [
    {
      "sections": [
        "Build a custom New Relic One application",
        "Get started",
        "New Relic One: a programmable platform",
        "Tip"
      ],
      "title": "Build a custom New Relic One application ",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Build on New Relic One"
      ],
      "external_id": "0fd7afcf4cd3c15157668bf349e84968062140ed",
      "image": "https://docs.newrelic.com/static/2caff7bdf3bb0fb46bee7c214448c921/c1b63/new-relic-one-browser-analyzer-example-application_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/build-new-relic-one/build-custom-new-relic-one-application/",
      "published_at": "2021-09-01T22:39:40Z",
      "updated_at": "2021-07-27T13:37:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic gives you a framework to build your own React JavaScript applications that: Reside on the New Relic One platform, alongside your other dashboards and data. Feature visualizations that you've tailored specifically for your organization. Display data from any source you want, whether from a New Relic-monitored entity or data from another service or API. Get started Keep reading to learn more about what you can do with New Relic One apps. If you want to get started building quickly, first read the requirements. New Relic One: a programmable platform We strive to have an automated user experience that provides optimal value for all users. But we also know that some organizations have unique business needs that can’t be met with our standard visualization options. Now, we give you control over the fundamental building blocks of our platform. Using the same tools our engineers use to build New Relic One, you can build custom applications that align with your unique organizational structure and business needs. If you know how to use React, GraphQL, and NRQL (our query language), building an application will take you only a few minutes. Check out these guides for help building custom applications. Solve any data-driven challenge, no matter how complex. You can: Use our APIs to get data into New Relic from any source. Visualize that data in your custom applications. one.newrelic.com: Here’s an example of a custom application built on New Relic One. This application gives a highly detailed analysis of a website, using the PageView events reported from New Relic's browser monitoring. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 457.50687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a highly detailed analysis of a website, using the PageView <em>events</em> <em>reported</em> from New Relic&#x27;s <em>browser</em> <em>monitoring</em>. Tip If your visualization needs are relatively simple, consider using custom charts and custom dashboards. Now, visit our developer site and start building!"
      },
      "id": "603eaaa6e7b9d251572a07d0"
    },
    {
      "sections": [
        "Compatibility and requirements for browser monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-09-02T06:45:42Z",
      "updated_at": "2021-09-02T06:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the browser agent, make sure your system meets these requirements. Want to try out our browser monitoring? Create a New Relic account for free! No credit card required. Basic requirements To report data to browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the browser agent for apps monitored by APM, or you can deploy the browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying browser for an app using APM, make sure your agent supports browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use our SPA monitoring features, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with browser. In all cases, the browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our Pro+SPA agent due to the way this library wraps promises. If you're using this library, we recommend selecting the Pro agent type. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organization’s standard procedures in order to install the browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.55844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "sections": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " and iPad IE 7 and 8 PageAction <em>events</em> PageAction <em>events</em> require a <em>browser</em> that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction <em>events</em>. Learn more on querying your data. Session traces Session traces are <em>reported</em> only from browsers that support"
      },
      "id": "603ed6b664441f4a784e883f"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-09-02T03:08:55Z",
      "updated_at": "2021-08-27T07:49:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Full-Stack Observability Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.76785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "Introduction to <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the <em>browser</em> <em>monitoring</em> agent. The PageViewTiming <em>event</em> provides a more real-time delivery mechanism that does"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/events-reported-mobile-monitoring": [
    {
      "sections": [
        "Mobile apps index",
        "View your list of mobile apps",
        "Standard menu functions"
      ],
      "title": "Mobile apps index",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Mobile app pages"
      ],
      "external_id": "38ff00ca55b0ca25a0ad534b57e02b01f4040c97",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/mobile-app-pages/mobile-apps-index/",
      "published_at": "2021-09-01T23:55:24Z",
      "updated_at": "2021-08-27T07:51:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's mobile monitoring UI includes a mobile app index that shows a list of your monitored apps and important summary information about them. View your list of mobile apps To see the mobile apps index, go to [one.newrelic.com > Explorer > Mobile applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com > Mobile. The index of available mobile apps includes a colored health status indicating: Green = Normal Yellow = Warning Red = Critical Gray = Not reporting data Standard menu functions To view details for a specific app, select it from the index. Here are some other functions available from the index: If you want to... Do this... View the app's status Mouse over the mobile app's colored health status indicator. If the health status indicator is gray and no data is being reported, you likely need to finish installing mobile monitoring. Monitor another app Select Add more. See the app's metadata To see the app's metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.73193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Mobile</em> apps index",
        "sections": "<em>Mobile</em> apps index",
        "tags": "<em>Mobile</em> <em>monitoring</em>",
        "body": " status indicator is gray and no data is being <em>reported</em>, you likely need to finish installing <em>mobile</em> <em>monitoring</em>. <em>Monitor</em> another app Select Add more. See the app&#x27;s metadata To see the app&#x27;s metadata, including its app ID, entity GUID, and more, click the icon next to the application name. For more about UI functions, see Basic UI functions."
      },
      "id": "604537fc64441f7903378f35"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2021-09-03T01:48:34Z",
      "title": "New Relic data dictionary",
      "updated_at": "2021-09-02T01:48:04Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. (This attribute doesn't exist for initial page load events.) AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. AjaxRequest BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. BrowserInteraction ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. (This attribute doesn't exist for initial page load events.) AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. (This attribute doesn't exist for initial page load events.) AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. AjaxRequest BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Here’s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (e.g., a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute ‘timestamp’, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileSession MobileRequestError device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileSession MobileRequestError deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileSession MobileRequestError deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileSession MobileRequestError runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileSession MobileRequestError device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileSession MobileRequestError deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileSession MobileRequestError deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileSession MobileRequestError deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileSession MobileRequestError requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileSession MobileRequestError trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileSession MobileRequestError device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileSession MobileRequestError deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileSession MobileRequestError deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileSession MobileRequestError deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileSession MobileRequestError requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileSession MobileRequestError trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileSession MobileRequestError PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileSession MobileRequestError device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileSession MobileRequestError deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileSession MobileRequestError deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileSession MobileRequestError deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileSession MobileRequestError sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileSession MobileRequestError upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileSession MobileRequestError NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system. NetworkSample ipV4Address The IP version 4 address. NetworkSample ipV6Address The IP version 6 address. NetworkSample kernelVersion The Linux kernel version, in string format. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample linuxDistribution The name of the Linux distribution the server is using. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample operatingSystem The operating system on which the agent is installed. NetworkSample ProcessSample StorageSample SystemSample receiveBytesPerSecond bytes (B) The number of bytes per second received during the sampling period. NetworkSample receiveDroppedPerSecond count The number of received packets per second dropped during the sampling period. NetworkSample receiveErrorsPerSecond count The number of receive errors per second on the interface during the sampling period. NetworkSample receivePacketsPerSecond count The number of packets per second (as defined by OS) received during the sampling period. NetworkSample state The state of the entity: either up or down. NetworkSample timestamp The time (date, hour, minute, second) at which the interaction occurred. NetworkSample ProcessSample StorageSample SystemSample transmitBytesPerSecond bytes (B) The number of bytes sent per second during the sampling period. NetworkSample transmitDroppedPerSecond count The number of dropped send packets per second during the sampling period. NetworkSample transmitErrorsPerSecond count The number of send errors per second on the interface during the sampling period. NetworkSample transmitPacketsPerSecond count The number of packets per second as defined by OS) sent during this sampling period. NetworkSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample windowsFamily The ",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.233826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mobile</em>",
        "body": " for iOS devices. <em>Mobile</em> name For interaction category <em>events</em> only. This is the label of the interaction associated with the <em>event</em>. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. <em>Mobile</em> <em>reported</em>TimestampMs For interaction"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "sections": [
        "FedRAMP-compliant endpoints",
        "Customer FedRAMP obligations",
        "Overview of data sources",
        "Agents",
        "APM agents",
        "Mobile monitoring agents",
        "Infrastructure monitoring",
        "Infrastructure agent versions below 1.15.0",
        "Browser agent",
        "Data-ingest APIs",
        "Metric API",
        "Telemetry integrations",
        "Telemetry SDKs",
        "Event API",
        "Log API",
        "Log forwarders",
        "Trace API"
      ],
      "title": "FedRAMP-compliant endpoints",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "ffce8ad6f802717392aca80e0965c9f3fe77ffdf",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/fedramp-compliant-endpoints/",
      "published_at": "2021-09-02T16:35:51Z",
      "updated_at": "2021-09-02T16:35:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides information on FedRAMP-compliant endpoints in New Relic. For more information about our security accreditation for the Federal Risk and Authorization Management Program (FedRAMP), see our data encryption documentation. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features (see below). Overview of data sources There are multiple ways to get data into New Relic. This doc has two sections: Agent settings: for our APM agents, infrastructure agent, browser agent, and mobile agent. Data-ingest APIs: for our Metric API, Event API, Trace API, and Log API, and the integrations that use those APIs. Agents New Relic has several agents for reporting data, like our APM agents, infrastructure agents, mobile agents, and browser agent. Setting these agents to send FedRAMP-compliant data involves setting a configuration setting to use the relevant FedRAMP endpoint. APM agents To ensure FedRAMP compliance, all APM agent configurations must report to gov-collector.newrelic.com rather than the default. Depending on the agent, you can either use code-based configuration or an environment variable. Here are details on enabling this: Language Code or environment variable C SDK In code: strcpy(_newrelic_app_config_t->redirect_collector, \"gov-collector.newrelic.com\"); Copy Environment variable: none Go In code: app, err = newrelic.NewApplication( newrelic.ConfigAppName(\"App Name\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), func(cfg *newrelic.Config) { cfg.Host = \"gov-collector.newrelic.com\" }, ) Copy Environment variable: NEW_RELIC_HOST Java In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Or set a system property of: newrelic.config.host Copy Environment variable: NEW_RELIC_HOST .NET In your XML config next to the license key: <service licenseKey=\"YOUR_LICENSE_KEY\" host=\"gov-collector.newrelic.com\"/> Copy Environment variable: NEW_RELIC_HOST Node.js In newrelic.js: host: 'gov-collector.newrelic.com' Copy Environment variable: NEW_RELIC_HOST PHP In newrelic.ini: newrelic.daemon.collector_host = gov-collector.newrelic.com Copy Environment variable: none Python In newrelic.ini: [newrelic] host = gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Ruby In newrelic.yml: common: &default_settings host: gov-collector.newrelic.com Copy Environment variable: NEW_RELIC_HOST Elixir (open source agent) In config.exs: config :new_relic_agent, host: \"gov-collector.newrelic.com\" Copy Environment variable: NEW_RELIC_HOST For more on configuring APM agents, see APM configuration. Mobile monitoring agents To ensure FedRAMP compliance when using our mobile monitoring agents, all agent configurations must report to gov-mobile-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables are not available. Framework-specific configurations: Agent Code or environment variable Android In code: NewRelic.withApplicationToken({APP_TOKEN}) .usingCollectorAddress(\"gov-mobile-collector.newrelic.com\") .usingCrashCollectorAddress(\"gov-mobile-crash.newrelic.com\") .start(this.getApplication()); Copy Environment variable: none iOS In code: [NewRelic startWithApplicationToken:@\"{APP_TOKEN}\" andCollectorAddress:@\"gov-mobile-collector.newrelic.com\" andCrashCollectorAddress:@\"gov-mobile-crash.newrelic.com\"]; Copy Environment variable: none Infrastructure monitoring If you have infrastructure agent version 1.15.0 or higher, simply enable the FedRAMP configuration option. This enables FedRAMP compliancy for data reported by the infrastructure agent, and for any on-host integrations that work with the infrastructure agent to report data. If you have an older agent version, use the following values to edit your YAML configuration: Infrastructure agent versions below 1.15.0 If you have an infrastructure agent version below 1.15.0, you must change three of the endpoints used for reporting. To set these endpoints, you can change your YAML configuration or use environment variables. YAML config field Endpoint URL collector_url https://gov-infra-api.newrelic.com Copy identity_url https://gov-identity-api.newrelic.com Copy command_channel_url https://gov-infrastructure-command-api.newrelic.com Copy To edit environment variables, use these values: Environment variable Endpoint URL NRIA_COLLECTOR_URL https://gov-infra-api.newrelic.com Copy NRIA_IDENTITY_URL https://gov-identity-api.newrelic.com Copy NRIA_COMMAND_CHANNEL_URL https://gov-infrastructure-command-api.newrelic.com Copy Browser agent To configure the browser agent to use a FedRAMP-compliant endpoint, you must use the copy-paste method method (other browser agent install methods are not supported) and edit the browser code’s script element tag so that the domain is gov-bam.nr-data.net for both beacon and errorBeacon, like this: window.NREUM||(NREUM={});NREUM.info={\"beacon\":\"gov-bam.nr-data.net\",\"errorBeacon\":\"gov-bam.nr-data.net\"... Copy Note: You only need to modify the beacon and errorBeacon properties in the NREUM.info object. These values will override the default values found in the NR loader script. Data-ingest APIs Below are details about the FedRAMP endpoint for our ingest APIs: Metric API, the Event API, the Log API, and the Trace API. Metric API To ensure FedRAMP compliance when using the Metric API, instead of sending metric data to the default Metric API endpoint of https://metric-api.newrelic.com/metric/v1, it must be sent to https://gov-metric-api.newrelic.com/metric/v1. The Metric API can be used directly but it's mainly used by various New Relic tools. Below are instructions showing where to edit the configuration for setting the FedRAMP endpoint. Telemetry integrations Here are instructions for our open source telemetry integrations that report metric data: Dropwizard: use the overrideUri configuration. Kamon: use the metric-ingest-url configuration. See Override endpoints. Micrometer: override the public String uri() method on your NewRelicRegistryConfig to return the new endpoint. See an example. Prometheus: Prometheus OpenMetrics: if you are using our nri-prometheus helm chart, you can change the endpoint in your values.yml file, like in this example. If you're using the nri-bundle chart, you need to nest this value under the nri-prometheus key to propagate it to the sub-chart. Remote write integration: not available. Telemetry SDKs Here are instructions for our Telemetry SDKs that report metric data: Go: use the MetricsURLOverride configuration. Java: in the MetricBatchSender section, configure the endpoint. See an example. .NET: use the MetricUrlOverride configuration. Node.js: edit the METRIC_HOST = 'metric-api.newrelic.com' configuration. Python: edit the HOST = \"metric-api.newrelic.com\" configuration. Event API To ensure FedRAMP compliance for the Event API, all traffic reporting to insights-collector.newrelic.com must instead report to gov-insights-collector.newrelic.com. The Event API endpoint is configurable for the following Telemetry SDKs. The Telemetry SDKs are used by our open-source telemetry integrations. Language Solution Java Telemetry SDK In code: SenderConfiguration configuration = SenderConfiguration .builder( \"gov-insights-collector.newrelic.com\", EventBatchSender.EVENTS_PATH) .build(); EventBatchSender eventBatchSender = EventBatchSender.create(configuration); Copy Python Telemetry SDK In code: event_client = EventClient(host=\"gov-insights-collector.newrelic.com\") Copy For more information, see our Telemetry API documentation in GitHub. Log API To ensure FedRAMP compliance for data sent via the Log API, the solution for almost all our logging tools is to replace the https://log-api.newrelic.com/log/v1 endpoint with https://gov-log-api.newrelic.com/log/v1. Here are details for various tools: Log forwarders Here are details on changing the endpoint for our log forwarders: AWS Firelens: Add the endpoint property to the options field of the logConfiguration, similar to to the EU account endpoint change shown in these Firelens endpoint configuration instructions. Fluentbit: Use our Fluentbit endpoint configuration. Fluentd: Use our Fluentd endpoint instructions. Infrastructure agent: See FedRAMP for infrastructure. Kubernetes: Our Kubernetes integration logs are based on fluentbit’s output plugin. Use these endpoint instructions. Logstash: Use our Logstash endpoint configuration. Syslog: For configuring syslog clients, see TCP endpoint configuration. S3: Not available. Vector: Not available. To use the Log API directly, you'd edit the Log API endpoint configuration. Trace API To ensure FedRAMP compliance for data sent via the Trace API (including telemetry integrations that use this API), replace the https://trace-api.newrelic.com/trace/v1 endpoint with https://gov-trace-api.newrelic.com/trace/v1. Notes about FedRAMP compliance for other trace data: Trace data is reported by some of our agents, like our APM agents, browser agent, and mobile agent. To enable FedRAMP compliance for that data, you would enable FedRAMP for the applicable agent. Currently Infinite Tracing is not FedRAMP compliant.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.65278,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mobile</em> <em>monitoring</em> agents",
        "body": " on configuring APM agents, see APM configuration. <em>Mobile</em> <em>monitoring</em> agents To ensure FedRAMP compliance when using our <em>mobile</em> <em>monitoring</em> agents, all agent configurations must <em>report</em> to gov-<em>mobile</em>-collector.newrelic.com rather than the default. You must use code-based configuration. Environment variables"
      },
      "id": "603e945164441f64384e8872"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/events-reported-synthetic-monitoring": [
    {
      "sections": [
        "Security for New Relic-reported events and attributes",
        "Default events and attributes",
        "Adjust the data reported"
      ],
      "title": "Security for New Relic-reported events and attributes ",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "af971d2b95ff397b57bf125f6801f57007ea5e77",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/customized-security-settings-insights/",
      "published_at": "2021-09-02T11:25:51Z",
      "updated_at": "2021-05-15T09:10:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, New Relic products report a variety of data used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. Default events and attributes Our products report a set of default events and attributes. We will never send request parameters or any other attributes that are not in the default set, unless someone has explicitly enabled this via configuration. Adjust the data reported When evaluating security settings for a New Relic product, review the default events and attributes. The default attributes don't contain sensitive data. In general, it's simply the data needed for effective performance monitoring. Our products don't send other data unless you change the default security settings. Depending on your requirements, either or both of these situations may apply: If the default list contains data you're concerned about, you can disable those attributes from being collected. For how to edit that, see the documentation for the product you're using. If you need to send attributes not reported by default, you can enable those attributes to be reported. In that case, do not use high security mode: this will disable the ability to collect custom attributes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.78192,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for New Relic-reported <em>events</em> and attributes ",
        "sections": "<em>Default</em> <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "By <em>default</em>, New Relic products report a variety of <em>data</em> used in our UI charts and that is available for querying. Our products will not transmit sensitive information without being explicitly instrumented to do so. <em>Default</em> <em>events</em> and attributes Our products report a set of <em>default</em> <em>events</em>"
      },
      "id": "60a8ea67e7b9d25ec7aeabfe"
    },
    {
      "sections": [
        "Default events reported by New Relic products"
      ],
      "title": "Default events reported by New Relic products",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Default events"
      ],
      "external_id": "217bc4ed58acefe9175df8be18fdf81baba7cf81",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/default-events-reported-new-relic-products/",
      "published_at": "2021-09-02T11:26:54Z",
      "updated_at": "2021-05-15T09:09:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic products report different types of data. One type of data reported is event data. Events are displayed in UI charts and tables, and also made available for querying. To understand the types of data available, see Data available via NRQL. Learn more about the events reported by New Relic products: APM default events Browser default events Infrastructure default events Mobile default events Synthetics default events NrAuditEvent events for understanding changes to your account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.78181,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Default</em> <em>events</em> reported by New Relic products",
        "sections": "<em>Default</em> <em>events</em> reported by New Relic products",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "New Relic products report different types of <em>data</em>. One type of <em>data</em> reported is <em>event</em> <em>data</em>. <em>Events</em> are displayed in UI charts and tables, and also made available for querying. To understand the types of <em>data</em> available, see <em>Data</em> available via NRQL. Learn more about the <em>events</em> reported by New Relic"
      },
      "id": "609f8faf64441f8af9d2a1f0"
    },
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-09-01T21:23:26Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.73723,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Insights</em> Dashboard API",
        "sections": "<em>Insights</em> Dashboard API",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " and DELETE endpoints are not available. To make the transition from the <em>Insights</em> Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts <em>data</em> in the EU <em>data</em> center"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/nrauditevent-event-data-query-examples": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/query-account-audit-logs-nrauditevent/",
      "sections": [
        "Query account audit logs (NrAuditEvent)",
        "Account data security and retention",
        "Run NrAuditEvent query"
      ],
      "published_at": "2021-09-02T11:27:59Z",
      "title": "Query account audit logs (NrAuditEvent)",
      "updated_at": "2021-07-16T07:17:59Z",
      "type": "docs",
      "external_id": "0d7ba78f9aa862a1d90b29d09d0137b804a22d6f",
      "document_type": "page",
      "popularity": 1,
      "body": "As an additional security measure for managing your New Relic account, you can use the NrAuditEvent event to view audit logs that show changes in your New Relic account. This includes: Individuals added or deleted Role changes Account changes made via API Synthetic monitor changes Dashboard deletion Workload configuration changes You can also use alerts to be notified about changes in your New Relic account. Account data security and retention All New Relic accounts can query up to 13 months of account changes. To ensure account security, the audit logging NRQL query only tracks changes in your currently selected account. It does not show audit log events for any associated child accounts. To query changes in another account or sub-account, select the account and run a NRQL query there. Audit logging is different than configuring audit mode for your APM agent. APM audit mode records information about all data being transmitted from your app. Run NrAuditEvent query To track and view changes in your New Relic account: At any NRQL interface, run the following query, adjusting the time frame as needed up to thirteen months: SELECT * from NrAuditEvent SINCE 1 day ago Copy To customize your query, use any of the available NrAuditEvent attributes. To be notified about account changes, create NRQL conditions with New Relic Alerts. To query changes in another account, select the account and run a separate NRQL query for that account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.42404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> account <em>audit</em> logs (<em>NrAuditEvent</em>)",
        "sections": "<em>Query</em> account <em>audit</em> logs (<em>NrAuditEvent</em>)",
        "body": " information about all <em>data</em> being transmitted from your app. Run <em>NrAuditEvent</em> <em>query</em> To track and view changes in your New Relic account: At any NRQL interface, run the following <em>query</em>, adjusting the time frame as needed up to thirteen months: SELECT * from <em>NrAuditEvent</em> SINCE 1 day ago Copy To customize"
      },
      "id": "60a8eb1fe7b9d202f1aeac03"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/nrintegrationerror/",
      "sections": [
        "Use NrIntegrationError event to understand data ingest problems",
        "Troubleshoot data ingest with NrIntegrationError",
        "Query and alert",
        "Query of Event API issues",
        "Query of Metric API issues",
        "Limit-related queries",
        "Query of distributed tracing issues",
        "Query of issues over time",
        "Tutorials and examples",
        "Ingest APIs",
        "Data limits",
        "Specific agents and integrations",
        "Programmatically use NrIntegrationError events",
        "Understand changes to your account"
      ],
      "published_at": "2021-09-01T19:46:21Z",
      "title": "Use NrIntegrationError event to understand data ingest problems",
      "updated_at": "2021-08-20T15:44:59Z",
      "type": "docs",
      "external_id": "ebd122a6362cabe2e1911466eec0fbc0303fef77",
      "document_type": "page",
      "popularity": 1,
      "body": "Use New Relic's NrIntegrationError event to understand problems related to data ingest, limits, and feature configuration. Troubleshoot data ingest with NrIntegrationError Our NrIntegrationError event is used to capture issues related to: Exceeding of our data ingest limits Exceeding of our query limits Malformed data Configuration issues You can run NRQL queries to analyze NrIntegrationError error messages. You can also set up alerts to be notified when specific types of errors, or certain quantities of errors, occur. NrIntegrationError events are primarily categorized by the feature that is sending them, as indicated by the newRelicFeature attribute. Values include: Metrics indicates an issue with Metric API ingest. Event API indicates an issue with Event API ingest. Logs indicates an issue with logs ingest. Distributed Tracing indicates an issue with distributed tracing (Span) data. For attribute definitions, see the data dictionary. Query and alert You can query NrIntegrationError events using NRQL, and set up NRQL alert conditions to get notified when issues happen. Here are some examples of queries: Query of Event API issues Here's a simple query of NrIntegrationError. This one shows Event API ingest issues from the last week, with up to 100 results: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' SINCE 1 WEEK AGO LIMIT 100 Copy For more detailed queries, see Example queries. Query of Metric API issues Here's a simple query of issues with the Metric API: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' SINCE 1 WEEK AGO LIMIT 100 Copy For more detailed queries, see Example queries. Limit-related queries See Data limits. Query of distributed tracing issues Here's a simple query of issues with distributed tracing data: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Distributed Tracing' SINCE 1 WEEK AGO LIMIT 100 Copy For more detailed queries, see Example queries. Query of issues over time Here's a query showing a count of NrIntegrationError events over time: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature = 'Metrics' TIMESERIES Copy For more detailed queries, see Example queries. If you want to examine the structure of this event and see what attributes are attached, you can use a keyset() query, like this: FROM NrIntegrationError SELECT keyset() Copy Tutorials and examples Here are links to docs that go into more detail about how to use NrIntegrationError. Ingest APIs Below are NrIntegrationError-related docs for our core ingest APIs. NrIntegrationError events are generated not just for direct use of these APIs but for any New Relic tools that rely on those API endpoints for reporting data: Metric API: see Troubleshoot Metric API ingest Event API: see parsing errors and tips for troubleshooting event reporting. Log API: See No log data appears. Trace API: see Response validation and Troubleshoot missing data. Data limits Limit-related docs: View the limits UI (NrIntegrationError is used to create these charts) Limit-related query examples Specific agents and integrations APM agent: Config mismatch StatsD Prometheus: OpenMetrics errors | Remote write errors Programmatically use NrIntegrationError events If you're interested in manipulating these events via API, see Programmatically use NrIntegrationError. Understand changes to your account If you're trying to understand changes that have been made in your New Relic account (like when a user made a change), see NrAuditEvent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 319.533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NrIntegrationError</em> <em>event</em> to understand <em>data</em> ingest problems",
        "sections": "Use <em>NrIntegrationError</em> <em>event</em> to understand <em>data</em> ingest problems",
        "body": ". For attribute definitions, see the <em>data</em> dictionary. <em>Query</em> and alert You can <em>query</em> <em>Nr</em>IntegrationError events using NRQL, and set up NRQL alert conditions to get notified when issues happen. Here are some <em>examples</em> of queries: <em>Query</em> of <em>Event</em> API issues Here&#x27;s a simple <em>query</em> of <em>Nr</em>"
      },
      "id": "610f1e9564441f259347ac11"
    },
    {
      "sections": [
        "NerdGraph tutorial: Manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Tip",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "NerdGraph tutorial: Manage license keys and user keys",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-09-02T03:48:08Z",
      "updated_at": "2021-08-27T02:32:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys Tip You can find and generate user keys using the NerdGraph GraphiQL explorer, at the top of that interface. To create multiple keys (user key or license key) in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 312.78748,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph tutorial: Manage license keys <em>and</em> user keys",
        "sections": "Before using <em>examples</em>",
        "tags": "<em>Examples</em>",
        "body": " as arguments, and will return details about successful changes and errors. See <em>examples</em> below for details. All mutations (create, update and delete) will result in an <em>NrAuditEvent</em> that can be queried for auditing purposes. For details, see <em>Audit</em> events. Regarding license keys: License keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/event-data/query-account-audit-logs-nrauditevent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/nrauditevent-event-data-query-examples/",
      "sections": [
        "NrAuditEvent event data and query examples",
        "Available events and attributes",
        "Example queries",
        "General account changes",
        "What changes have been made to the New Relic account?",
        "What type of account change was made the most?",
        "What trends appear in account changes?",
        "What user management changes have been done?",
        "Synthetics: What changes have been made to a monitor?",
        "Workloads: What changes were made to any workload configuration?",
        "Changes made by specific users",
        "What account changes have been made by any user?",
        "What account changes have been made by a specific user?",
        "Who made the most changes to the account?",
        "Synthetics: What monitors were created by a specific user?",
        "Changes made using the API",
        "What account changes have been made using an API key?"
      ],
      "published_at": "2021-09-02T11:51:26Z",
      "title": "NrAuditEvent event data and query examples",
      "updated_at": "2021-05-15T09:10:01Z",
      "type": "docs",
      "external_id": "1cb581c67b8196fedfd66c9eb527bd88e6090a40",
      "document_type": "page",
      "popularity": 1,
      "body": "To view changes made in your New Relic account, you can query NrAuditEvent events. Available events and attributes The NrAuditEvent is created to record configuration changes made in our products. The data gathered for this event includes the type of account change, actor (user or API key) that made the change, a human-readable description of the action taken, and a timestamp for the change. To see all the attributes attached to this event, see NrAuditEvent. Example queries These examples show some of the ways you can run NRQL queries of the NrAuditEvent event. General account changes What changes have been made to the New Relic account? To view all changes to your New Relic account for a specific time frame, run this basic NRQL query: SELECT * from NrAuditEvent SINCE 1 day ago Copy What type of account change was made the most? To query what type of change to the account users was made the most frequently during a specific time frame, include the actionIdentifier attribute in your query. For example: SELECT count(*) AS Actions FROM NrAuditEvent FACET actionIdentifier SINCE 1 week ago Copy What trends appear in account changes? When you include TIMESERIES in a NRQL query, the results are shown as a line graph. For example: SELECT count(*) from NrAuditEvent TIMESERIES facet actionIdentifier since 1 week ago Copy What user management changes have been done? Note that your users' user model will impact these queries. If your users are on our original user model, you can only query per account. If your users are on the New Relic One user model, you should query the top-level account in your New Relic organization. To see all the changes made to users, you could use: SELECT * FROM NrAuditEvent WHERE targetType = 'user' SINCE this month Copy If you wanted to narrow that down to see changes to user type (full user vs basic user), you could use: SELECT * FROM NrAuditEvent WHERE targetType = 'user' AND actionIdentifier IN ('user.self_upgrade', 'user.change_type') SINCE this month Copy Synthetics: What changes have been made to a monitor? To query Synthetics monitor updates during a specific time frame, include the actionIdentifier attribute in your query. For example: SELECT count(*) FROM NrAuditEvent WHERE actionIdentifier = 'synthetics_monitor.update_script' FACET actionIdentifier, description, actorEmail SINCE 1 week ago LIMIT 1000 Copy For more information about this Synthetics feature, see Synthetics audit log. Workloads: What changes were made to any workload configuration? To query what configuration changes were made to any workload, use the query below. The targetId attribute contains the GUID of the workload that was modified, which you can use for searches. Since changes on workloads are often automated, you might want to include the actorType attribute to know if the change was done directly by a user through the UI or through the API. SELECT timestamp, actorEmail, actorType, description, targetId FROM NrAuditEvent WHERE targetType = 'workload' SINCE 1 week ago LIMIT MAX Copy Changes made by specific users What account changes have been made by any user? To see detailed information about any user who made changes to the account during a specific time frame, include actorType = 'user' in the query. For example: SELECT actionIdentifier, description, actorEmail, actorId, targetType, targetId FROM NrAuditEvent WHERE actorType = 'user' SINCE 1 week ago Copy What account changes have been made by a specific user? To query account activities made by a specific person during the selected time frame, you must know their actorId. For example: SELECT actionIdentifier FROM NrAuditEvent WHERE actorId = 829034 SINCE 1 week ago Copy Who made the most changes to the account? To identify who (actorType) has made the most changes to the account, include the actorEmail attribute in your query. For example: SELECT count(*) as Users FROM NrAuditEvent WHERE actorType = 'user' FACET actorEmail SINCE 1 week ago Copy Synthetics: What monitors were created by a specific user? To query Synthetics monitor updates made by a specific user, include the actionIdentifier and actorEmail attribute in your query. For example: SELECT count(*) FROM NrAuditEvent WHERE actionIdentifier = 'synthetics_monitor.update_script' FACET actorEmail, actionIdentifier, description SINCE 1 week ago LIMIT 1000 Copy Changes made using the API What account changes have been made using an API key? To see detailed information about changes to the account that were made using an API key during a specific time frame, include actorType = 'api_key' in the query. For example: SELECT actionIdentifier, description, targetType, targetId, actorAPIKey, actorId, actorEmail FROM NrAuditEvent WHERE actorType = 'api_key' SINCE 1 week ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 345.78778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NrAuditEvent</em> <em>event</em> data and <em>query</em> examples",
        "sections": "<em>NrAuditEvent</em> <em>event</em> data and <em>query</em> examples",
        "body": "To view changes made in your New Relic <em>account</em>, you can <em>query</em> <em>NrAuditEvent</em> events. Available events and attributes The <em>NrAuditEvent</em> is created to record configuration changes made in our products. The data gathered for this <em>event</em> includes the type of <em>account</em> change, actor (user or API key"
      },
      "id": "60a8e35ce7b9d2b07caeabdd"
    },
    {
      "sections": [
        "Synthetic monitoring audit log: Track changes made by users",
        "Feature description",
        "Query details",
        "Example use case: Finding changes made by a user"
      ],
      "title": "Synthetic monitoring audit log: Track changes made by users",
      "type": "docs",
      "tags": [
        "Synthetics",
        "Synthetic monitoring",
        "Administration"
      ],
      "external_id": "4673ae884e9d00a1c90e9577f2b8ff229b73b543",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/administration/synthetic-monitoring-audit-log-track-changes-made-users/",
      "published_at": "2021-09-02T16:49:47Z",
      "updated_at": "2021-03-16T18:11:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic lets you see a 13-month history of synthetic monitoring audit events. Feature description When you take specific actions in synthetic monitoring like creating or editing a monitor, an NrAuditEvent is generated. This event includes details about the action taken and which user took that action. This data is stored for 13 months. This historical data may be helpful if you'd like to investigate how a problem with your account was created and who made that change. Synthetic monitoring's changes tracked include: Monitors Creation Edits (including location change, mute/unmute, and enable/disable) Script creation, edits, validation (including secure credentials used) Deletion Monitor downtimes Creation Edits Deletion Secure credentials Creation Edits Views Deletion Private locations Creation Edits (including clearing queues) Deletion For details on how to query this data, see Query details. Query details To query changes, use the query builder to explore the NrAuditEvent and its associated attributes. For an introduction to using the NrAuditEvent event, see Query account audit logs. Supported actionIdentifier events currently include: Monitors synthetics_monitor.create synthetics_monitor.update synthetics_monitor.create_script synthetics_monitor.update_script synthetics_monitor.validate_script synthetics_monitor.delete Monitor downtimes synthetics_monitor_downtime.create synthetics_monitor_downtime.update synthetics_monitor_downtime.delete Secure credentials synthetics_secure_credential.create synthetics_secure_credential.update synthetics_secure_credential.view synthetics_secure_credential.delete Private locations synthetics_private_location.create​ synthetics_private_location.update​ synthetics_private_location.delete How the change was made: The actorAPIKey attribute indicates if the change was made via the API or by a user via the UI. When this value is null, it's a user update; when not null, it's an API update. For examples of synthetic monitoring's audit log queries, see: The example use case. The synthetic monitoring specific examples in Audit query examples. Example use case: Finding changes made by a user Here's an example of using the synthetic monitoring audit log to solve a common problem: You are a manager at a company that uses synthetic monitoring. A new employee has been playing with your company's accounts to learn how synthetic monitoring works. Unfortunately, this employee was accidentally given full access to the production accounts, instead of the pre-production accounts. You want to determine what synthetic monitors this employee created, deleted, and updated, so that you will know which monitors need to be fixed. Instead of having to review every monitor in the account, you open the query builder and run the following NRQL query of the NrAuditEvent event: SELECT count(*) FROM NrAuditEvent WHERE actionIdentifier = 'synthetics_monitor.update_script' AND actorEmail = 'EMPLOYEE_EMAIL' FACET actionIdentifier, description SINCE 1 week ago LIMIT 1000 Copy The query will return all the synthetic monitors that the employee has updated, deleted, created, disable, or muted. One by one, you and the employee review the list and update the edited monitors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 338.27625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Synthetic monitoring <em>audit</em> <em>log</em>: Track changes made by users",
        "sections": "Synthetic monitoring <em>audit</em> <em>log</em>: Track changes made by users",
        "body": " details. <em>Query</em> details To <em>query</em> changes, use the <em>query</em> builder to explore the <em>NrAuditEvent</em> and its associated attributes. For an introduction to using the <em>NrAuditEvent</em> <em>event</em>, see <em>Query</em> <em>account</em> <em>audit</em> <em>logs</em>. Supported actionIdentifier events currently include: Monitors synthetics_monitor.create"
      },
      "id": "603eb96fe7b9d251b82a07cd"
    },
    {
      "sections": [
        "NerdGraph tutorial: Manage license keys and user keys",
        "Overview of feature description",
        "Before using examples",
        "Create keys",
        "Tip",
        "Create a user key",
        "Update keys",
        "Delete keys",
        "Query keys"
      ],
      "title": "NerdGraph tutorial: Manage license keys and user keys",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "5610c77ebfcd92d59c1d0a1b15343f499c8e310e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys/",
      "published_at": "2021-09-02T03:48:08Z",
      "updated_at": "2021-08-27T02:32:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains tutorials on how to use NerdGraph to programmatically manage some New Relic API keys. For general information about New Relic keys, see API keys. Overview of feature description You can use the API keys UI to create and manage keys. Alternatively, you can use NerdGraph's ApiAccess field to programmatically create and manage the following types of keys: User keys License keys, including: General license key (used for APM, infrastructure monitoring, more) Browser key (for browser monitoring) One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. Notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Regarding license keys: License keys are categorized by NerdGraph as ingest keys. This is because their main use is to allow data ingest. You can create up to 1,000 keys of each license key type, which allows for key rotation. You can't manage or delete original license keys; you can only create additional license keys and manage keys you've created. Before using examples Things to note before using these example queries: The examples below use license keys (aka ingest keys), but you can query user keys in similar ways, replacing the ingest-key-specific fields with user-key-specific fields. To understand the data structure, we recommend experimenting with queries using the GraphiQL explorer. You can also create, view, and delete user keys using the UI. Create keys Tip You can find and generate user keys using the NerdGraph GraphiQL explorer, at the top of that interface. To create multiple keys (user key or license key) in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Here's an example of using this query to create a user key: Create a user key To create a user key, you'd change the above query slightly, in the keys section: mutation { apiAccessCreateKeys(keys: {user: {accountId: YOUR_ACCOUNT_ID, userId: YOUR_USER_ID}}) { createdKeys { id key name notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Copy Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Copy Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Copy Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.01764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Query</em> keys",
        "body": " as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an <em>NrAuditEvent</em> that can be queried for auditing purposes. For details, see <em>Audit</em> events. Regarding license keys: License keys"
      },
      "id": "603e96bf28ccbc326aeba75c"
    }
  ],
  "/docs/telemetry-data-platform/understand-data/metric-data/metric-data-type": [
    {
      "sections": [
        "Introduction to the Metric API",
        "What is the Metric API?",
        "Requirements",
        "Get started",
        "Find and use your data",
        "Alert on metric data",
        "Data retention",
        "Troubleshooting"
      ],
      "title": "Introduction to the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "6641228194261fb156e88acfed2dcd79754d2dc5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/introduction-metric-api/",
      "published_at": "2021-09-02T11:49:23Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Metric API can be used to send metric data to New Relic from a variety of sources. This API is how metrics from some of our integrations and exporters get into New Relic. Want to try out our Metric API? Create a New Relic account for free! No credit card required. What is the Metric API? The Metric API is a way to get metric data into New Relic. The API works by sending a POST request to our HTTP endpoint with a JSON payload containing the metric data. The Metric API is how metrics are ingested from some of our integrations, including our open source exporters (like DropWizard, OpenCensus, and Prometheus). The Metric API is also used by our Telemetry SDKs, which are language-specific tools that make it easier to use our data-ingest APIs. The Metric API can be used to: Report metric data to New Relic without a New Relic agent. Integrate metric data from an open source or in-house developed tool, library, or framework. Fully control the metric data you're sending, including the resolution and associated dimensions. Leverage the power of NRQL, New Relic's query language, for querying your metric data. Set up alerts for your metric data. Requirements Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name metric-api.newrelic.com or metric-api.eu.newrelic.com. You'll need a New Relic license key for the New Relic account you want to send data to. For information on limits and restricted attributes, see Metric API requirements and limits. Get started If we don't have an existing integration that meets your metric-reporting needs, you have two options: Use our Telemetry SDKs, which are language-specific tools that help you send us metrics and other data. Use the Metric API directly. Find and use your data You can find data sent via the Metric API (including from integrations that use this API) in these locations: From one.newrelic.com, select Explorer and look for your service. By querying the Metric data type. For example, you can use NRQL to run: SELECT * FROM Metric Copy For more on querying, see Metric query examples. For information on querying in general, see Query data. Alert on metric data To alert on metrics created with the Metric API, use NRQL alert conditions: Select the NRQL category when defining your condition, then use the FROM Metric ... NRQL query syntax to express it. When you create these alert conditions, Alerts automatically uses the finest granularity data available (the raw metric data points) to evaluate alerts. Data retention All raw metric data points will be retained for 30 days. All additional aggregated data derived from the raw metric data points (for example, one-minute rollups) will be retained for 13 months. Any change to the retention period beyond such periods may result in a charge to you. Troubleshooting See Troubleshoot an NrIntegrationError event.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.66058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find <em>and</em> use your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", OpenCensus, and Prometheus). The Metric API is also used by our <em>Telemetry</em> SDKs, which are language-specific tools that make it easier to use our <em>data</em>-<em>ingest</em> APIs. The Metric API can be used to: Report metric <em>data</em> to New Relic without a New Relic agent. Integrate metric <em>data</em> from an open source"
      },
      "id": "6107858fe7b9d2f9dcfc108e"
    },
    {
      "sections": [
        "Report metrics via the Metric API",
        "Quick start: Send metric data",
        "Endpoint URL",
        "Tip",
        "HTTP request headers",
        "HTTP request body",
        "Structure",
        "JSON payload creating two metrics",
        "Required key-value pairs",
        "JSON payload with three metric types",
        "Share attributes across metrics with common",
        "Example of common attributes",
        "Response validation and status codes",
        "Missing data with 202 response",
        "Status codes"
      ],
      "title": "Report metrics via the Metric API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "dc117e1fa9345c0d05e7a8274b31b92b29134f0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/metric-api/report-metrics-metric-api/",
      "published_at": "2021-09-02T11:50:19Z",
      "updated_at": "2021-08-27T01:24:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Metric API to send custom metrics to the New Relic platform. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric data. Quick start: Send metric data We report the metric types count, gauge, and summary. For more information on metrics see our documentation. Metric data is submitted to New Relic through an HTTP POST request. Each request is composed of one or more metric data points, which consist of a metric name, a timestamp, and a value. Follow this example to send your first metric data points to New Relic: Get the license key for the account you want to report data to. Insert the license key into the following JSON, and then send the JSON to our endpoint. This example creates a single metric data point for a metric named memory.heap, but you can create additional attributes or data points by specifying metric types or adding optional common blocks. curl -vvv -k -H \"Content-Type: application/json\" \\ -H \"Api-Key: NEW_RELIC_LICENSE_KEY\" \\ -X POST https://metric-api.newrelic.com/metric/v1 \\ --data '[{ \"metrics\":[{ \"name\":\"memory.heap\", \"type\":\"gauge\", \"value\":2.3, \"timestamp\":CURRENT_TIME, \"attributes\":{\"host.name\":\"dev.server.com\"} }] }]' Copy The metric should be available in New Relic in a few seconds. You can query the data from any NRQL interface using this query: FROM Metric SELECT max(memory.heap) TIMESERIES Copy For more on where data shows up, see Find Metric API data. Endpoint URL Use an HTTP POST when sending metric data to the metric API endpoint: https://metric-api.newrelic.com/metric/v1 Copy Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. HTTP request headers Include the following HTTP request headers with the POST request. You can send some parameters as query parameters instead of request headers. Header Send as a query parameter? Details Content-Type No Required. Must be application/json. Content-Length No Required (usually set automatically by the HTTP client). The length of the request body in octets (8-bit bytes) unless sent with chunked encoding. This header is generally set by default by the underlying HTTP client sending the data and in most cases should not require any additional effort by the end user. Api-Key Yes Required. A license key for the account you want to report data to. If this is provided as both a header and a query parameter, the values must match. Content-Encoding No Required if GZIP. The value must be GZIP or Identity. If no value is present, then Identity is assumed. x-request-id No Optional - Reserved for future use. The value must be a valid UUID4. The value is expected to be unique for each request. HTTP request body The body of the HTTP POST request must be in JSON format. The following describes the requirements and recommendations for the JSON payload. The payload must be encoded as UTF-8. Structure The JSON payload uses this structure: The JSON payload is an array of maps. Each map must contain a metrics key whose value is an array containing one or more metric data points. A metric data point is identified by a name, value, and timestamp along with an optional set of attributes. JSON payload creating two metrics This example payload creates two metrics. service.errors.all is a count metric with three attributes and service.memory is a gauge metric with two attributes. [ { \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"service.response.statuscode\": \"400\", \"host.name\": \"dev.server.com\", \"service.name\": \"foo\" } }, { \"name\": \"service.memory\", \"type\": \"gauge\", \"value\": 2.7, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Required key-value pairs Each metric data point map in the metrics array uses the following key-value structure: Key Description name string Required. The name of the metric. The value must be less than 255 characters. value number or map Required. The value varies depending on the metric type. For gauge and count the value should be a single number. For summary, the value should be a map with key-value pairs specifying the count, sum, min, and max. timestamp long Required. The metric's start time in Unix time. Defaults to the current time in UTC timezone. This field also support seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and query. Metrics reported with a timestamp older than 48 hours ago or newer than 24 hours from the time they are reported are dropped. interval.ms positive long Required for count and summary metric types. The length of the time window. type Recommended. This should be one of the supported metric types. If you do not specify a type, then this will default to a gauge. attributes strings, JSON numbers, or booleans Recommended. A map of key value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Keys are case-sensitive and must be less than 255 characters. JSON payload with three metric types Here's an example payload containing one metric data point for each metric type: [ { \"metrics\": [ { \"name\": \"cache.misses\", \"type\": \"count\", \"value\": 15, \"timestamp\": [CURRENT_TIME](#optional-map-attributes), \"interval.ms\": 10000, \"attributes\": { \"cache.name\": \"myCache\", \"host.name\": \"dev.server.com\" } }, { \"name\": \"temperature\", \"type\": \"gauge\", \"value\": 15, \"timestamp\": CURRENT_TIME, \"attributes\": { \"city\": \"Portland\", \"state\": \"Oregon\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"interval.ms\": 10000, \"timestamp\": CURRENT_TIME, \"attributes\": { \"host.name\": \"dev.server.com\", \"app.name\": \"foo\" } } ] } ] Copy Share attributes across metrics with common If you want to include a set of attributes on multiple metrics (and not add the same attributes for each metric), you can use the common block. This is an optional map that specifies information that applies to all associated metric data points. Values in the common section will be overridden if the same key exists on a metric data point. The block can include: Attribute Description timestamp long The metric's start time in Unix time. This defaults to the current time in the UTC timezone. This field also supports seconds, microseconds, and nanoseconds. However, the data will be converted to milliseconds for storage and later querying. interval.ms positive long Required for count and summary.The length of the time window. attributes strings, JSON numbers, or booleans A map of key-value pairs associated with this specific metric. Values can be strings, JSON numbers, or booleans. Example of common attributes In the following example payload, three metrics are sent. All three metrics share app.name and host.name attributes, specified in the common block. Each metric also has a unique value for another attribute, server.response.statuscode. [ { \"common\" : { \"timestamp\": 1531414060739, \"interval.ms\": 10000, \"attributes\": { \"app.name\": \"foo\", \"host.name\": \"dev.server.com\" } }, \"metrics\": [ { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 9, \"attributes\": { \"service.response.statuscode\": \"400\" } }, { \"name\": \"service.errors.all\", \"type\": \"count\", \"value\": 4, \"attributes\": { \"service.response.statuscode\": \"500\" } }, { \"name\": \"service.response.duration\", \"type\": \"summary\", \"value\": { \"count\": 5, \"sum\": 0.004382655, \"min\": 0.0005093, \"max\": 0.001708826 }, \"attributes\": { \"service.response.statuscode\": \"200\" } } ] } ] Copy Response validation and status codes The Metric API returns a 202 response code for successful requests. When your data is accepted, an HTTP 202 response code is returned with a response structure like this: HTTP/1.1 202 Accepted Content-Type: application/json; charset=UTF-8 Content-Length: 52 Access-Control-Allow-Methods: GET, POST, PUT, HEAD, OPTIONS Access-Control-Allow-Credentials: true Access-Control-Allow-Origin: * Connection: keep-alive {\"requestId\":\"f0e7bfff-001a-b000-0000-01682bcf4565\"} Copy Missing data with 202 response A 202 code indicates the API did receive your data, and that the data passed basic validation checks. Normally, your data will be available for querying within a few seconds. However, New Relic runs additional validation asynchronously after receiving your data. If you receive a 202 response but can't find your metric, this indicates that New Relic found an error during this asynchronous validation. You can find these errors by querying NrIntegrationError events in the account associated with the Insert API key you used. The requestId for each request will be tagged on the NrIntegrationError event. For more information, see Troubleshoot an NRIntegrationError event. Status codes The Metric API can return the following HTTP status codes: Status code Definition 202 Data accepted. 400 Structure of the request is invalid. 403 Authentication failure. 404 The request path is incorrect. 405 Used a request method other than POST. 408 The request took too long to reach the endpoint. 411 The Content-Length header wasn’t included. 413 The payload was too big. Payloads must be under 1MB (10^6 bytes). 414 The request URI was too long. 415 The Content-Type or Content-Encoding was invalid. 429 The request rate quota has been exceeded. 431 The request headers are too long. 5xx There was a server error (please retry).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.66058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Quick start: Send metric <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": "Use the Metric API to send custom metrics to the New Relic <em>platform</em>. This document includes a quick start to send your first custom metric, plus detailed information on how to format and send your metric <em>data</em>. Quick start: Send metric <em>data</em> We report the metric types count, gauge, and summary"
      },
      "id": "6107859064441f8baf47abd9"
    },
    {
      "sections": [
        "Introduction to the Event API",
        "Requirements",
        "Basic workflow",
        "Tip",
        "Get the license key",
        "Format the JSON",
        "JSON format guidelines",
        "JSON example",
        "Limits and restricted characters",
        "Submit the custom event",
        "Linux/bash example",
        "Windows/PowerShell example",
        "Important",
        "Verify or troubleshoot request response",
        "Success response code",
        "Submission errors",
        "Parsing errors",
        "Query and alert with NrIntegrationError",
        "Find your data",
        "Limit on HTTP requests"
      ],
      "title": "Introduction to the Event API",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "0e0f5ad678bc1756a2cf7db88a52df2c2983bbe4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/introduction-event-api/",
      "published_at": "2021-09-01T21:57:54Z",
      "updated_at": "2021-08-26T19:44:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Event API is one way to report custom events to New Relic. The Event API lets you send custom event data to your New Relic account with a POST command. These events are then queryable and chartable using NRQL. Want to try out our Event API? Create a New Relic account for free! No credit card required. Related content: Learn about all options for reporting custom events. For details about how event data is retained, see Event data retention. For how to add attributes to existing events, see Add custom attributes. Check out New Relic University’s tutorial Adding custom events with the Event API (aka the Insights API). Or, go directly to the full online course Custom data. Requirements For Event API limits and restricted attributes, see Limits. Ensure outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. The preferred configuration method is to use the DNS name insights-collector.newrelic.com or insights-collector.eu01.nr-data.net. Basic workflow The Event API is an asynchronous endpoint. This allows you to send a very large volume of POSTS, reliably, with very low response latency. Tip If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. To send a custom event to a New Relic account: Get a license key for the account you want to report data to. Before creating custom events or attributes, review New Relic's list of reserved terms used by NRQL. Generate JSON for the event by instrumenting your application, querying an API, or some other method. Submit a compressed JSON payload (for example, gzip or deflate) to the HTTPS endpoint using curl in a POST request. Recommendation: Set up NRQL alert conditions to notify you when parsing errors occur. This method will send the events directly into your account, where they will be accessible from any NRQL interface or with the Query API. The Event API limits the size, rate, and characters allowed in custom events. Also, like other events available in NRQL, custom events cannot be updated or deleted after they are created. If you have problems with your custom event, follow the troubleshooting procedures or create a new custom event. Get the license key You'll need a license key. License keys are associated with an account, not a specific user. This means that anyone in the account with access to that key can use it. You can submit multiple event types to the same account with the same license key. However, to help ensure security, we recommend that you use different keys for different applications or data sources. Alternatively, you can use an Insights insert keyfor this API, but we recommend using a license key. Format the JSON The Event API accepts specific formats for attributes included in the payload. Only float or string values are allowed. JSON format guidelines When defining attributes for your custom events, follow these JSON format guidelines. Attributes JSON format guidelines eventType Required: The event's name. Float and string values Float value format: \"label\":value String value format: \"label\":\"value\" Data types The API only accepts key-value pairs, not map/object or array values. Supported data types for this API are strings and numbers (integers or floats). For more information, see Data requirements. Digits in strings For performance-related reasons, we do not cast values submitted to the API. For example, we treat 123 as a number and \"123\" as a string. The database will only store up to 64 bit numbers. Any numbers larger than 64 bits will be truncated. Dates For attributes that contain date information, use an unformatted Unix timestamp in the Insights data formatter. You can define the date attribute either in seconds or in milliseconds, both relative to the Unix epoch. Time Unless otherwise specified, the timestamp for a submitted event is the time it was submitted to New Relic. To specify a different time for the event, use the timestamp attribute. JSON example Here is an example of a typical JSON data set for sending with the API. This call sends two Purchase type events as a JSON array. You can add multiple events in a single HTTP call using a JSON array. [ { \"eventType\":\"Purchase\", \"account\":3, \"amount\":259.54 }, { \"eventType\":\"Purchase\", \"account\":5, \"amount\":12309, \"product\":\"Item\" } ] Copy When generating the JSON, make sure your attributes are properly formatted. Limits and restricted characters The following size and rate limits apply to events sent via the Event API: Max events per API call: 2K Payload total size: 1MB(10^6 bytes) maximum per POST. We highly recommend using compression. The payload must be encoded as UTF-8. Number of attributes per event: 255 maximum Length of attribute name: 255 characters Length of attribute value: 4096 maximum character length There are rate limits on the number of HTTP requests per minute sent to the Event API. Some specific attributes have additional restrictions: accountId: This is a reserved attribute name. If it is included, it will be dropped during ingest. entity.guid, entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric data point may cause undefined behavior such as missing entities in the UI or telemetry not associating with the expected entities. For more information please refer to Entity synthesis. appId: Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType: Can be a combination of alphanumeric characters, _ underscores, and : colons. timestamp: Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. Submit the custom event Data submitted to the Event API uses a compressed JSON format in a simple HTTPS POST request. This example uses gzip, but you can also use deflate. Linux/bash example gzip -c example_events.json | curl -X POST -H \"Content-Type: application/json\" -H \"Api-Key: YOUR_LICENSE_KEY\" -H \"Content-Encoding: gzip\" https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events --data-binary @- Copy Windows/PowerShell example $accountId = \"YOUR_ACCOUNT_ID\" $insertkey = \"YOUR_LICENSE_KEY\" # Replace with your custom event for the body $body = '[{\"eventType\": \"powershell\", \"account\": 4, \"amount\": 123, \"fileLocation\": \"c:\\\\temp2\", \"zipped\": \"true\" }]' $headers = @{} $headers.Add(\"Api-Key\", \"$insertkey\") $headers.Add(\"Content-Encoding\", \"gzip\") $encoding = [System.Text.Encoding]::UTF8 $enc_data = $encoding.GetBytes($body) $output = [System.IO.MemoryStream]::new() $gzipStream = New-Object System.IO.Compression.GzipStream $output, ([IO.Compression.CompressionMode]::Compress) $gzipStream.Write($enc_data, 0, $enc_data.Length) $gzipStream.Close() $gzipBody = $output.ToArray() Invoke-WebRequest -Headers $headers -Method Post -Body $gzipBody \"https://insights-collector.newrelic.com/v1/accounts/$accountId/events\" Copy Important Always use compression with every payload. This allows you to send more data, and it saves resources during parsing. Before generating your HTTP request, make sure it is properly formatted, including: The Api-Key contains the correct license key. The Content-Type is application/json. The request uses POST only. The API does not accept PUT and GET requests. The API supports HTTP/1.1 persistent connections. This is helpful to manage client-side performance under heavy event loads. Verify or troubleshoot request response The Event API follows a two-step process to process requests: The Event API synchronously acknowledges or rejects the request based on validation of the headers and payload size. The Event API asynchronously parses the payload after a successful HTTP response is provided to the client. This may generate an error due to missing or malformed data. These are classified as submission errors or parsing errors. All successful submissions receive a 200 response, regardless of any data errors that may exist within the payload. The response includes a uuid, which is a unique ID created for each request. The uuid also appears in any error events created for the request. Other potential issues: 10-second timeout: API calls exceeding 10 seconds will time out. Large payloads: Payloads exceeding 100 KB may see increased response times. Recommendation: In addition to checking for a success message, create a NRQL query of your data to verify it's available. Success response code Success message Comments 200 {\"success\":true,\"uuid\":\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\"} Copy Submission errors Payloads with submission errors are handled and returned to the sender through an HTTP response code. To troubleshoot payload submission errors, refer to these HTTP response codes. Submission errors Troubleshooting 400 Missing or invalid content length: Unable to process empty request. 403 Missing or invalid key: Invalid license key. Register a valid license key. 408 Request timed out: Request took too long to process. 413 Content too large: Request is too large to process. Refer to the limits and restricted characters to troubleshoot. 415 Invalid content type: Must be application/JSON. The Event API accepts any content type except multi-part/related and assumes it can be parsed to JSON. 429 Too many requests due to rate limiting. 503 Service temporarily unavailable: Retry request Parsing errors Parsing errors occur if: An event is sent within a payload, but it is either missing data or is exceeding maximum limits. New Relic will drop the individual event from the payload, generate an NrIntegrationError event, and process the rest. The JSON payload includes malformed JSON or missing required data. Payloads with parsing errors receive a 200 response to indicate a successful submission. To help resolve parsing errors, a new NrIntegrationError event type is created. All parsing errors are due to NRQL queries. For error messages related to dropped events, New Relic will include the number of events that were dropped as part of the message. To troubleshoot requests with parsing errors, refer to these error messages. Parsing errors Troubleshooting X event(s) rejected because attribute appId was not an integer An appId attribute has a non-integer value, such as a decimal value or string. X event(s) rejected because eventType cannot contain the following characters: [., \\] An eventType attributed included an invalid character, such as a period or backslash. X event(s) rejected because attribute is missing attribute name An attribute name was set to null or an empty string. X event(s) rejected because attribute name exceeded maximum length An attribute name has more than 255 characters. X event(s) rejected because attribute value exceeded maximum length An attribute value was longer than 4096 characters. X event(s) rejected because event exceeded maximum number of attributes An event has more than 255 attributes. X event(s) rejected because missing required attributes eventType The eventType attribute is required for the custom event. Error parsing JSON payload There was an error parsing the request JSON because of formatting problems or corrupted data. Query and alert with NrIntegrationError The NrIntegrationError event allows you to query and set alerts on custom data being sent to your New Relic account. Recommendation: To get alerts for parsing errors, create a NRQL alert condition for NrIntegrationError. Use this example NRQL query: SELECT message FROM NrIntegrationError WHERE newRelicFeature = 'Event API' AND category = 'EventApiException' Copy NrIntegrationError attributes Troubleshooting timestamp The timestamp when the request was received. The timestamp attribute takes a 64-bit integer Unix timestamp within the last 24 hours. You can define timestamps either in seconds or in milliseconds, both relative to the Unix epoch. Do not use a decimal for the timestamp. If a decimal is used, the attribute will default to the timestamp when the custom event was created. newRelicFeature The name of the feature experiencing errors. For all custom event parsing errors, this will be Event API. apiKeyPrefix The first six characters of the license key used for the request that generated an error. requestId The uuid returned by the the API for the request that generated an error. Category The category of the error. For custom events, this is EventApiException. Message Contents of the error message. Name The error's name. For custom events, this is always EventValidationException. eventTypeSample One of the event types that generated the error, when available. Find your data To find data sent via the Event API (and from integrations that use this API), you can query it. For example, to query a custom event using NRQL, you would run: SELECT * FROM YOUR_CUSTOM_EVENT Copy For more on how to query, see Query data. Limit on HTTP requests The Event API has a rate limit of 100,000 HTTP requests (POSTs) per minute, per account. (Note that this is not a limit on the number of events per minute; only on the number of POSTs per minute.) This limit helps ensure that large traffic spikes in accounts across our multi-tenant platform do not negatively affect how the service performs for you. If your API usage exceeds 100k POSTs in a 1-minute window, we will reject subsequent API requests with a 429 response code for the remainder of the 1-minute window. At the end of the 1-minute window, the counter will be reset and allow traffic to resume. This limit is intended to be an upper threshold that you shouldn't hit under normal scenarios. If you have a high number of 429 responses, consider using the API less. If you are expecting a higher-than-normal activity level in the near future and want to prepare for that, contact technical support.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.4227,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Find your <em>data</em>",
        "tags": "<em>Telemetry</em> <em>Data</em> <em>Platform</em>",
        "body": ", entity.name, and entity.type: These attributes are used internally to identify entities. Any values submitted with these keys in the attributes section of a metric <em>data</em> point may cause undefined behavior such as missing entities in the UI or <em>telemetry</em> not associating with the expected entities. For more"
      },
      "id": "609fa5fb64441f9d9fd2a1e2"
    }
  ]
}